<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql数据库插入数据</title>
      <link href="/2025/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2025/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库插入大数据"><a href="#MySQL数据库插入大数据" class="headerlink" title="MySQL数据库插入大数据"></a>MySQL数据库插入大数据</h1><h5 id="一、连接数据库创建表"><a href="#一、连接数据库创建表" class="headerlink" title="一、连接数据库创建表"></a>一、连接数据库创建表</h5><pre><code class="sql">CREATE TABLE `ln_batch_return_detail_mmdd` (  `legal_entity` VARCHAR(14) NOT NULL COMMENT &#39;法人号&#39;,  `tx_trace_no` VARCHAR(40) NOT NULL COMMENT &#39;交易流水号&#39;,   `tx_trace_no_local` VARCHAR(40) COMMENT &#39;核算本地流水号&#39;,  `tx_trace_cnt` BIGINT NOT NULL COMMENT &#39;流水笔次&#39;,  `settle_flag` VARCHAR(1) NOT NULL COMMENT &#39;结清标志[0:不结息; 1:结息]&#39;,  `prcl_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;本金金额&#39;,  `int_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;利息金额&#39;,  `core_trace_no` VARCHAR(60) NOT NULL COMMENT &#39;核心流水号&#39;,  `deduct_sts` VARCHAR(1) NOT NULL COMMENT &#39;扣款状态[1:成功; 2:失败]&#39;,  `error_info` VARCHAR(200) NOT NULL COMMENT &#39;异常信息&#39;,  `mac` VARCHAR(30) NOT NULL COMMENT &#39;MAC 验证&#39;,  `vpd_entity` BIGINT NOT NULL COMMENT &#39;多实体号&#39;,  `repay_ac_no` VARCHAR(32) COMMENT &#39;还款账号&#39;,  `ln_ac_id` DECIMAL(20,0) COMMENT &#39;贷款账户ID&#39;,  `repay_ac_seqn` BIGINT COMMENT &#39;还款账户序号&#39;,  `tx_date` BIGINT NOT NULL COMMENT &#39;交易日期&#39;,  `opposite_br_no` VARCHAR(14) COMMENT &#39;对方机构号&#39;,  `repay_ac_name` VARCHAR(200) COMMENT &#39;还款账户名称&#39;,  `send_prcl_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;上送本金金额&#39;,  `send_int_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;上送利息金额&#39;,  `send_settl_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;上送结清金额&#39;,  `batch_no` VARCHAR(40) NOT NULL COMMENT &#39;批次号&#39;,  PRIMARY KEY (`tx_trace_no`, `tx_trace_cnt`, `legal_entity`),  INDEX `ln_return_detail_mmdd_idx1` (`tx_date`, `tx_trace_no_local`, `tx_trace_no`, `tx_trace_cnt`, `legal_entity`)) ENGINE=InnoDB;</code></pre><h5 id="二、执行python脚本生成data-csv数据"><a href="#二、执行python脚本生成data-csv数据" class="headerlink" title="二、执行python脚本生成data.csv数据"></a>二、执行python脚本生成data.csv数据</h5><pre><code class="python">import csvimport randomfrom tqdm import tqdm  # 进度条工具（可选：pip install tqdm）def generate_csv(file_path, total_rows=10_000_000, batch_size=10_000):    # CSV文件列头（与表字段顺序严格一致）    header = [        &quot;legal_entity&quot;, &quot;tx_trace_no&quot;, &quot;tx_trace_no_local&quot;, &quot;tx_trace_cnt&quot;, &quot;settle_flag&quot;,        &quot;prcl_amt&quot;, &quot;int_amt&quot;, &quot;core_trace_no&quot;, &quot;deduct_sts&quot;, &quot;error_info&quot;,        &quot;mac&quot;, &quot;vpd_entity&quot;, &quot;repay_ac_no&quot;, &quot;ln_ac_id&quot;, &quot;repay_ac_seqn&quot;,        &quot;tx_date&quot;, &quot;opposite_br_no&quot;, &quot;repay_ac_name&quot;, &quot;send_prcl_amt&quot;, &quot;send_int_amt&quot;,        &quot;send_settl_amt&quot;, &quot;batch_no&quot;    ]    with open(file_path, &#39;w&#39;, newline=&#39;&#39;) as f:        writer = csv.writer(f)        writer.writerow(header)  # 写入列头        # 分批次生成数据（避免内存溢出）        for i in tqdm(range(1, total_rows + 1), desc=&quot;Generating CSV&quot;):            row = [                f&quot;LE&#123;i:08d&#125;&quot;,                      # legal_entity                f&quot;TX&#123;i:08d&#125;&quot;,                      # tx_trace_no                f&quot;LOCAL&#123;i:08d&#125;&quot;,                   # tx_trace_no_local                i,                                 # tx_trace_cnt                &#39;0&#39; if random.random() &lt; 0.5 else &#39;1&#39;,  # settle_flag                round(random.uniform(100, 10000), 2),  # prcl_amt                round(random.uniform(10, 1000), 2),    # int_amt                f&quot;CORE&#123;i:08d&#125;&quot;,                    # core_trace_no                &#39;1&#39; if random.random() &lt; 0.9 else &#39;2&#39;, # deduct_sts                &#39;No error&#39; if random.random() &lt; 0.95 else &#39;Error&#39;, # error_info                f&quot;MAC&#123;i:08d&#125;&quot;,                     # mac                random.randint(1, 1_000_000),      # vpd_entity                f&quot;ACCT&#123;i:08d&#125;&quot;,                    # repay_ac_no                random.randint(1, 10_000_000_000), # ln_ac_id                random.randint(1, 100),            # repay_ac_seqn                20230000 + random.randint(1, 365), # tx_date                f&quot;BR&#123;i:08d&#125;&quot;,                      # opposite_br_no                f&quot;Name&#123;i:08d&#125;&quot;,                    # repay_ac_name                round(random.uniform(100, 10000), 2),  # send_prcl_amt                round(random.uniform(10, 1000), 2),    # send_int_amt                round(random.uniform(100, 11000), 2),  # send_settl_amt                f&quot;BATCH&#123;i:08d&#125;&quot;                    # batch_no            ]            writer.writerow(row)            # 每生成 batch_size 行刷新一次缓冲区            if i % batch_size == 0:                f.flush()if __name__ == &quot;__main__&quot;:    generate_csv(&quot;data.csv&quot;, total_rows=100_000_000) # 生成一千万条数据</code></pre><h5 id="三、导入数据到数据库"><a href="#三、导入数据到数据库" class="headerlink" title="三、导入数据到数据库"></a>三、导入数据到数据库</h5><ol><li>将数据上传到服务器，并放到MySQL指定的目录下</li></ol><pre><code class="sql"># 执行下面命令mysql&gt; SHOW VARIABLES LIKE &#39;secure_file_priv&#39;;+------------------+-----------------------+| Variable_name    | Value                 |+------------------+-----------------------+| secure_file_priv | /var/lib/mysql-files/ |+------------------+-----------------------+</code></pre><ol start="2"><li>执行前关闭索引，执行结束后开启索引</li></ol><pre><code class="sql">-- 临时关闭索引更新（加速插入）ALTER TABLE ln_batch_return_detail_mmdd DISABLE KEYS;-- 插入完成后重建索引ALTER TABLE ln_batch_return_detail_mmdd ENABLE KEYS;</code></pre><ol start="3"><li>进入数据库执行插入命令</li></ol><pre><code class="sql">-- 执行数据导入LOAD DATA INFILE &#39;/path/to/data.csv&#39;INTO TABLE `ln_batch_return_detail_mmdd`FIELDS TERMINATED BY &#39;,&#39;     -- CSV字段分隔符（与生成文件时一致）OPTIONALLY ENCLOSED BY &#39;&quot;&#39;   -- 字段包裹符（如果字段含逗号或换行符）LINES TERMINATED BY &#39;\n&#39;     -- 行分隔符（Linux/Mac用\n，Windows用\r\n）IGNORE 1 LINES               -- 跳过CSV文件的列头行(  `legal_entity`, `tx_trace_no`, `tx_trace_no_local`, `tx_trace_cnt`, `settle_flag`,  `prcl_amt`, `int_amt`, `core_trace_no`, `deduct_sts`, `error_info`,  `mac`, `vpd_entity`, `repay_ac_no`, `ln_ac_id`, `repay_ac_seqn`,  `tx_date`, `opposite_br_no`, `repay_ac_name`, `send_prcl_amt`, `send_int_amt`,  `send_settl_amt`, `batch_no`);</code></pre><p>4.查看成功写入1千万条数据</p><p><img src="../images/sql%E8%BE%93%E5%85%A5%E6%8F%92%E5%85%A5.png" alt="sql输入插入"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在类中封装属性名</title>
      <link href="/2025/03/03/%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B0%81%E8%A3%85%E5%B1%9E%E6%80%A7%E5%90%8D/"/>
      <url>/2025/03/03/%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B0%81%E8%A3%85%E5%B1%9E%E6%80%A7%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>在面向对象编程中，<strong>封装属性名</strong>的目的是隐藏类的内部实现细节，通过受控的方法访问或修改数据，从而提高代码的安全性和可维护性</p><h4 id="一、-Python中的属性封装实现"><a href="#一、-Python中的属性封装实现" class="headerlink" title="一、 Python中的属性封装实现"></a>一、 Python中的属性封装实现</h4><ol><li>使用私有属性（名称改写）<pre><code>* 在属性名前添加双下划线__, Python会将其名称改写为 `_ClassName__attribute`，限制直接访问。* 提供公有方法（getter/setter）或 `@property` 装饰器来访问和验证数据。</code></pre></li></ol><pre><code class="python">class Person:    def __init__(self, name, age):        self.__name = name  # 私有属性        self.__age = age    # 使用@property 访问属性    @property    def name(self):        return self.__name    # 定义setter方法验证数据    # 用于控制属性赋值逻辑的 setter 方法，它会验证你给属性赋的值是否合法    @name.setter    def name(self, value):        if isinstance(value, str) and len(value) &gt; 0:            self.__name = value        else:            raise ValueError(&quot;Invalid name&quot;)    @property    def age(self):        return self.__age    @age.setter    def age(self, value):        if value &gt;= 0:            self.__age = value        else:            raise ValueError(&quot;Age cannot be negative&quot;)# 使用示例p = Person(&quot;Alice&quot;, 30)print(p.name)  # 输出: Alicep.age = 25     # 合法操作p.age = -5     # 抛出 ValueErrorp.name = &quot;Bob&quot;p.age = 44print(p._Person__name)print(p._Person__age)</code></pre><ol start="2"><li> @name.setter 的作用</li></ol><ul><li><p><em><strong>功能</strong></em>：这是一个装饰器，用来标记这是一个 <code>setter</code> 方法。当你给 <code>name</code> 属性赋值时（例如 <code>p.name = &quot;Bob&quot;</code>），<strong>自动触发</strong>这个方法。</p></li><li><p><strong>为什么需要</strong>：普通的属性赋值（如 <code>p.name = 123</code>）无法验证数据是否合法，而 <code>setter</code> 方法允许你在赋值前插入自定义检查逻辑。</p></li></ul><ol start="3"><li> 方法内部的验证逻辑</li></ol><pre><code class="python">def name(self, value):    if isinstance(value, str) and len(value) &gt; 0:  # 检查是否为非空字符串        self.__name = value  # 合法则赋值给私有属性 __name    else:        raise ValueError(&quot;Invalid name&quot;)  # 非法则抛出异常</code></pre><pre><code>    * **`isinstance(value, str)`** ：检查 `value` 是否是字符串类型（例如防止数字或对象被赋值给 `name`）。    * **`len(value) &gt; 0`** ：确保字符串不是空的（例如防止 `name = &quot;&quot;`）。</code></pre><ul><li><strong><code>raise ValueError</code></strong> ：如果值不合法，直接抛出错误，阻止赋值。</li></ul><ol start="4"><li>和 @property 的关系</li></ol><ul><li><strong><code>@property</code> 定义 getter</strong>：负责读取属性时的逻辑（例如 <code>print(p.name)</code>）。</li><li><strong><code>@name.setter</code> 定义 setter</strong>：负责写入属性时的逻辑（例如 <code>p.name = &quot;Bob&quot;</code>）。</li><li><strong>配套使用</strong>：两者共同实现对属性的<strong>安全读写控制</strong>。</li></ul><ol start="5"><li>为什么用 <code>self.__name</code></li></ol><ul><li><strong>双下划线 <code>__name</code></strong> ：这是 Python 的私有属性命名约定，实际会被改写为 <code>_Person__name</code>，防止外部直接访问（如 <code>p.__name</code> 会报错，但 <code>p._Person__name</code> 仍可访问，不过约定上不这样做）。</li><li><strong>封装目的</strong>：强制通过 <code>setter</code> 方法修改属性，确保所有赋值都经过验证。</li></ul><h4 id="二、封装的优势"><a href="#二、封装的优势" class="headerlink" title="二、封装的优势"></a>二、封装的优势</h4><ol><li><strong>数据保护</strong>：防止外部代码直接修改属性，避免非法值（如负数的年龄）。</li><li><strong>灵活性</strong>：可在方法中添加额外逻辑（如数据验证、日志记录）。</li><li><strong>兼容性</strong>：内部实现变化时，不影响外部代码（如重命名属性）。</li></ol><h4 id="三、单下划线和双下划线的区别"><a href="#三、单下划线和双下划线的区别" class="headerlink" title="三、单下划线和双下划线的区别"></a>三、单下划线和双下划线的区别</h4><h5 id="一、单下划线-name-受保护的属性（Portected）"><a href="#一、单下划线-name-受保护的属性（Portected）" class="headerlink" title="一、单下划线  _name : 受保护的属性（Portected）"></a>一、单下划线  _name : 受保护的属性（Portected）</h5><pre><code>1. 命名的约定：    *  _name 表示这是一个内部属性，暗示开发者“不要直接访问，除非你知道自己在做什么”。    *  不触发名称改写：名称保持为 _name, 没有自动重命名。    *  访问权限：外部代码仍可以直接读写（p.name = 123）,但约定上应通过方法或属性装饰器操作。</code></pre><ol start="2"><li>典型用途：</li></ol><ul><li>类的内部状态管理（如缓存、临时变量）</li><li>子类继承时可以安全覆盖或者扩展</li></ul><pre><code class="python">class Person:    def __init__(self, name):        self._name = name  # 单下划线，约定上的“受保护”属性p = Person(&quot;Alice&quot;)print(p._name)  # 直接访问：输出 &quot;Alice&quot;（不推荐但允许）</code></pre><h5 id="二、对比表格"><a href="#二、对比表格" class="headerlink" title="二、对比表格"></a>二、对比表格</h5><table><thead><tr><th>特性</th><th>单下划线 <code>_name</code></th><th>双下划线 <code>__name</code></th></tr></thead><tbody><tr><td><strong>名称改写</strong></td><td>无</td><td>有（改写为 <code>_ClassName__name</code>）</td></tr><tr><td><strong>直接外部访问</strong></td><td>允许（不推荐）</td><td>不允许（需改写后的名称）</td></tr><tr><td><strong>继承冲突防护</strong></td><td>无，子类可直接覆盖</td><td>有，避免子类同名属性冲突</td></tr><tr><td><strong>用途</strong></td><td>约定上的内部属性</td><td>强制私有属性</td></tr></tbody></table><h5 id="三、何时选择哪种？"><a href="#三、何时选择哪种？" class="headerlink" title="三、何时选择哪种？"></a>三、何时选择哪种？</h5><ol><li><strong>用单下划线 <code>_name</code></strong> ：<ul><li>属性需要被子类继承或覆盖。</li><li>仅作为内部状态管理，不涉及敏感数据。</li><li>团队约定明确时（如 Django 框架常用 <code>_</code> 表示内部方法）。</li></ul></li><li><strong>用双下划线 <code>__name</code></strong> ：<ul><li>明确禁止外部直接访问（即使通过名称改写也不建议）。</li><li>避免多级继承中的属性命名冲突。</li><li>需要强制封装时（如属性值必须通过方法验证）。</li></ul></li></ol><h5 id="四、代码示例"><a href="#四、代码示例" class="headerlink" title="四、代码示例"></a>四、代码示例</h5><pre><code class="python">class Base:    def __init__(self):        self._protected = &quot;Base Protected&quot;  # 单下划线        self.__private = &quot;Base Private&quot;     # 双下划线class SubClass(Base):    def __init__(self):        super().__init__()        self._protected = &quot;Sub Protected&quot;   # 直接覆盖父类的 _protected        self.__private = &quot;Sub Private&quot;      # 实际名称是 _SubClass__private    def show(self):        print(self._protected)              # 输出 &quot;Sub Protected&quot;        print(self.__private)               # 输出 &quot;Sub Private&quot;        print(self._Base__private)           # 输出 &quot;Base Private&quot;（访问父类私有属性）obj = SubClass()obj.show()</code></pre><h5 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h5><ul><li><strong>单下划线 <code>_name</code></strong> ：约定上的“内部属性”，轻量级封装。</li><li><strong>双下划线 <code>__name</code></strong> ：强制私有属性，通过名称改写避免冲突。</li><li>实际开发中，优先用单下划线，除非明确需要避免继承冲突或强制封装。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象支持上下文管理协议</title>
      <link href="/2025/03/03/%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/03/03/%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>​            在 Python 中，让对象支持上下文管理协议，简单说就是让你的对象能和 with 语句配合使用，自动处理资源的打开和关闭（比如文件、网络连接、锁等），避免资源泄漏。</p><p>只需要在类中实现两个方法：</p><ol><li><p><strong>enter</strong>(self)</p><ul><li><p>当with语句开始调用时，返回你需要管理的资源（比如打开的文件对象）。</p></li><li><p>通常返回self, 但也可以返回其他对象。</p></li></ul></li><li><p><strong>exit</strong>(self，exc_type，exc_val，exc_tb)</p><ul><li><p>当 <code>with</code> 语句块<strong>结束</strong>时（无论是否发生异常）调用。</p></li><li><p>负责清理工作（比如关闭文件、释放锁）。</p></li></ul></li></ol><pre><code class="python"># 模拟文件打开器class FileOpener:    def __init__(self, filename, mode):        self.filename = filename        self.mode = mode    def __enter__(self):        self.file = open(self.filename, self.mode)        return self.file  # 返回文件对象，供 with 块内使用    def __exit__(self, exc_type, exc_val, exc_tb):        self.file.close()  # 确保文件被关闭# 使用 with 语句自动管理文件with FileOpener(&quot;test.txt&quot;, &quot;w&quot;) as f:    f.write(&quot;Hello, Context Manager!&quot;)# 这里文件已自动关闭，无需手动调用 f.close()</code></pre><p>✅ 为什么要用上下文管理？</p><ol><li><strong>资源安全</strong>：即使代码块中发生异常，<code>__exit__</code> 也会被调用，确保资源释放。</li><li><strong>代码简洁</strong>：避免了冗长的 <code>try...finally</code> 结构。</li><li><strong>可读性高</strong>：明确展示资源的作用域。</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义字符串的格式化</title>
      <link href="/2025/03/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2025/03/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<pre><code class="python">_formats = &#123;    &#39;ymd&#39; : &#39;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&#39;,    &#39;mdy&#39; : &#39;&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;&#39;,    &#39;dmy&#39; : &#39;&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;&#39;    &#125;class Date:    def __init__(self, year, month, day):        self.year = year        self.month = month        self.day = day    def __format__(self, code):        if code == &#39;&#39;:            code = &#39;ymd&#39;        fmt = _formats[code]        return fmt.format(d=self) # 替换为 self.year, self.month, self.day 的实际值ddd = Date(2012, 12, 21)print(format(ddd, &#39;ymd&#39;))print(&#39;The date is &#123;:mdy&#125;&#39;.format(ddd))import math# __format__ 专门用于格式化输出，支持动态格式控制（如精度、单位等）# __str__ 和 __repr__ 用于一般字符串表示。class Vector:    def __init__(self, x, y):        self.x = x        self.y = y    def __format__(self, format_spec):        if format_spec == &#39;r&#39;:  # 直角坐标            return f&quot;Vector(&#123;self.x&#125;, &#123;self.y&#125;)&quot;        elif format_spec == &#39;p&#39;:  # 极坐标            r = math.hypot(self.x, self.y)            theta = math.degrees(math.atan2(self.y, self.x))            return f&quot;Vector(r=&#123;r:.2f&#125;, θ=&#123;theta:.2f&#125;°)&quot;        elif format_spec == &#39;&#39;:  # 默认格式            return f&quot;Vector(&#123;self.x&#125;, &#123;self.y&#125;)&quot;        else:            raise ValueError(f&quot;Unknown format specifier &#39;&#123;format_spec&#125;&#39;&quot;)# 使用示例v = Vector(3, 4)print(f&quot;&#123;v&#125;&quot;)          # 输出: Vector(3, 4)print(f&quot;&#123;v:r&#125;&quot;)        # 输出: Vector(3, 4)print(f&quot;&#123;v:p&#125;&quot;)        # 输出: Vector(r=5.00, θ=53.13°)print(format(v, &#39;p&#39;))  # 输出: Vector(r=5.00, θ=53.13°)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令lsof</title>
      <link href="/2025/02/26/linux%E5%91%BD%E4%BB%A4lsof/"/>
      <url>/2025/02/26/linux%E5%91%BD%E4%BB%A4lsof/</url>
      
        <content type="html"><![CDATA[<h4 id="1-lsof简介"><a href="#1-lsof简介" class="headerlink" title="1.lsof简介"></a>1.lsof简介</h4><p>lsof(list open  files)可以列出当前系统中进程打开的所有文件，在Linux环境下，我们可以理解为一切(包括网络套接口)皆文件。在实际使用过程中，lsof是一款非常强大的系统监控和系统诊断工具。在终端下输入lsof 即可显示系统打开的文件， lsof 一般需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。</p><h4 id="2-lsof使用"><a href="#2-lsof使用" class="headerlink" title="2.lsof使用"></a>2.lsof使用</h4><h5 id="2-lsof-h-显示使用方法"><a href="#2-lsof-h-显示使用方法" class="headerlink" title="2.lsof -h 显示使用方法"></a>2.lsof -h 显示使用方法</h5><p><img src="../images/lsof.png" alt="lsof"></p><p>2.2终端下输入lsof命令，打开前三个文件</p><p><img src="../images/lsof_head.jpg" alt="lsof_head"></p><p>2.3lsof输出每列含义如下</p><pre><code class="text">COMMAND：进程的名称PID：进程标识符TID：任务 ID。Linux 下 TID 为空表示该行为进程USER：进程所有者FD：文件描述符。主要有：    cwd：应用程序当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改    txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序    lnn：库引用（AIX）    err：FD 信息错误    jld：监狱目录（FreeBSD）    ltx：共享库文本（代码和数据）    mxx：十六进制内存映射类型号 xx    m86：DOS合并映射文件    mem：内存映射文件    mmap：内存映射设备    pd：父目录    rtd：根目录    tr：内核跟踪文件（OpenBSD）    v86：VP/ix 映射文件    0：标准输出    1：标准输入    2：标准错误    文件描述符后一般还跟着文件状态模式：    r：只读模式    w：写入模式    u：读写模式    空格：文件的状态模式为 unknow，且没有锁定    -：文件的状态模式为 unknow，且被锁定        同时在文件状态模式后面，还跟着相关的锁：    N：对于未知类型的 Solaris NFS 锁    r：文件部分的读锁    R：整个文件的读锁    w：文件的部分写锁    W：整个文件的写锁    u：任何长度的读写锁    U：用于未知类型的锁    x：用于部分文件上的 SCO OpenServer Xenix 锁    X：用于整个文件上的 SCO OpenServer Xenix 锁    space：无锁TYPE：文件类型。常见的文件类型有：    REG：普通文件    DIR：表示目录    CHR：表示字符类型    BLK：块设备类型    UNIX：UNIX 域套接字    FIFO：先进先出队列    IPv4：IPv4 套接字DEVICE：磁盘名称SIZE：文件的大小或文件偏移量（以字节为单位）NODE：索引节点NAME：打开文件的确切名称</code></pre><p>2.4 Linux上常用的几种用法</p><p>lsof -i  显示所有网络连接</p><p>lsof  filename 显示打开指定文件的所有进程</p><p>lsof -a 表示两个参数都必须满足时才显示结果</p><p>lsof -c string   显示COMMAND列中包含指定字符的进程所有打开的文件</p><p>lsof -u username  显示所属user进程打开的文件</p><p>lsof -g gid 显示归属gid的进程情况</p><p>lsof +d /DIR/ 显示目录下被进程打开的文件</p><p>lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长</p><p>lsof -d FD 显示指定文件描述符的进程</p><p>lsof -n 不将IP转换为hostname，缺省是不加上-n参数</p><p>lsof -i 用以显示符合条件的进程情况</p><p>2.5 显示指定程序的端口号</p><p><img src="../images/lsof_i.jpg" alt="lsof_i"></p><h4 id="3-Lsof解决Device-is-busy问题"><a href="#3-Lsof解决Device-is-busy问题" class="headerlink" title="3.Lsof解决Device is busy问题"></a>3.Lsof解决Device is busy问题</h4><p>在系统运维过程中，我们会遇到磁盘卸载报umount: /home: device is busy之类的提示</p><p><img src="../images/umount.jpg" alt="umount"></p><h5 id="3-1-使用lsof命令找出占用磁盘的进程"><a href="#3-1-使用lsof命令找出占用磁盘的进程" class="headerlink" title="3.1 使用lsof命令找出占用磁盘的进程"></a>3.1 使用lsof命令找出占用磁盘的进程</h5><p><img src="../images/lsof_home.jpg" alt="lsof_home"></p><p>直接kill掉此进程(kill -9 5689)，umount /home/后目录成功卸载</p><p>umount -l /home 强行解除挂载</p><p>fuser  -mv -k /home直接杀死占用磁盘的进程</p><p>3.2 <strong>Lsof解决文件已删除空间未释放问题</strong></p><p>磁盘空间达到100%会导致数据无法正常写入文件造成程序异常，如下/home空间达到100%，一般的解决方法是先删除大文件，然后有必要的情况下对磁盘进行扩容。</p><p>按照排查步骤，先进入/home目录查找占用磁盘的大文件（命令du -h –max-depth=1 /home），如下发现/home目录下并没有占用空间大的文件和目录。</p><p>为什么磁盘空间显示占用100%呢？原因是磁盘上文件已经被删除，但是存在进程仍然占用这些文件，因此其原来占用的磁盘空间并没有被释放，当然重启操作系统，空间会被释放出来，但是重启并不是最好的解决方法。</p><p>lsof -n | grep delete检查出占用文件的进程</p><p><img src="../images/delete.jpg" alt="delete"></p><p>从进程显示上可以看出，/home目录下占用文件已经删除，仍然有3个进程在占用，我们采用kill方式杀死进程，释放空间。</p><p><img src="../images/kill.jpg" alt="kill"></p>]]></content>
      
      
      <categories>
          
          <category> linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/02/26/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/select/"/>
      <url>/2025/02/26/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/select/</url>
      
        <content type="html"><![CDATA[<html><head><meta charset="utf-8"><title>上传表单</title>#上传文件<link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script></head><body><div class="jumbotron"><form class="form-inline" role="form"><div class="form-group"><label class="sr-only" for="name">名称</label><input type="text" class="form-control" id="name" placeholder="请输入名称"></div><div class="form-group"><label class="sr-only" for="inputfile">文件输入</label><input type="file" id="inputfile"></div><button type="submit" class="btn btn-default">提交</button></form></div># select 选择<form><center><select name="anjing"><option value="boke">请关注今日天气</option><option value="study">今天大雨</option><option value="daily">写写什么</option><option value="like">喜欢的食物</option><option value="attention">关注点在哪里</option></select></center></form></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>改变对象字符串显示</title>
      <link href="/2025/02/25/%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA/"/>
      <url>/2025/02/25/%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="1-repr函数简介"><a href="#1-repr函数简介" class="headerlink" title="1. repr函数简介"></a>1. repr函数简介</h4><p>​        在Python中，<code>__repr__</code>和<code>__str__</code>都是用于对象字符串表示的特殊方法，但用途不同。<code>__repr__</code>（representation）旨在提供对象的“官方”字符串表示，通常用于调试和日志，应尽量明确且无歧义（如<code>eval(repr(obj))</code>能重建对象），开发者可通过<code>repr(obj)</code>或直接输出对象时调用；<code>__str__</code>（string）则面向用户，提供更友好、可读性高的描述（如<code>print(obj)</code>时触发），若未定义则默认回退到<code>__repr__</code>。两者均需返回字符串，但<code>__repr__</code>更强调准确性，<code>__str__</code>侧重易读性。</p><pre><code class="python">class Pair:    def __init__(self, x, y):        self.x = x        self.y = y    def __repr__(self):        return &#39;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&#39;.format(self)    def __str__(self):        return &#39;(&#123;0.x!s&#125;, &#123;0.y!s&#125;)&#39;.format(self)p = Pair(1,2)print(repr(p)) # Pair(1, 2)  # 当调用内置函数repr(obj)时，实际上会调用obj.__repr__()方法print(str(p)) # (1, 2)new_p = eval(repr(p))print(&quot;new_p: &quot;, new_p) # new_p:  (1, 2)p = Pair(True, [1, 2, 3])print(repr(p))  # 输出：Pair(True, [1, 2, 3])print(str(p))   # 输出：(True, [1, 2, 3])# 可以看到 !r 会保留数据的完整类型信息，而 !s 会直接输出值的字符串形式# 实例：class Vector3D:    def __init__(self, x, y, z):        self.x = x        self.y = y        self.z = z    # 标准 repr 格式    def __repr__(self):        # return f&quot;Vector3D(&#123;self.x!r&#125;,&#123;self.y!r&#125;,&#123;self.z!r&#125;)&quot;        return f&quot;&#123;self.__class__.__name__&#125;(&#123;self.x!r&#125;,&#123;self.y!r&#125;,&#123;self.z!r&#125;)&quot;        #定制化 str 格式    def __str__(self):        return f&quot;3D向量 → X:&#123;self.x:.2f&#125;, Y:&#123;self.y:.2f&#125;, Z:&#123;self.z:.2f&#125;&quot;print(&#39;---------------------------------分割线-----------------------------------&#39;)   V = Vector3D(3,4,5)print(V) # Vector3D(3,4,5)  # 如果用户没有为Vector3D类定义__str__方法，那么print(V)实际上会调用__repr__方法，导致print(V)和print(repr(V))输出相同print(repr(V))new_v = eval(repr(V))print(new_v)# V = Vector3D(3, 4, 5)# print(V)          # 输出 Vector3D(3,4,5) → 调用 __repr__# print(repr(V))    # 输出 Vector3D(3,4,5) → 直接调用 __repr__# new_v = eval(repr(V))# print(new_v)      # 输出 Vector3D(3,4,5) → 新对象的 __repr__v = Vector3D(1.2345, 2.5678, 3.8912)print(v)  # 输出：3D向量 → X:1.23, Y:2.57, Z:3.89# 日期时间类class MyDateTime:    def __init__(self, year, month, day):        self.year = year        self.month = month        self.day = day    def __repr__(self):        return f&quot;&#123;self.__class__.__name__&#125;(&#123;self.year&#125;, &#123;self.month&#125;, &#123;self.day&#125;)&quot;    def __str__(self):        return f&quot;&#123;self.year&#125;年&#123;self.month:02d&#125;月&#123;self.day:02d&#125;日&quot;# 测试输出# dt = MyDateTime(2023, 9, 15)# print(repr(dt))  # MyDateTime(2023, 9, 15)# print(dt)        # 2023年09月15日class BrokenClass1:    def __init__(self, value):        self.value = value    def __repr__(self):        return f&quot;BrokenClass1(&#123;self.value&#125;)&quot;  # 开发者视角    def __str__(self):        return f&quot;Value: &#123;self.value&#125;&quot;        # 用户视角obj = BrokenClass1(444)print(repr(obj)) # 调用 __repr__print(obj)  # 调用 __str__# 通过定义 __repr__ 或 __str__，你可以控制对象的字符串表示形式</code></pre><h4 id="2-案例示范"><a href="#2-案例示范" class="headerlink" title="2. 案例示范"></a>2. 案例示范</h4><pre><code class="python">&quot;&quot;&quot;题目：智能坐标点类请实现一个 SmartPoint 类，要求满足以下所有条件：1. 基础要求包含 x, y, tag 三个属性（tag 为字符串类型的标签）__repr__ 返回的字符串必须能够通过 eval() 重建对象__str__ 返回人类可读的格式：&quot;标签：(x, y)&quot;（坐标保留2位小数）2. 特殊需求当 tag 包含空格时，__repr__ 必须自动添加引号如果 tag 为空字符串，__str__ 显示 &quot;未命名点&quot;在列表中打印多个 SmartPoint 对象时，显示的是 __repr__ 格式&quot;&quot;&quot;class SmartPoint:    def __init__(self, x, y, tag=&#39;&#39;):        self.x = x        self.y = y        self.tag = tag    def __repr__(self):        return f&quot;&#123;self.__class__.__name__&#125;(&#123;self.x!r&#125;, &#123;self.y!r&#125;, &#123;self.tag!r&#125;)&quot;        def __str__(self):        # if self.tag == &quot;&quot;:  # 如果 tag 为空字符串        if not self.tag:            return f&quot;未命名点：(&#123;self.x:.2f&#125;, &#123;self.y:.2f&#125;)&quot;  # 返回默认提示        else:            return f&quot;&#123;self.tag&#125;: (&#123;self.x:.2f&#125;, &#123;self.y:.2f&#125;)&quot;# 创建对象p1 = SmartPoint(3.1415926, 2.71828, &quot;Alpha&quot;)p2 = SmartPoint(-5, 4.2, &quot;&quot;)p3 = SmartPoint(0, 0, &quot;Beta Point&quot;)# 测试1：直接打印print(p1)           # 应输出：Alpha：(3.14, 2.72)print(p2)           # 应输出：未命名点：(-5.00, 4.20)# # 测试2：repr相关print(repr(p3))     # 应输出：SmartPoint(0, 0, &#39;Beta Point&#39;)points = [p1, p3]print(points)       # 应输出：[SmartPoint(3.1415926, 2.71828, &#39;Alpha&#39;), SmartPoint(0, 0, &#39;Beta Point&#39;)]# 测试3：eval验证p1_clone = eval(repr(p1))print(p1.x)print(p1_clone.x)print(p1_clone.tag)print(p1_clone.x == p1.x)  # 应输出：True</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ntp配置时间同步</title>
      <link href="/2023/09/20/ntp%E9%85%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/09/20/ntp%E9%85%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="方法1：ntpd服务同步"><a href="#方法1：ntpd服务同步" class="headerlink" title="方法1：ntpd服务同步"></a>方法1：ntpd服务同步</h4><ul><li>每台主机上安装yum -y install ntp</li><li>配置/etc/ntp.conf配置文件</li><li>启动ntpd服务</li></ul><h4 id="方法2：ntpd-ntpdate同步"><a href="#方法2：ntpd-ntpdate同步" class="headerlink" title="方法2：ntpd+ntpdate同步"></a>方法2：ntpd+ntpdate同步</h4><ol><li><p>选一台服务器作为ntp服务器</p><p>安装yum -y install ntp</p><p>启动ntpd服务</p></li><li><p>其他服务器作为客户端配置定时任务使用ntpdate同步时间</p></li></ol><pre><code class="shell"> yum install ntpdate    echo &quot;* * * * * /usr/sbin/ntpdate ntp服务器ip&quot; &gt;&gt;/etc/crontab    systemctl start ntpdate    systemctl status ntpdate    systemctl enable ntpdate</code></pre><ol start="3"><li>实例如下：</li></ol><pre><code class="shell">1、选择一台服务作为ntp服务器，安装ntp软件，并启动服务    yum -y install ntp    systemctl start ntpd    systemctl enable ntpd2、配置ntp客户端(客户端都要安装ntpdate)同步ntp服务器时间,下面命令都要在客户端执行        yum install ntpdate        echo &quot;* * * * * /usr/sbin/ntpdate 172.172.31.32&quot; &gt;&gt;/etc/crontab        systemctl restart crond        systemctl status crond</code></pre><h4 id="记录一下装载目录方法："><a href="#记录一下装载目录方法：" class="headerlink" title="记录一下装载目录方法："></a>记录一下装载目录方法：</h4><pre><code class="shell">        # 用lsblk查看磁盘信息。        mkfs.xfs -f  /dev/sdb        mkdir -p /data1        mount /dev/sdb /data1        chmod +x  /etc/rc.d/rc.local        echo &quot;/usr/bin/mount -t xfs /dev/sdb /data1&quot; &gt;&gt;/etc/rc.d/rc.local</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ntpd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口测试学习笔记</title>
      <link href="/2023/06/19/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/19/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-HTTP-与-HTTPS-的概念"><a href="#1-HTTP-与-HTTPS-的概念" class="headerlink" title="1. HTTP 与 HTTPS 的概念"></a>1. HTTP 与 HTTPS 的概念</h4><ul><li>HTTP</li><li><ul><li>超文本传输协议</li><li>是一个基于请求与响应，无状态的，应用层的协议</li><li>常基于 TCP/IP 协议传输数据</li><li>以明文方式发送内容</li></ul></li><li>HTTPS</li><li><ul><li>安全套接字层超文本传输协议</li><li>通过计算机网络进行安全通信的传输协议</li><li>在 HTTP 的基础上加入了 SSL/TLS 协议</li><li><code>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</code> </li></ul></li><li><img src="../imags/$%7Bfiilename%7D/https%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.jpg" alt="https通信过程"></li><li><img src="../images/%E4%BC%A0%E8%BE%93.jpg" alt="传输"></li></ul><h4 id="2-HTTP-与-HTTPS-的区别"><a href="#2-HTTP-与-HTTPS-的区别" class="headerlink" title="2. HTTP 与 HTTPS 的区别"></a>2. HTTP 与 HTTPS 的区别</h4><ol><li><p>HTTPS 比 HTTP 更安全</p><ul><li><p>HTTP 是超文本传输协议，连接简单无状态，信息明文传输</p></li><li><p>HTTPS 通过 SSL/TLS 提供安全方式</p></li></ul></li><li><p>HTTP 和 HTTPS 使用完全不同的连接方式</p></li><li><p>HTTP 和 HTTPS 用的端口也不一样</p><ul><li><p>HTTP 是 80 端口</p></li><li><p>HTTPS 是 443 端口</p></li></ul></li><li><p>HTTPS 协议需要到 CA 申请证书，可能需要一定费用</p></li></ol><h4 id="3-get、post区别"><a href="#3-get、post区别" class="headerlink" title="3.get、post区别"></a>3.get、post区别</h4><p><img src="../images/%E5%8C%BA%E5%88%AB.jpg" alt="区别"></p><ul><li><p>HTTP 的 method 字段不同</p></li><li><p>POST 可以附加 body，可以支持 form、json、xml、binary 等各种数据格式</p></li><li><p>行业通用的规范</p></li><li><ul><li>无状态变化的建议使用 GET 请求</li><li>数据的写入与状态修改建议用 POST</li></ul></li></ul><ul><li>传送数据量不同</li><li>安全性不同</li></ul><h4 id="4-session、cookie、token的区别"><a href="#4-session、cookie、token的区别" class="headerlink" title="4 session、cookie、token的区别"></a>4 session、cookie、token的区别</h4><ul><li>Session：数据存储到服务端，只把关联数据的一个加密串放到 Cookie 中标记</li><li>Cookie：浏览器接受服务器的 Set-Cookie 指令，并把 cookie 保存到电脑上，每个网站保存的 cookie 只作用于自己的网站</li><li>Token：是一个用户请求时附带的请求字段，用于验证身份与权限</li></ul><h5 id="4-1-session的实现机制"><a href="#4-1-session的实现机制" class="headerlink" title="4.1 session的实现机制"></a>4.1 session的实现机制</h5><p>​        服务器创建 Session 出来后，会把 Session id，以 Cookie 的形式回写给客户端  浏览器，这样，只要客户端的浏览器不关，再去访问服务器时，都会带着 Session id ，服务器发现客户机浏览器带 Session id  过来了，就会使用内存中与之对应的 Session 为之服务。(Session 会存在服务器)</p><p><img src="../images/session.jpg" alt="session"></p><h5 id="4-2-cookie-实现机制"><a href="#4-2-cookie-实现机制" class="headerlink" title="4.2 cookie 实现机制"></a>4.2 cookie 实现机制</h5><ul><li>Cookie 通过在客户端记录信息确定用户身份，</li><li>Cookie 由服务器生成，发送给浏览器，浏览器把 Cookie 以 kv 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 Cookie 发送给服务器。</li></ul><p><img src="../images/cookie%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.jpg" alt="cookie实现机制"></p><h5 id="4-3-Token-的原理"><a href="#4-3-Token-的原理" class="headerlink" title="4.3 Token 的原理"></a>4.3 Token 的原理</h5><ul><li><p>基于 Token 的身份验证是无状态的，我们不将用户信息存在服务器或 Session 中。这解决了在服务端存储信息时的许多问题 NoSession 意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</p></li><li><p>基于 Token 的身份验证的过程如下:</p></li><li><ul><li>用户发送数据请求</li><li>程序验证</li><li>程序返回一个签名的 token 给客户端</li><li>客户端储存 token，并且每次用于每次发送请求。</li><li>服务端验证 token 并返回数据。</li></ul></li></ul><p>​    token 通常在 HTTP 的头部发送给服务端</p><h5 id="4-4-Session-Cookie-Token-的工作原理"><a href="#4-4-Session-Cookie-Token-的工作原理" class="headerlink" title="4.4 Session,Cookie,Token 的工作原理"></a>4.4 Session,Cookie,Token 的工作原理</h5><p><img src="../images/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="工作原理"></p>]]></content>
      
      
      <categories>
          
          <category> 接口测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter中使用“用户参数”实现参数化</title>
      <link href="/2023/06/15/JMeter%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%80%9C%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E2%80%9D%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96/"/>
      <url>/2023/06/15/JMeter%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%80%9C%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E2%80%9D%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="1-用户参数组件介绍"><a href="#1-用户参数组件介绍" class="headerlink" title="1. 用户参数组件介绍"></a>1. <strong>用户参数组件介绍</strong></h4><p>​    用户参数（User  Parameter）组件在前置处理器元件中添加，前置处理器的作用是在取样器发出请求之前，执行一些操作。即：如果将前置处理器附加到取样器元件中，则它将在该取样器元件运行之前执行。常用操作如：取样器参数设置、环境变量设置、脚本预处理等。之前我们介绍过，JMeter中常用的参数化方式有四种：1、CSV数据文件设置（CSV Data Set Config）：这种方式是通常所指的参数化。数据存储在文件中，该种参数化方式取值范围大，灵活性强，适用于大量测试数据时的使用。</p><h5 id="1-1-用户参数（User-Parameter）"><a href="#1-1-用户参数（User-Parameter）" class="headerlink" title="1.1 用户参数（User Parameter）"></a>1.1 用户参数（User Parameter）</h5><p>​        适用于参数取值范围很小，需要少量测试数据时使用。</p><h5 id="1-2-用户自定义变量（User-Defined-Variables）"><a href="#1-2-用户自定义变量（User-Defined-Variables）" class="headerlink" title="1.2 用户自定义变量（User Defined Variables）"></a>1.2 用户自定义变量（User Defined Variables）</h5><p>​        更多用于设置全局变量，常用于数据库地址，测试环境、开发环境地址等常量配置。</p><h5 id="1-3-函数助手"><a href="#1-3-函数助手" class="headerlink" title="1.3  函数助手"></a>1.3  函数助手</h5><p>​        可使用函数生成随机数字和随机字符串实现参数化。本文以前置处理器中的<strong>用户参数</strong>组件为例，实现JMeter中的参数化。</p><h4 id="2-用户参数界面介绍"><a href="#2-用户参数界面介绍" class="headerlink" title="2. 用户参数界面介绍"></a>2. <strong>用户参数界面介绍</strong></h4><p>​    <strong>用户参数</strong>组件添加方式：选中“取样器”右键—&gt;添加—&gt;前置处理器—&gt;用户参数。</p><p><img src="../images/%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E7%95%8C%E9%9D%A2.jpg" alt="用户参数界面"></p><p>界面说明：</p><ul><li><strong>名称</strong>：用户参数组件的自定义名称，见名知意最好。</li><li><strong>注释</strong>：即添加一些备注信息，对该用户参数组件的简短说明，以便后期回顾时查看。</li><li><strong>每次迭代更新一次</strong>：不同的线程需要应用不同的用户数据，这时就需要勾选此选项。也就是根据线程组里设置的线程数，每个线程调用不同的用户数据，依次取值。但是我实际操作中，勾选不勾选都能够依次取值。（如果修改线程组界面中的循环次数，勾不勾选，都只用一个用户的值。）</li><li><strong>添加变量</strong>：横着添加一行变量信息，此变量会应用于每个用户。</li><li><strong>删除变量</strong>：删除所选中的一行数据。</li><li><strong>添加用户</strong>：竖着添加一个用户信息，一个用户就是一组测试数据。</li><li><strong>删除用户</strong>：删除所选中的一列数据。</li><li><strong>向上和向下按钮</strong>：就是上下移动所选中变量的位置。</li></ul><h4 id="3-使用“用户参数”组件实现参数化"><a href="#3-使用“用户参数”组件实现参数化" class="headerlink" title="3. 使用“用户参数”组件实现参数化"></a>3. <strong>使用“用户参数”组件实现参数化</strong></h4><p>​    需求，实现批量新建和删除标签</p><h5 id="3-1测试计划内包含的元件"><a href="#3-1测试计划内包含的元件" class="headerlink" title="3.1测试计划内包含的元件"></a>3.1<strong>测试计划内包含的元件</strong></h5><p><strong>添加元件操作步骤</strong>：</p><p>​    1、创建测试计划</p><p>​    2、创建线程组：选中“测试计划”右键—&gt;添加—&gt;线程（用户）—&gt;线程组。</p><p>​    3、在线程组中，添加取样器”HTTP请求“组件：选中“线程组”右键—&gt;添加—&gt;取样器—&gt; HTTP请求。</p><p>​    4、在取样器中，添加前置处理器“用户参数”组件：选中“取样器”右键—&gt;添加—&gt;前置处理器—&gt;用户参数。</p><p>​    5、在线程组中，添加监听器察看结果树组件：查看结果，选中“线程组”右键—&gt;添加—&gt;监听器—&gt;察看结果树。</p><p>最终测试计划中的元件如下：</p><p><img src="../images/%E6%A0%87%E7%AD%BE%E6%96%B0%E5%BB%BA.jpg" alt="标签新建"></p><h5 id="3-2-线程组元件内容"><a href="#3-2-线程组元件内容" class="headerlink" title="3.2 线程组元件内容"></a>3.2 <strong>线程组元件内容</strong></h5><p><img src="../images/%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E5%8C%96_%E7%BA%BF%E7%A8%8B%E6%95%B0.jpg" alt="用户参数化_线程数"></p><h5 id="3-3-HTTP请求组件内容"><a href="#3-3-HTTP请求组件内容" class="headerlink" title="3.3 HTTP请求组件内容"></a>3.3 <strong>HTTP请求组件内容</strong></h5><p><img src="../images/%E6%A0%87%E7%AD%BEhttp.jpg" alt="标签http"></p><h5 id="3-4-用户参数组件内容"><a href="#3-4-用户参数组件内容" class="headerlink" title="3.4 用户参数组件内容"></a>3.4 <strong>用户参数组件内容</strong></h5><p><img src="../images/%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E7%95%8C%E9%9D%A2.jpg" alt="用户参数界面"></p><h4 id="4-脚本运行结果"><a href="#4-脚本运行结果" class="headerlink" title="4. 脚本运行结果"></a>4. <strong>脚本运行结果</strong></h4><p><img src="../images/%E7%BB%93%E6%9E%9C.jpg" alt="结果"></p><h5 id="5-总结优先级说明："><a href="#5-总结优先级说明：" class="headerlink" title="5. 总结优先级说明："></a>5. <strong>总结</strong>优先级说明：</h5><ul><li>线程组下的用户参数组件 优先级高于 测试计划 里的用户自定义变量。</li><li>HTTP 请求下的用户参数组件 优先级高于 **线程组下 **的用户参数组件。</li><li>若有重名参数，优先取优先级高的用户参数。</li><li>若用户参数和用户自定义变量重名，则优先取用户参数组件中的值 。因为配置元件执行完再到前置处理器，所以前置处理器的值会覆盖配置元件中设置的值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter参数化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter中实现跨线程组关联</title>
      <link href="/2023/06/15/JMeter%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%85%B3%E8%81%94/"/>
      <url>/2023/06/15/JMeter%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%85%B3%E8%81%94/</url>
      
        <content type="html"><![CDATA[<h4 id="1-JMeter中实现跨线程组关联说明"><a href="#1-JMeter中实现跨线程组关联说明" class="headerlink" title="1. JMeter中实现跨线程组关联说明"></a>1. JMeter中实现跨线程组关联说明</h4><h4 id="1-1-JMeter中实现跨线程组关联步骤"><a href="#1-1-JMeter中实现跨线程组关联步骤" class="headerlink" title="1.1 JMeter中实现跨线程组关联步骤"></a>1.1 <strong>JMeter中实现跨线程组关联步骤</strong></h4><p>​    1、先进行登陆请求。<br>​    2、记录登陆请求返回的Cookie，或者有关登录状态的token信息。<br>​    3、如果是Cookie，就用HTTP Cookie管理器获取。<br>​    4、如果是token，就用提取器进行提取。<br>​    5、然后通过函数助手中的__setProperty函数，把Cookie值升级为JMeter的全局属性，就可以在线程组和线程组之间共享了。<br>​    6、然后从另一个线程组中通过__property函数，获取全局数据。<br>​    7、然后把获取的Cookie或token，加入到查看购物车请求中，保持用户登陆状态。<br>​    8、如果是Cookie，就用添加到HTTP信息头管理器组件中。<br>​    9、如果是token，就添加到请求的参数中。<br>​    10、执行脚本，查看运行结果。</p><h4 id="2-测试计划内包含的元件"><a href="#2-测试计划内包含的元件" class="headerlink" title="2.测试计划内包含的元件"></a>2.<strong>测试计划内包含的元件</strong></h4><p>​    1、创建测试计划。<br>​    2、创建线程组：选中“测试计划”右键 —&gt; 添加 —&gt; 线程（用户） —&gt; 线程组。<br>​    3、在线程组中，添加配置元件HTTP Cookie管理器组件：选中“线程组”右键 —&gt; 添加 —&gt; 配置元件 —&gt; HTTP<br>Cookie管理器。<br>​    4、在线程组中，添加取样器“HTTP请求”组件：选中“线程组”右键 —&gt; 添加 —&gt; 取样器 —&gt; HTTP请求。<br>​    5、在线程组中，添加取样器“BeanShell 取样器”组件：选中“线程组”右键 —&gt; 添加 —&gt; 取样器 —&gt; BeanShell<br>取样器BeanShell 取样器。<br>​    6、在线程组中，添加配置元件“HTTP信息头管理器”组件：选中“线程组”右键 —&gt; 添加 —&gt; 配置元件 —&gt; HTTP信息头管理器。<br>​    7、在线程组中，添加监听器“察看结果树”组件：选中“线程组”右键 —&gt; 添加 —&gt; 监听器 —&gt; 察看结果树。</p><p>最终测试计划中的元件如下：</p><p><img src="../images/%E5%9B%BE%E5%83%8F.jpg" alt="图像"></p><h4 id="3-用户登陆请求的相关操作"><a href="#3-用户登陆请求的相关操作" class="headerlink" title="3. 用户登陆请求的相关操作"></a>3. 用户登陆请求的相关操作</h4><h5 id="3-1-进行登陆操作获取Cookie信息"><a href="#3-1-进行登陆操作获取Cookie信息" class="headerlink" title="3.1 进行登陆操作获取Cookie信息"></a>3.1 <strong>进行登陆操作获取Cookie信息</strong></h5><p><img src="../images/%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2.jpg" alt="登陆页面"></p><p>通过添加HTTP Cookie管理器组件，会把服务器返回来的Cookie信息，默认存储到线程变量中</p><p><strong>前提</strong>：jmeter.properties文件中，设置CookieManager.save.cookies=true</p><p>然后我们可以通过Debug Sampler（调试取样器）组件，查看到线程变量中的Cookie数据。</p><p><img src="../images/cookie%E5%AD%98%E6%94%BE.jpg" alt="cookie存放"></p><p>说明：保持用户登陆状态的Cookie数据： COOKIE_sid=40cbbff1-567f-4434-b414-1977dd321149，这样我们就找到Cookie的值了。</p><h5 id="3-2-把Cookie数据提升为JMeter的全局属性"><a href="#3-2-把Cookie数据提升为JMeter的全局属性" class="headerlink" title="3.2 把Cookie数据提升为JMeter的全局属性"></a>3.2 <strong>把Cookie数据提升为JMeter的全局属性</strong></h5><p>我们需要通过__setProperty函数，把Cookie数据提升为JMeter的全局属性。这样该Cookie就可以在JMeter脚本中，所有线程组里都可以使用了。（也就是可以在线程组和线程组之间通信）</p><p>接下来点击：工具 —&gt; 函数助手对话框，打开函数助手。（之前的版本在选项中）</p><p>然后选择__setProperty函数。</p><p>第一行填写：填写升级为全局属性后的变量名。（自定义即可）</p><p>第二行填写：定义全局属性的值。（我们就把Cookie属性的值，引用到这里）</p><p>Return Original Value of property (default false)?：返回属性的原始值（默认为 false），默认即可。<br><img src="../images/set.jpg" alt="set"></p><p>这样我们就把Cookie提升为JMeter的全局属性了，变量名叫kuayu_session。</p><p>JMeter的全局属性就相当于在“测试计划”界面中定义的用户定义的变里</p><h5 id="3-3-编写BeanShell取样器组件"><a href="#3-3-编写BeanShell取样器组件" class="headerlink" title="3.3 编写BeanShell取样器组件"></a>3.3 <strong>编写BeanShell取样器组件</strong></h5><p>上面生成的这个函数比较特殊，他必须放到BeanShell Sampler组件里面。当把这个函数放到BeanShell取样器组件里面后，就相当于把变量kuayu_session的值，放到了我们声明的公共空间里面。</p><p><img src="../images/%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.jpg" alt="设置为全局变量"></p><h4 id="4-新建标签请求的相关操作"><a href="#4-新建标签请求的相关操作" class="headerlink" title="4.新建标签请求的相关操作"></a>4.新建标签请求的相关操作</h4><h5 id="4-1-查看标签请求"><a href="#4-1-查看标签请求" class="headerlink" title="4.1 查看标签请求"></a>4.1 查看标签请求</h5><p><img src="../images/%E6%A0%87%E7%AD%BE%E6%96%B0%E5%BB%BA.jpg" alt="标签新建"></p><h5 id="4-2-获取JMeter全局属性"><a href="#4-2-获取JMeter全局属性" class="headerlink" title="4.2 获取JMeter全局属性"></a>4.2 <strong>获取JMeter全局属性</strong></h5><p>因为我们把用户登陆线程组中的Cookie属性提升为JMeter全局属性了。</p><p>需要在查看购物车线程组中把全局属性中的Cookie属性获取到，使用__Property函数。</p><p>打开函数助手：工具 —&gt; 函数助手对话框。（之前的版本在选项中）</p><p>选择__Property函数。</p><p>第一行：填写要获取的JMeter全局属性的变量名。（即：kuayu_session）</p><p>第二行：重用函数计算值的引用名。（可选填）</p><p>默认值：属性未定义时的默认值。</p><p><img src="../images/%E5%8F%96%E7%94%A8cookie.jpg" alt="取用cookie"></p><h5 id="4-3-HTTP信息头管理器内容"><a href="#4-3-HTTP信息头管理器内容" class="headerlink" title="4.3 HTTP信息头管理器内容"></a>4.3 <strong>HTTP信息头管理器内容</strong></h5><p>我们需要把上一步获取到的Cookie信息，放入新建标签的请求中。</p><p>因为是Cookie的相关数据，只能放在请求头的信息中。（如果要是token，就放在请求的参数中</p><p><img src="../images/http%E4%BF%A1%E6%81%AF%E5%A4%B4%E7%AE%A1%E7%90%86%E5%99%A8.jpg" alt="http信息头管理器"></p><p>这样查看新建标签请求，就带有用户的登陆状态了。</p><h5 id="4-4-设置线程组的启动时间"><a href="#4-4-设置线程组的启动时间" class="headerlink" title="4.4 设置线程组的启动时间"></a>4.4 <strong>设置线程组的启动时间</strong></h5><p>因为我们需要等待前面的登陆线程组执行完成后，在进行查看购物的请求，否则将获取不到我们需要的Cookie信息。</p><p>这时候就需要设置线程组元件界面中的调度器属性了。</p><p>我们把持续时间和启动延迟都设置成3，表示JMeter脚本启动3秒后，再执行查看购物线程组中的内容，并持续3秒钟。</p><p><img src="../images/%E8%B0%83%E5%BA%A6%E5%99%A8.jpg" alt="调度器"></p><p>调度器配置（Scheduler Configuration）说明:</p><ul><li>持续时间（秒）：如果选择了调度程序复选框，控制测试执行的持续时间，以秒为单位。</li><li>启动延迟（秒）：如果选择了调度程序复选框，控制测试在多久后启动执行，以秒为单位。</li></ul><h4 id="5-运行结果说明"><a href="#5-运行结果说明" class="headerlink" title="5 运行结果说明"></a>5 运行结果说明</h4><p><img src="../images/%E7%BB%93%E6%9E%9C.jpg" alt="结果"></p><h4 id="6-拓展说明（也很重点）"><a href="#6-拓展说明（也很重点）" class="headerlink" title="6. 拓展说明（也很重点）"></a>6. 拓展说明（也很重点）</h4><p>如上需求，在进行性能测试的时候，我们要保证登陆请求线程组中，所有用户登陆的Cookie或token都保存好，才能进入到下一个线程组中执行其他的跨域关联请求。</p><p>这样就会有两种实现方式：</p><p>1、像本篇文章一样，把需要关联的数据提升到全局属性。</p><p>但是这种方式只能适用于单线程跨域关联，如果是很多用户并发进行跨域关联，该种方式只是把最后一个登陆请求的Cookie或token进行了提升。所以下一个线程组中使用的登陆状态，都是登陆线程组最后一个人的请求状态。<br>2、第二种方式，把登陆请求中的Cookie或token信息，提取出来并保存到一个文件中。然后在其他关联跨域请求中，使用参数化的方式，把用户登陆的Cookie或token信息，传入到所需的请求中，从而实现跨域关联的操作。（推荐）</p><h5 id="6-1-第二种方式实现步骤："><a href="#6-1-第二种方式实现步骤：" class="headerlink" title="6.1 第二种方式实现步骤："></a>6.1 <strong>第二种方式实现步骤：</strong></h5><ol><li>每一个接口放在一个线程组中。</li><li>把登陆接口的返回Cookie数据，写入到.csv文件中。</li><li>jmeter写.csv文件，使用BeanShell。取样器添加后置处理器BeanShell postprocessor。</li><li>在下一个跨域关联接口使用数据，用参数化的方式导入.csv文件。</li></ol><p>提供BeanShell中的数据存储代码（简单示例）</p><pre><code class="shell">import java.io.FileWriter;import java.io.BufferedWriter;FileWriter fstream = new FileWriter(&quot;C:\\Users\\L\\Desktop\\JMeterScript\\user_session.csv&quot;, true);BufferedWriter out = new BufferedWriter(fstream);out.write(vars.get(&quot;COOKIE_ECS_ID&quot;)+&quot;\n&quot;);out.close();fstream.close();</code></pre>]]></content>
      
      
      <categories>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter_cookie处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python @property的使用</title>
      <link href="/2023/05/17/python-property%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/17/python-property%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="1-python的-property是python的一种装饰器，是用来修饰方法的"><a href="#1-python的-property是python的一种装饰器，是用来修饰方法的" class="headerlink" title="1. python的@property是python的一种装饰器，是用来修饰方法的"></a>1. python的@property是python的一种装饰器，是用来修饰方法的</h4><h5 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h5><p>使用@property装饰器来创建<strong>只读属性</strong>，@property装饰器会将<strong>方法</strong>转换为相同名称的<strong>只读属性</strong>,可以与所定义的属性配合使用，这样可以防止属性被修改。</p><h5 id="1-2-修饰方法，使方法可以像属性一样访问"><a href="#1-2-修饰方法，使方法可以像属性一样访问" class="headerlink" title="1.2  修饰方法，使方法可以像属性一样访问"></a>1.2  修饰方法，使方法可以像属性一样访问</h5><pre><code class="python">class DataSet(object):  @property  def method_with_property(self): ##含有@property      return 15  def method_without_property(self): ##不含@property      return 15l = DataSet()print(l.method_with_property) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。print(l.method_without_property())  #没有加@property , 必须使用正常的调用方法的形式，即在后面加()# 两个输出都为15</code></pre><p>如果使用property进行修饰后，又在调用的时候，方法后面添加了()， 那么就会显示错误信息：TypeError: ‘int’ object  is not callable，也就是说添加@property  后，这个方法就变成了一个属性，如果后面加入了()，那么就是当作函数来调用，而它却不是callable（可调用）的。</p><h5 id="1-3-不加括号"><a href="#1-3-不加括号" class="headerlink" title="1.3 不加括号"></a>1.3 不加括号</h5><p>没有使用property修饰，它是一种方法，如果把括号去掉，不会报错输出的就会是方法存放的地址。</p><pre><code class="python">class DataSet(object):  def method_without_property(self): ##不含@property      return 15l = DataSet()print(l.method_without_property） #没有加@property , 必须使用正常的调用方法的形式，即在后面加()</code></pre><h4 id="2-与所定义的属性配合使用，这样可以防止属性被修改"><a href="#2-与所定义的属性配合使用，这样可以防止属性被修改" class="headerlink" title="2. 与所定义的属性配合使用，这样可以防止属性被修改"></a>2. 与所定义的属性配合使用，这样可以防止属性被修改</h4><p>​        由于python进行属性的定义时，没办法设置私有属性，因此要通过@property的方法来进行设置。这样可以隐藏属性名，让用户进行使用的时候无法随意修改。</p><pre><code class="python">class DataSet(object):    def __init__(self):        self._images = 1        self._labels = 2 #定义属性的名称    @property    def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。        return self._images     @property    def labels(self):        return self._labelsl = DataSet()#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。</code></pre><p>总结：类中定义私有属性有两种方式：一种用单下划线，表示这个属性是类的私有属性，不希望被外部访问到，但仅仅是不希望，还是可以被访问的；第二种是双下划线，表示这个属性就是类的私有属性，只能在类中被使用，不可以在实例化的对象中去使用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest_parametrize()参数化</title>
      <link href="/2023/02/23/pytest-parametrize-%E5%8F%82%E6%95%B0%E5%8C%96/"/>
      <url>/2023/02/23/pytest-parametrize-%E5%8F%82%E6%95%B0%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h5 id="pytest参数化"><a href="#pytest参数化" class="headerlink" title="pytest参数化"></a>pytest参数化</h5><ol><li>pytest.mark.parametrize()方式进行<a href="https://so.csdn.net/so/search?q=%E5%8F%82%E6%95%B0%E5%8C%96&spm=1001.2101.3001.7020">参数化</a></li><li>pytest.fixture()方式进行参数化，fixture装饰的函数可以作为参数传入其他函数</li><li>conftest.py 文件中存放参数化函数，可作用于模块内的所有</li><li>测试用例 支持元组，列表，支持列表嵌套列表，列表嵌套元组，列表嵌套字典，支持类和函数的参数化</li></ol><pre><code class="python">一，@pytest.mark.parametrize(&#39;参数名&#39;，list)方式pytest.mark.parametrize(argnames, argvalues)，是pytest自带的装饰器之一1. 传一个参数 @pytest.mark.parametrize(&#39;参数名&#39;，list)2. 传两个参数@pytest.mark.parametrize(&#39;参数名1，参数名2&#39;，[(参数1_data[0], 参数2_data[0]),(参数1_data[1], 参数2_data[1])]) 进行参数化,参数值，是list,多组数据用元组类型; 传三个或更多参数也是这样传。list的每个元素都是一个元组，元组里的每个元素和按参数顺序一一对应</code></pre><h6 id="单个变量"><a href="#单个变量" class="headerlink" title="单个变量"></a>单个变量</h6><pre><code class="python">import pytest@pytest.mark.parametrize(&#39;user&#39;, (&quot;zhangsan&quot;, &quot;lisi&quot;))def test_01(user):    print(user)</code></pre><h6 id="单个参数，参数为列表"><a href="#单个参数，参数为列表" class="headerlink" title="单个参数，参数为列表"></a>单个参数，参数为列表</h6><pre><code class="python">import pytestdatatest04 = [&#39;zhangsan&#39;, &#39;lisi&#39;]@pytest.mark.parametrize(&#39;user&#39;, datatest04)def test_04(user):    print(user)</code></pre><h6 id="多个变量，列表中嵌套元组。列表中，每一组数据用元组格式"><a href="#多个变量，列表中嵌套元组。列表中，每一组数据用元组格式" class="headerlink" title="多个变量，列表中嵌套元组。列表中，每一组数据用元组格式"></a>多个变量，列表中嵌套元组。列表中，每一组数据用元组格式</h6><pre><code class="python">import pytest@pytest.mark.parametrize(&#39;user,password&#39;, [(&quot;zhangsan&quot;, &quot;111111&quot;), (&quot;lisi&quot;, &quot;222222&quot;)])def test_02(user, password):    print(user, password)</code></pre><h6 id="多个变量，列表中嵌套列表。列表中，每一组数据用列表格式"><a href="#多个变量，列表中嵌套列表。列表中，每一组数据用列表格式" class="headerlink" title="多个变量，列表中嵌套列表。列表中，每一组数据用列表格式"></a>多个变量，列表中嵌套列表。列表中，每一组数据用列表格式</h6><pre><code class="python">import pytestdata = [[&quot;zhangsan&quot;, &quot;111111111&quot;], [&quot;lisi&quot;, &quot;2222222&quot;]]@pytest.mark.parametrize(&#39;user,password&#39;, data)def test_05(user, password):    print(user, password)</code></pre><h6 id="组合函数-笛卡尔集"><a href="#组合函数-笛卡尔集" class="headerlink" title="组合函数-笛卡尔集"></a>组合函数-笛卡尔集</h6><pre><code class="python">import pytestdata1 = [&quot;zhangsan&quot;, &quot;lisi&quot;]data2 = [&quot;1111111&quot;, &quot;2222222&quot;]@pytest.mark.parametrize(&#39;user&#39;, data1)@pytest.mark.parametrize(&#39;password&#39;, data2)def test_06(user, password):    print(user, password)</code></pre><h6 id="列表嵌套字典"><a href="#列表嵌套字典" class="headerlink" title="列表嵌套字典"></a>列表嵌套字典</h6><pre><code class="python">import pytestdatatest07 = [&#123;&quot;user&quot;: &quot;zhangsan&quot;, &quot;password&quot;: &quot;111111111&quot;&#125;, &#123;&quot;user&quot;: &quot;lisi&quot;, &quot;password&quot;: &quot;222222&quot;&#125;]@pytest.mark.parametrize(&quot;data&quot;, datatest07)def test_07(data):    print(data)    print(data[&quot;user&quot;], data[&quot;password&quot;])# 执行结果test0223.py::test_07[data0] PASSED                                       [ 50%]&#123;&#39;user&#39;: &#39;zhangsan&#39;, &#39;password&#39;: &#39;111111111&#39;&#125;zhangsan 111111111test0223.py::test_07[data1] PASSED                                       [100%]&#123;&#39;user&#39;: &#39;lisi&#39;, &#39;password&#39;: &#39;222222&#39;&#125;lisi 222222</code></pre>]]></content>
      
      
      <categories>
          
          <category> pytest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest基础3</title>
      <link href="/2023/02/23/pytest%E5%9F%BA%E7%A1%803/"/>
      <url>/2023/02/23/pytest%E5%9F%BA%E7%A1%803/</url>
      
        <content type="html"><![CDATA[<h5 id="pytest基础用法二"><a href="#pytest基础用法二" class="headerlink" title="pytest基础用法二"></a>pytest基础用法二</h5><pre><code class="python">前置条件：1.文件路径：Test_App    - - test_abc.py    - - pytest.ini2.pyetst.ini配置文件内容：[pytest]  命令行参数 addopts = -s 搜索文件名 python_files = test*.py  搜索的类名 python_classes = Test*搜索的函数名 python_functions = test_*</code></pre><h5 id="跳过测试函数"><a href="#跳过测试函数" class="headerlink" title="跳过测试函数"></a>跳过测试函数</h5><pre><code class="python">根据特定的条件，不执行标识的测试函数. 方法：     skipif(condition, reason=None) 参数：     condition：跳过的条件，必传参数     reason：标注原因，必传参数 使用方法：     @pytest.mark.skipif(condition, reason=&quot;xxx&quot;) </code></pre><pre><code class="python">import pytestclass Test_ABC:    def setup_class(self):        print(&quot;-------&gt;setup_class&quot;)    def teardown_class(self):        print(&quot;-------&gt;teardown_class&quot;)    def test_a(self):        print(&quot;-------&gt;test_a&quot;)        assert 1    @pytest.mark.skipif(condition=2&gt;1,reason = &quot;跳过该函数&quot;) # 跳过测试函数test_b    def test_b(self):        print(&quot;-------&gt;test_b&quot;)        assert 0# 执行结果：test0223.py::Test_ABC::test_a -------&gt;setup_classPASSED                                     [ 50%]-------&gt;test_atest0223.py::Test_ABC::test_b SKIPPED (跳过该函数)                       [100%]Skipped: 跳过该函数-------&gt;teardown_class</code></pre><h5 id="标记为预期失败函数"><a href="#标记为预期失败函数" class="headerlink" title="标记为预期失败函数"></a>标记为预期失败函数</h5><pre><code class="tex">标记测试函数为失败函数 方法：     xfail(condition=None, reason=None, raises=None, run=True, strict=False) 常用参数：     condition：预期失败的条件，必传参数     reason：失败的原因，必传参数 使用方法：     @pytest.mark.xfail(condition, reason=&quot;xx&quot;)</code></pre><pre><code class="python">import pytestclass Test_ABC:    def setup_class(self):        print(&quot;-------&gt;setup_class&quot;)    def teardown_class(self):        print(&quot;-------&gt;teardown_class&quot;)    def test_a(self):        print(&quot;-------&gt;test_a&quot;)        assert 1    @pytest.mark.xfail(2 &gt; 1, reason=&quot;标注为预期失败&quot;) # 标记为预期失败函数test_b    def test_b(self):       print(&quot;-------&gt;test_b&quot;)       assert 0if __name__ == &#39;__main__&#39;:    pytest.main()# 执行结果-------&gt;setup_classPASSED                                     [ 50%]-------&gt;test_aXFAIL (标注为预期失败)                     [100%]-------&gt;test_bself = &lt;test0223.Test_ABC object at 0x000001F92D538640&gt;    @pytest.mark.xfail(2 &gt; 1, reason=&quot;标注为预期失败&quot;) # 标记为预期失败函数test_b    def test_b(self):       print(&quot;-------&gt;test_b&quot;)&gt;      assert 0E      assert 0</code></pre><h5 id="函数数据参数化"><a href="#函数数据参数化" class="headerlink" title="函数数据参数化"></a>函数数据参数化</h5><pre><code class="python">方便测试函数对测试属于的获取。 方法：     parametrize(argnames, argvalues, indirect=False, ids=None, scope=None) 常用参数：     argnames：参数名     argvalues：参数对应值，类型必须为list                 当参数为一个时格式：[value]                 当参数个数大于一个时，格式为:[(param_value1,param_value2.....),(param_value1,param_value2.....)] 使用方法:     @pytest.mark.parametrize(argnames,argvalues)     ️ 参数值为N个，测试方法就会运行N次</code></pre><pre><code class="python"># 单个参数示例import pytestclass Test_ABC:    def setup_class(self):        print(&quot;-------&gt;setup_class&quot;)    def teardown_class(self):        print(&quot;-------&gt;teardown_class&quot;)    @pytest.mark.parametrize(&quot;a&quot;, [3, 6])  # a参数被赋予两个值，函数会运行两遍    def test_a(self, a):  # 参数必须和parametrize里面的参数一致        print(&quot;test data:a=%d&quot; % a)        assert a % 3 == 0 # 运行结果 test0223.py::Test_ABC::test_a[3] -------&gt;setup_classPASSED                                  [ 50%]test data:a=3test0223.py::Test_ABC::test_a[6] PASSED                                  [100%]test data:a=6-------&gt;teardown_class</code></pre><pre><code class="python"># 多个参数示例import pytestclass Test_ABC:    def setup_class(self):        print(&quot;-------&gt;setup_class&quot;)    def teardown_class(self):        print(&quot;-------&gt;teardown_class&quot;)    @pytest.mark.parametrize(&quot;a,b&quot;,[(1,2),(0,3)]) # 参数a,b均被赋予两个值，函数会运行两遍    def test_a(self,a,b): # 参数必须和parametrize里面的参数一致        print(&quot;test data:a=%d,b=%d&quot;%(a,b))        assert a+b == 3 # 执行结果 test_abc.py     -------&gt;setup_class    test data:a=1,b=2 # 运行第一次取值 a=1,b=2    .    test data:a=0,b=3 # 运行第二次取值 a=0,b=3    .    -------&gt;teardown_class</code></pre><pre><code class="python"># 函数返回值类型示例：import pytestdef return_test_data():    return [(1, 2), (0, 3)]class Test_ABC:    def setup_class(self):        print(&quot;-------&gt;setup_class&quot;)    def teardown_class(self):        print(&quot;-------&gt;teardown_class&quot;)    @pytest.mark.parametrize(&quot;a,b&quot;, return_test_data())  # 使用函数返回值的形式传入参数值    def test_a(self, a, b):        print(&quot;test data:a=%d,b=%d&quot; % (a, b))        assert a + b == 3# 执行结果test0223.py::Test_ABC::test_a[1-2] -------&gt;setup_classPASSED                                [ 50%]test data:a=1,b=2test0223.py::Test_ABC::test_a[0-3] PASSED                                [100%]test data:a=0,b=3-------&gt;teardown_class</code></pre>]]></content>
      
      
      <categories>
          
          <category> pytest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytest基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest基础2</title>
      <link href="/2023/02/23/pytest%E5%9F%BA%E7%A1%802/"/>
      <url>/2023/02/23/pytest%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<h4 id="pytest用法一"><a href="#pytest用法一" class="headerlink" title="pytest用法一"></a>pytest用法一</h4><pre><code class="python">前置条件：1.文件路径：Test_App    - - test_abc.py    - - pytest.ini2.pyetst.ini配置文件内容：[pytest]  命令行参数 addopts = -s 搜索文件名 python_files = test*.py  搜索的类名 python_classes = Test*搜索的函数名 python_functions = test_*</code></pre><h5 id="pytest之fixture"><a href="#pytest之fixture" class="headerlink" title="pytest之fixture"></a>pytest之fixture</h5><p>fixture修饰器来标记固定的工厂函数,在其他函数，模块，类或整个工程调用它时会被激活并优先执行,通常会被用于完成预置处理和重复操作。</p><pre><code class="python">方法：fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None)常用参数：scope: 被标记方法的作用域&quot;function&quot;(default): 作用于每个测试方法，每个test都运行一次&quot;class&quot;: 作用于整个类，每个class的所有test只运行一次&quot;module&quot;: 作用于整个模块，每个module的所有test只运行一次&quot;session&quot;: 作用于整个session,每个session只运行一次 params：(list类型)提供参数数据，供调用标记方法的函数使用 autouse：是否自动运行,默认为False不运行，设置为True自动运行</code></pre><h5 id="fixture第一个例子（通过参数引用）"><a href="#fixture第一个例子（通过参数引用）" class="headerlink" title="fixture第一个例子（通过参数引用）"></a>fixture第一个例子（通过参数引用）</h5><pre><code class="python">class Test_ABC:    @pytest.fixture()    def before(self):        print(&quot;-------&gt;before&quot;)    def test_a(self,before): # ️ test_a方法传入了被fixture标识的函数，已变量的形式        print(&quot;-------&gt;test_a&quot;)        assert 1if __name__ == &#39;__main__&#39;:    pytest.main(&quot;-s  test_abc.py&quot;)# 执行结果：发现before会优先于测试函数运行test0223.py::Test_ABC::test_a -------&gt;beforePASSED                                     [100%]-------&gt;test_a</code></pre><h5 id="fixture第二个例子（通过函数引用）"><a href="#fixture第二个例子（通过函数引用）" class="headerlink" title="fixture第二个例子（通过函数引用）"></a>fixture第二个例子（通过函数引用）</h5><pre><code class="python">import pytest@pytest.fixture() # fixture标记的函数可以应用于测试类外部def before():    print(&quot;-------&gt;before&quot;)@pytest.mark.usefixtures(&quot;before&quot;)class Test_ABC:    def setup(self):        print(&quot;-------&gt;setup&quot;)    def test_a(self):        print(&quot;-------&gt;test_a&quot;)        assert 1if __name__ == &#39;__main__&#39;:          pytest.main(&quot;-s  test_abc.py&quot;)  执行结果：      test_abc.py       -------&gt;before # 发现before会优先于测试类运行      -------&gt;setup      -------&gt;test_a      .</code></pre><h5 id="fixture第三个例子（默认设置为运行）"><a href="#fixture第三个例子（默认设置为运行）" class="headerlink" title="fixture第三个例子（默认设置为运行）"></a>fixture第三个例子（默认设置为运行）</h5><pre><code class="python">import pytest@pytest.fixture(autouse=True) # 设置为默认运行def before(): print(&quot;-------&gt;before&quot;)class Test_ABC: def setup(self):     print(&quot;-------&gt;setup&quot;) def test_a(self):     print(&quot;-------&gt;test_a&quot;)     assert 1if __name__ == &#39;__main__&#39;: pytest.main(&quot;-s  test_abc.py&quot;)# 执行结果：test0223.py::Test_ABC::test_a -------&gt;before #发现before自动优先于测试类运行-------&gt;setupPASSED                                     [100%]-------&gt;test_a</code></pre><h5 id="fixture第四个例子-设置作用域为function"><a href="#fixture第四个例子-设置作用域为function" class="headerlink" title="fixture第四个例子(设置作用域为function)"></a>fixture第四个例子(设置作用域为function)</h5><pre><code class="python">import pytest@pytest.fixture(scope=&#39;function&#39;,autouse=True) # 作用域设置为function，自动运行def before():    print(&quot;-------&gt;before&quot;)class Test_ABC:    def setup(self):        print(&quot;-------&gt;setup&quot;)    def test_a(self):        print(&quot;-------&gt;test_a&quot;)        assert 1    def test_b(self):        print(&quot;-------&gt;test_b&quot;)        assert 1if __name__ == &#39;__main__&#39;:    pytest.main(&quot;-s  test_abc.py&quot;)# 执行结果：test0223.py::Test_ABC::test_a -------&gt;before # 运行第一次-------&gt;setupPASSED                                     [ 50%]-------&gt;test_atest0223.py::Test_ABC::test_b -------&gt;before # 运行第二次-------&gt;setupPASSED                                     [100%]-------&gt;test_b</code></pre><h5 id="fixture第五个例子-设置作用域为class"><a href="#fixture第五个例子-设置作用域为class" class="headerlink" title="fixture第五个例子(设置作用域为class)"></a>fixture第五个例子(设置作用域为class)</h5><pre><code class="python">import pytest@pytest.fixture(scope=&#39;class&#39;,autouse=True) # 作用域设置为class，自动运行def before():    print(&quot;-------&gt;before&quot;)class Test_ABC:    def setup(self):        print(&quot;-------&gt;setup&quot;)    def test_a(self):        print(&quot;-------&gt;test_a&quot;)        assert 1    def test_b(self):        print(&quot;-------&gt;test_b&quot;)        assert 1if __name__ == &#39;__main__&#39;:    pytest.main(&quot;-s  test_abc.py&quot;)# 执行结果test0223.py::Test_ABC::test_a -------&gt;before  # 发现只运行一次-------&gt;setupPASSED                                     [ 50%]-------&gt;test_atest0223.py::Test_ABC::test_b -------&gt;setupPASSED                                     [100%]-------&gt;test_b</code></pre><h5 id="fixture第六个例子-返回值"><a href="#fixture第六个例子-返回值" class="headerlink" title="fixture第六个例子(返回值)"></a>fixture第六个例子(返回值)</h5><pre><code class="python">import pytest@pytest.fixture()def need_data():    return 2  # 返回数字2class Test_ABC:    def test_a(self, need_data):        print(&quot;-------&gt;test_a&quot;)        assert need_data != 3  # 拿到返回值做一次断言if __name__ == &#39;__main__&#39;:    pytest.main(&quot;-s  test_abc.py&quot;) # 执行结果    test_abc.py     -------&gt;test_a    .</code></pre><pre><code class="python"># 示例二import pytest@pytest.fixture(params=[1, 2, 3])def need_data(request):  # 传入参数request 系统封装参数    return request.param  # 取列表中单个值，默认的取值方式class Test_ABC:     def test_a(self, need_data):        print(&quot;-------&gt;test_a&quot;)        assert need_data != 3  # 断言need_data不等于3if __name__ == &#39;__main__&#39;:    pytest.main(&quot;-s  test_abc.py&quot;)# 执行结果运行了三次PASSED                                  [ 33%]-------&gt;test_aPASSED                                  [ 66%]-------&gt;test_aFAILED                                  [100%]-------&gt;test_atest0223.py:10 (Test_ABC.test_a[3])self = &lt;test0223.Test_ABC object at 0x000001F7D83E8550&gt;, need_data = 3    def test_a(self, need_data):        print(&quot;-------&gt;test_a&quot;)&gt;       assert need_data != 3  # 断言need_data不等于3E       assert 3 != 3test0223.py:13: AssertionError</code></pre>]]></content>
      
      
      <categories>
          
          <category> pytest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytest基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest基础1</title>
      <link href="/2023/02/22/pytest%E5%9F%BA%E7%A1%801/"/>
      <url>/2023/02/22/pytest%E5%9F%BA%E7%A1%801/</url>
      
        <content type="html"><![CDATA[<h4 id="pytest框架约束"><a href="#pytest框架约束" class="headerlink" title="pytest框架约束"></a>pytest框架约束</h4><p>1.所有的单测文件名都需要满足test_*.py格式或*_test.py格式。<br>2.在单测文件中，测试类以Test开头，并且不能带有 init 方法(注意：定义class时，需要以T开头，不然pytest是不会去运行该class的)<br>3.在单测类中，可以包含一个或多个test_开头的函数。此时，在执行pytest命令时，会自动从当前目录及子目录中寻找符合上述约束的测试函数来执行。</p><h5 id="控制测试用例执行"><a href="#控制测试用例执行" class="headerlink" title="控制测试用例执行"></a>控制测试用例执行</h5><p>1.在第N个用例失败后，结束测试执行</p><p>pytest -x                    # 第01次失败，就停止测试<br>pytest –maxfail=2     # 出现2个失败就终止测试</p><p>2.指定测试模式    pytest test_mod.py</p><p>3.指定测试目录    pytest    ./test/</p><p>4.通过node id 指定测试用例 ，nodeid由模块文件名、分隔符、类名、方法名、参数构成，                pytest test_mod.py::test_func</p><p>运行模块中的指定方法：pytest test_mod.py::TestClass::test_method</p><p>5.通过标记表达式执行  pytest -m slow   会执行被装饰器@pytest.mark.slow装饰的所有测试用例</p><p>6、通过包执行测试        pytest –pyargs pkg.testing  这条命令会自动导入包pkg.testing,并使用该包所在的目录，执行下面的用例</p><h4 id="其它运行方法"><a href="#其它运行方法" class="headerlink" title="其它运行方法"></a>其它运行方法</h4><p>1.多进程运行cases,当cases量很多时，运行时间也会变的很长，如果想缩短脚本运行的时长，就可以用多进程来运行。</p><p>安装pytest-xdist: pip install -U pytest-xdist</p><p>运行模式：pytest test_demo1.py -n NUM</p><p>2.重试运行cases:  在做接口测试时，有事会遇到503或短时的网络波动，导致case运行失败，而这并非是我们期望的结果，此时可以就可以通过重试运行cases的方式来解决。</p><p>安装pytest-rerunfailures：pip install -U pytest-rerunfailures</p><p>pytest test_se.py –reruns NUM</p><p>3.显示print内容：在运行测试脚本时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是在运行pytest时，这些内容不会显示出来。如果带上-s，就可以显示了。</p><p>pytest test_se.py -s -n 4</p><h5 id="pytest的set和teardown函数"><a href="#pytest的set和teardown函数" class="headerlink" title="pytest的set和teardown函数"></a>pytest的set和teardown函数</h5><p>1.setup和teardown主要分为：模块级，类，功能，函数级</p><p>函数级别setup()和teardown():运行于测试方法的始末</p><p>运行一次函数会运行一次setup和teardown</p><pre><code class="python">import pytestclass Test_ABC:  # 函数级开始  def setup(self):      print(&quot;-------&gt;setup_method&quot;)  # 函数级结束  def teardown(self):      print(&quot;-------&gt;teardown_method&quot;)  def test_a(self):      print(&quot;-------&gt;test_a&quot;)      assert 1  def test_b(self):      print(&quot;-------&gt;test_b&quot;)if __name__ == &#39;__main__&#39;:              pytest.main(&quot;-s  test_abc.py&quot;)</code></pre><pre><code class="python">执行结果：test0223.py::Test_ABC::test_a -------&gt;setup_methodPASSED                                     [ 50%]-------&gt;test_a-------&gt;teardown_methodtest0223.py::Test_ABC::test_b -------&gt;setup_methodPASSED                                     [100%]-------&gt;test_b-------&gt;teardown_method</code></pre><p>类级别：运行于测试类的始末，即:在一个测试内只运行一次setup_class和teardown_class，不关心测试类内有多少个测试函数。</p><pre><code class="python">import pytestclass Test_ABC:   # 测试类级开始   def setup_class(self):       print(&quot;-------&gt;setup_class&quot;)   # 测试类级结束   def teardown_class(self):       print(&quot;-------&gt;teardown_class&quot;)   def test_a(self):       print(&quot;-------&gt;test_a&quot;)       assert 1   def test_b(self):       print(&quot;-------&gt;test_b&quot;)if __name__ == &#39;__main__&#39;:  pytest.main(&quot;-s  test_abc.py&quot;)执行结果：test0223.py::Test_ABC::test_a -------&gt;setup_class  #第一次setup_class()PASSED                                     [ 50%]-------&gt;test_atest0223.py::Test_ABC::test_b PASSED                                     [100%]-------&gt;test_b-------&gt;teardown_class    # 第一次teardown_class()</code></pre><h5 id="Pytest配置文件"><a href="#Pytest配置文件" class="headerlink" title="Pytest配置文件"></a>Pytest配置文件</h5><p>pytest的配置文件通常放在测试目录下，名称为pytest.ini，命令行运行时会使用该配置文件中的配置.</p><pre><code class="python"># 配置pytest命令行运行参数[pytest]addopts = -s...  # 空格分隔，可添加多个命令行参数 -所有参数均为插件包的参数配置测试搜索的路径testpaths =./ scripts  # 当前目录下的scripts文件夹 -可自定义# 配置测试搜索的文件名称python_files = test *.py# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件 -可自定义配置测试搜索的测试类名python_classes = Test_ *# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件中，以Test开头的类 -可自定义配置测试搜索的测试函数名python_functions = test_ *# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件中，以Test开头的类内，以test_开头的方法 -可自定义# 前置条件    - Test_App    - - test_abc.py    - - pytest.ini# pytest.ini的配置文件内容      [pytest]    # 命令行参数     addopts = -s    # 搜索文件名     python_files = test_*.py     # 搜索的类名     python_classes = Test_*     #搜索的函数名        python_functions = test_*</code></pre><h5 id="pytest测试报告"><a href="#pytest测试报告" class="headerlink" title="pytest测试报告"></a>pytest测试报告</h5><pre><code class="text">pytest-HTML是一个插件，pytest用于生成测试结果的HTML报告安装方式：pip install pytest-html                   pip install pytest-html通过命令行方式，生成xm l /html格式的测试报告，存储于用户指定路径。插件名称：pytes t -html使用方法： 命令行格式：pytest --html = 用户路径 / report.html</code></pre><pre><code class="python">import pytestclass Test_ABC:    def setup_class(self):        print(&quot;-------&gt;setup_class&quot;)    def teardown_class(self):        print(&quot;-------&gt;teardown_class&quot;)    def test_a(self):        print(&quot;-------&gt;test_a&quot;)        assert 1    def test_b(self):        print(&quot;-------&gt;test_b&quot;)        assert 0  # 断言失败```运行方式：1.修改Test_App / pytest.ini文件，添加报告参数，即：addopts = -s - -html =./ report.html# -s:输出程序运行信息# --html=./report.html 在当前目录下生成report.html文件️若要生成xml文件，可将 - -html =./ report.html改成 - -html =./ report.xml2.命令行进入Test_App目录3.执行命令： pytest执行结果：1.在当前目录会生成assets文件夹和report.html文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> pytest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytest基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML测试报告</title>
      <link href="/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
      <url>/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h4 id="HTML下载与安装"><a href="#HTML下载与安装" class="headerlink" title="HTML下载与安装"></a>HTML下载与安装</h4><p>HTMLTestRunner.py 文件，既可以把它当作Python 的第三方库来使用，也可以将把它当作项目的一部分来使用。建议将该文件放到python的lib目录下；如果把 HTMLTestRunner 当作项目的一部分来使用，就把它放到项目目录中。可以方便地定制生成的HTMLTestRunner 报告,文件目录结构如下：</p><p><img src="/.com//../imags/$%7Bfiilename%7D/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-16690114393791.jpg"></p><pre><code class="python">#test_unittest1.py文件import unittestfrom selenium import webdriverfrom time import sleepclass TestBaidu(unittest.TestCase):    driver = None    @classmethod    def setUpClass(cls):        cls.driver = webdriver.Chrome()        cls.base_url = &quot;https://www.baidu.com&quot;    def baidu_search(self, search_key):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(2)    def test_search_key_selenium(self):        &quot;&quot;&quot;&quot; 搜索关键字：selenium &quot;&quot;&quot;  # 加了注释的测试报告        search_key = &quot;selenium&quot;        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    def test_search_key_unittest(self):        &quot;&quot;&quot; 搜索关键字：unittest&quot;&quot;&quot;        search_key = &quot;unittest&quot;        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    @classmethod    def tearDownClass(cls):        cls.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><pre><code class="python">#run_tests.py文件import unittestfrom HTMLTestRunner import HTMLTestRunnerimport time# 定义测试用例的目录为当前目录下的test_case 目录test_dir = &#39;./test_case&#39;suit = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;)# if __name__ == &#39;__main__&#39;:#     # 生成HTML 格式的报告#     fp = open(&#39;./test_report/result.html&#39;, &#39;wb&#39;)#     runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)#     runner.run(suit)#     fp.close()if __name__ == &#39;__main__&#39;:    # 取当前日期时间，修改测试报告名称，确保测试报告不会被覆盖    # strftime()方法以指定的格式获取当前日期时间    now_time = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)    fp = open(&#39;./test_report/&#39;+ now_time +&#39;result.html&#39;, &#39;wb&#39;)    runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)    runner.run(suit)    fp.close()</code></pre><h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><pre><code class="python">import codecsimport csvimport unittestfrom itertools import islicefrom time import sleepfrom selenium import webdriverclass TestBaidu(unittest.TestCase):    @classmethod    def setUpClass(cls):        cls.driver = webdriver.Chrome()        cls.base_url = &quot;https://www.baidu.com&quot;        cls.test_data = []        with codecs.open(&#39;data.csv&#39;, &#39;r&#39;, &#39;utf_8_sig&#39;) as f:            data = csv.reader(f)            for line in islice(data, 1, None):                cls.test_data.append(line)    @classmethod    def tearDownClass(cls):        cls.driver.quit()    def baidu_search(self, search_key):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(3)    def test_search_selenium(self):        self.baidu_search(self.test_data[0][1])    def test_search_unittest(self):        self.baidu_search(self.test_data[1][1])    def test_search_parameterized(self):        self.baidu_search(self.test_data[2][1])if __name__ == &#39;__main__&#39;:    unittest.main(verbosity=2)    verbosity是一个选项,表示测试结果的信息复杂度，有0、1、2 三个值    0 (静默模式): 你只能获得总的测试用例数和总的结果 比如 总共10个 失败2 成功8    1 (默认模式): 非常类似静默模式 只是在每个成功的用例前面有个“.” 每个失败的用例前面有个 “F”    2 (详细模式):测试结果会显示每个测试用例的所有相关的信息    并且 你在命令行里加入不同的参数可以起到一样的效果    加入 --quiet 参数 等效于 verbosity=0    加入--verbose参数等效于 verbosity=2    什么都不加就是 verbosity=1</code></pre><h4 id="Parameterized"><a href="#Parameterized" class="headerlink" title="Parameterized"></a>Parameterized</h4><pre><code class="python">import unittestfrom time import sleepfrom selenium import webdriverfrom parameterized import parameterizedclass TestBaidu(unittest.TestCase):    @classmethod    def setUpClass(cls):        cls.driver = webdriver.Chrome()        cls.base_url = &quot;https://www.baidu.com&quot;    def baidu_search(self, search_key):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(2)    # 通过Parameterized 实现参数化    @parameterized.expand([    (&quot;case1&quot;, &quot;selenium&quot;),    (&quot;case2&quot;, &quot;unittest&quot;),    (&quot;case3&quot;, &quot;parameterized&quot;),    ])    def test_search(self, name, search_key):        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    @classmethod    def tearDownClass(cls):        cls.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main(verbosity=2)</code></pre><h4 id="DDT"><a href="#DDT" class="headerlink" title="DDT"></a>DDT</h4><pre><code class="python">#列举了三组参数化，第一组为列表，第二组为元组，第三组为字典。需要注意的是，字典的key与测试方法的参数要保持一致。import unittestfrom time import sleepfrom selenium import webdriverfrom ddt import ddt, data, file_data, unpack@ddtclass TestBaidu(unittest.TestCase):    @classmethod    def setUpClass(cls):        cls.driver = webdriver.Chrome()        cls.base_url = &quot;https://www.baidu.com&quot;    def baidu_search(self, search_key):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(3)    # 参数化使用方式一    @data([&quot;case1&quot;, &quot;selenium&quot;], [&quot;case2&quot;, &quot;ddt&quot;], [&quot;case3&quot;, &quot;python&quot;])    @unpack    def test_search1(self, case, search_key):        print(&quot;第一组测试用例：&quot;, case)        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    # 参数化使用方式二    @data((&quot;case1&quot;, &quot;selenium&quot;), (&quot;case2&quot;, &quot;ddt&quot;), (&quot;case3&quot;, &quot;python&quot;))    @unpack    def test_search2(self, case, search_key):        print(&quot;第二组测试用例：&quot;, case)        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    # 参数化使用方式三    @data(&#123;&quot;search_key&quot;: &quot;selenium&quot;&#125;, &#123;&quot;search_key&quot;: &quot;ddt&quot;&#125;, &#123;&quot;search_key&quot;:    &quot;python&quot;&#125;)    @unpack    def test_search3(self, search_key):        print(&quot;第三组测试用例：&quot;, search_key)        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    @classmethod    def tearDownClass(cls):        cls.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main(verbosity=2)</code></pre><p>DDT 同样支持数据文件的参数化。它封装了数据文件的读取,不需要关心数据文件是如何被读取进来的</p><pre><code class="python">#创建ddt_data_file.json文件&#123;&quot;case1&quot;: &#123;&quot;search_key&quot;: &quot;python1&quot;&#125;,&quot;case2&quot;: &#123;&quot;search_key&quot;: &quot;ddt1&quot;&#125;,&quot;case3&quot;: &#123;&quot;search_key&quot;: &quot;Selenium1&quot;&#125;&#125;</code></pre><pre><code class="python">import unittestfrom time import sleepfrom selenium import webdriverfrom ddt import ddt, data, file_data, unpack@ddtclass TestBaidu(unittest.TestCase):    @classmethod    def setUpClass(cls):        cls.driver = webdriver.Chrome()        cls.base_url = &quot;https://www.baidu.com&quot;    def baidu_search(self, search_key):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(3)            @file_data(&#39;ddt_data_file.json&#39;)    def test_search4(self, search_key):        print(&quot;第四组测试用例：&quot;, search_key)        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    @classmethod    def tearDownClass(cls):        cls.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main(verbosity=2)</code></pre><p>DDT 还支持yaml 格式的数据文件</p><pre><code class="python">case1:- search_key: &quot;python&quot;case2:- search_key: &quot;ddt&quot;case3:- search_key: &quot;unittest&quot;</code></pre><pre><code class="python">@file_data(&#39;ddt_data_file.yaml&#39;)def test_search5(self, case):search_key = case[0][&quot;search_key&quot;]print(&quot;第五组测试用例：&quot;, search_key)self.baidu_search(search_key)self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)</code></pre><h4 id="自动发送邮件功能"><a href="#自动发送邮件功能" class="headerlink" title="自动发送邮件功能"></a>自动发送邮件功能</h4><pre><code class="python">import timeimport unittestimport yagmailfrom HTMLTestRunner import HTMLTestRunner#把测试报告作为附件发送到指定邮箱def send_mail(report):    yag = yagmail.SMTP(user=&quot;sender@126.com&quot;,    password=&quot;a123456&quot;,    host=&#39;smtp.126.com&#39;)    subject = &quot;主题，自动化测试报告&quot;    contents = &quot;正文，请查看附件。&quot;    yag.send(&#39;receiver@126.com&#39;, subject, contents, report)    print(&#39;email has send out !&#39;)if __name__ == &#39;__main__&#39;:    # 定义测试用例的目录为当前目录    test_dir = &#39;./test_case&#39;    suit = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;)    # 获取当前日期和时间    now_time = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)    html_report = &#39;./test_report/&#39; + now_time + &#39;result.html&#39;    fp = open(html_report, &#39;wb&#39;)    # 调用HTMLTestRunner，运行测试用例    runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)    runner.run(suit)    fp.close()    send_mail(html_report)  # 发送报告</code></pre>]]></content>
      
      
      <categories>
          
          <category> unittest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unittest执行用例</title>
      <link href="/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/"/>
      <url>/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="测试用例的执行顺序"><a href="#测试用例的执行顺序" class="headerlink" title="测试用例的执行顺序"></a>测试用例的执行顺序</h4><p>测试用例的执行顺序涉及多个层级：多个测试目录&gt;多个测试文件&gt;多个测试类&gt;多个测试方法（测试用例）</p><p>``</p><pre><code class="python">import unittestclass TestBdd(unittest.TestCase):    def setUp(self):        print(&quot;test TestBdd:&quot;)    def test_ccc(self):        print(&quot;test ccc&quot;)    def test_aaa(self):        print(&quot;test aaa&quot;)class TestAdd(unittest.TestCase):    def setUp(self):        print(&quot;test TestAdd:&quot;)    def test_bbb(self):        print(&quot;test bbb&quot;)if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><p>unittest 默认根据ASCII 码的顺序加载测试用例的（数字与字母的顺序为0<del>9，A</del>Z，a~z），所以TestAdd 类会优先于TestBdd 类被执行，test_aaa()方法会优先于test_ccc()方法被执行，也就是说，它并不是按照测试用例的创建顺序从上到下执行的。</p><p>声明测试套件TestSuite 类，通过addTest()方法按照一定的顺序来加载测试用<br>例。</p><p>现在的执行顺序与addTest()方法加载测试用例的顺序相同。不过，当测试用例非常多时，不推荐用这种方法创建测试套件。最好的方法是通过命名控制执行顺序</p><p>``</p><pre><code class="python">if __name__ == &#39;__main__&#39;:    # 构造测试集    suite = unittest.TestSuite()    suite.addTest(TestBdd(&quot;test_aaa&quot;))    suite.addTest(TestBdd(&quot;test_ccc&quot;))    suite.addTest(TestAdd(&quot;test_bbb&quot;))    # 执行测试    runner = unittest.TextTestRunner()    runner.run(suite)</code></pre><h4 id="执行多级目录的测试用例"><a href="#执行多级目录的测试用例" class="headerlink" title="执行多级目录的测试用例"></a>执行多级目录的测试用例</h4><p>当测试用例的数量达到一定量级时，就要考虑目录划分，</p><p>``</p><pre><code>test_project├──/test_case/│ ├── test_bbb/│ │ ├── test_ccc/│ │ │ └── test_c.py│ │ └── test_b.py│ ├── test_ddd/│ │ └── test_d.py│ └── test_a.py└─ run_tests.py</code></pre><p>对于上面的目录结构，如果将discover()方法中的start_dir 参数定为“./test_case”目<br>录，那么只能加载test_a.py 文件中的测试用例。如何让unittest 查找test_case/下子目录中的测试文件呢？方法很简单，就是在每个子目录下放一个__init__.py 文件。<strong>init</strong>.py 文件的作用是将一个目录标记成一个标准的Python 模块。</p><h4 id="跳过测试和预期失败"><a href="#跳过测试和预期失败" class="headerlink" title="跳过测试和预期失败"></a>跳过测试和预期失败</h4><p>``</p><pre><code>import unittestclass MyTest(unittest.TestCase):    @unittest.skip(&quot;直接跳过测试&quot;)  # unittest.skip(reason)无条件地跳过装饰的测试，需要说明跳过测试的原因    def test_skip(self):        print(&quot;test aaa&quot;)    @unittest.skipIf(3 &gt; 2, &quot;当条件为真时跳过测试&quot;)# unittest.skipIf(condition, reason) 如果条件为真，则跳过装饰的测试。    def test_skip_if(self):        print(&#39;test bbb&#39;)    @unittest.skipUnless(3 &gt; 2, &quot;当条件为真时执行测试&quot;)#unittest.skipUnless(condition, reason)当条件为真时，执行装饰的测试    def test_skip_unless(self):        print(&#39;test ccc&#39;)    @unittest.expectedFailure   #unittest.expectedFailure()不管执行结果是否失败，都将测试标记为失败。    def test_expected_failure(self):        self.assertEqual(2, 3)if __name__ == &#39;__main__&#39;:        unittest.main() </code></pre><h5 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h5><pre><code class="python">import unittestdef setUpModule():    print(&quot;test module start &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)def tearDownModule():    print(&quot;test module end &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)class MyTest(unittest.TestCase):    @classmethod    def setUpClass(cls):        print(&quot;test class start =======&gt;&quot;)    @classmethod    def tearDownClass(cls):        print(&quot;test class end =======&gt;&quot;)    def setUp(self):        print(&quot;test case start --&gt;&quot;)    def tearDown(self):        print(&quot;test case end --&gt;&quot;)    def test_case1(self):        print(&quot;test case1&quot;)    def test_case2(self):        print(&quot;test case2&quot;)if __name__ == &#39;__main__&#39;:    unittest.main()setUpModule/tearDownModule：在整个模块的开始与结束时被执行。setUpClass/tearDownClass：在测试类的开始与结束时被执行。setUp/tearDown：在测试用例的开始与结束时被执行。需要注意的是，setUpClass/tearDownClass 为类方法，需要通过@classmethod 进行装饰。另外，方法的参数为cls。其实，cls 与self 并没有什么本质区别，都只表示方法的第一个参数。</code></pre><h4 id="编写web自动化测试"><a href="#编写web自动化测试" class="headerlink" title="编写web自动化测试"></a>编写web自动化测试</h4><p>``</p><pre><code class="python">import unittestfrom time import sleepfrom selenium import webdriverclass TestBaidu(unittest.TestCase):    def setUp(self):        self.driver = webdriver.Chrome()        self.base_url = &quot;https://www.baidu.com&quot;    def test_search_key_selenium(self):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(2)        title = self.driver.title        self.assertEqual(title, &quot;selenium_百度搜索&quot;)    def test_search_key_unittest(self):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;unittest&quot;)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(2)        title = self.driver.title        self.assertEqual(title, &quot;unittest_百度搜索&quot;)    def tearDown(self):        self.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main() 上面的代码不做过多介绍，都是以 unittest 创建测试类和方法的。方法中的代码是Selenium 脚本,代码存在一些问题，</code></pre><p>观察上面代码可以发现，两个测试用例中的步骤是一样的，唯一的区别是搜索的关键字和断言的结果不同，使用模块化，把操作步骤封装成一个方法。</p><p>``</p><pre><code class="python">import unittestfrom selenium import webdriverfrom time import sleepclass TestBaidu(unittest.TestCase):    def setUp(self):        self.driver = webdriver.Chrome()        self.base_url = &quot;https://www.baidu.com&quot;    def baidu_search(self, search_key):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(2)    def test_search_key_selenium(self):        search_key = &quot;selenium&quot;        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    def test_search_key_unittest(self):        search_key = &quot;unittest&quot;        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    def tearDown(self):        self.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main()#baidu_search()方法不会被当作测试用例执行，因为根据unittest 查找和执行测试用例的规则，它只会把以“test”开头的方法当作测试用例</code></pre><p>减少浏览器的启动和关闭次数</p><p>``</p><pre><code class="python">import unittestfrom selenium import webdriverfrom time import sleepclass TestBaidu(unittest.TestCase):    driver = None    @classmethod    def setUpClass(cls):        cls.driver = webdriver.Chrome()        cls.base_url = &quot;https://www.baidu.com&quot;    def baidu_search(self, search_key):        self.driver.get(self.base_url)        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)        self.driver.find_element_by_id(&quot;su&quot;).click()        sleep(2)    def test_search_key_selenium(self):        search_key = &quot;selenium&quot;        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    def test_search_key_unittest(self):        search_key = &quot;unittest&quot;        self.baidu_search(search_key)        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)    @classmethod    def tearDownClass(cls):        cls.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> unittest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unittest概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unittest单元测试框架</title>
      <link href="/2022/11/15/unittest%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/15/unittest%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h4 id="unittest功能"><a href="#unittest功能" class="headerlink" title="unittest功能"></a>unittest功能</h4><ol><li>提供测试用例组织和执行</li><li>提供丰富的断言方法</li><li>提供丰富的日志</li></ol><h4 id="基础代码实现"><a href="#基础代码实现" class="headerlink" title="基础代码实现"></a>基础代码实现</h4><p>``</p><pre><code class="python">import unittestclass Calculator:    &quot;&quot;&quot; 用于完成两个数的加、减、乘、除&quot;&quot;&quot;    def __init__(self, a, b):        self.a = int(a)        self.b = int(b)    # 加法    def add(self):        return self.a + self.b    # 减法    def sub(self):        return self.a - self.b    # 乘法    def mul(self):        return self.a * self.b    # 除法    def div(self):        return self.a / self.bdef test_add():    c = Calculator(3, 5)    result = c.add()    assert result == 8, &#39;加法运算失败!&#39;def test_sub():    c = Calculator(7, 2)    result = c.sub()    assert result == 5, &#39;减法运算失败!&#39;def test_mul():    c = Calculator(3, 3)    result = c.mul()    assert result == 10, &#39;乘法运算失败!&#39;def test_div():    c = Calculator(6, 2)    result = c.div()    assert result == 3, &#39;除法运算失败!&#39;if __name__ == &#39;__main__&#39;:    test_add()    test_sub()    test_mul()    test_div()</code></pre><p>这样的测试存在着一些问题。首先，我们需要自己定义断言失败的提示；其次，当<br>测试函数运行失败后，后面的测试函数将不再执行；最后，执行结果无法统计    </p><h5 id="通过-unittest-单元测试框架重新编写测试用例"><a href="#通过-unittest-单元测试框架重新编写测试用例" class="headerlink" title="通过 unittest 单元测试框架重新编写测试用例"></a>通过 unittest 单元测试框架重新编写测试用例</h5><p>``</p><pre><code class="python">class TestCalculator(unittest.TestCase):    def test_add(self):        c = Calculator(3, 5)        result = c.add()        self.assertEqual(result, 8)    def test_sub(self):        c = Calculator(7, 2)        result = c.sub()        self.assertEqual(result, 5)    def test_mul(self):        c = Calculator(3, 3)        result = c.mul()        self.assertEqual(result, 10)    def test_div(self):        c = Calculator(6, 2)        result = c.div()        self.assertEqual(result, 3)if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><ol><li>创建一个测试类，这里为TestCalculator 类，必须要继承unittest 模块的TestCase类。</li><li>创建一个测试方法，该方法必须以“test”开头。</li><li>通过unittest 提供的assertEqual()方法来断言结果是否与预期结果相同。该方法由TestCase 父类提供，由于继承了该类，所以可以通过self 调用。</li><li>最后，调用unittest 的main()来执行测试用例，它会按照前面的两条规则查找测试用例并执行。</li></ol><h5 id="四个重要的概念：Test-Case、Test-Suite、Test-Runner-和Test-Fixture。"><a href="#四个重要的概念：Test-Case、Test-Suite、Test-Runner-和Test-Fixture。" class="headerlink" title="四个重要的概念：Test Case、Test Suite、Test Runner 和Test Fixture。"></a>四个重要的概念：Test Case、Test Suite、Test Runner 和Test Fixture。</h5><ol><li>Test Case 是最小的测试单元，用于检查特定输入集合的特定返回值。unittest 提供了TestCase 基类，我们创建的测试类需要继承该基类，它可以用来创建新的测试用例。</li><li>测试套件是测试用例、测试套件或两者的集合，用于组装一组要运行的测试。unittest提供了TestSuite 类来创建测试套件。</li><li>Test Runner 是一个组件，用于协调测试的执行并向用户提供结果。Test Runner 可以使用图形界面、文本界面或返回特殊值来展示执行测试的结果。unittest 提供了TextTestRunner类运行测试用例，为了生成HTML 格式的测试报告，后面会选择使用HTMLTestRunner 运行类。</li><li>Test Fixture 代表执行一个或多个测试所需的环境准备，以及关联的清理动作。例如，创建临时或代理数据库、目录，或启动服务器进程,unittest 中提供了setUp()/tearDown()、setUpClass()/tearDownClass()等方法来完成这些操作</li></ol><p>``</p><pre><code class="python">class TestCalculator(unittest.TestCase):    # 测试用例前置动作    def setUp(self):        print(&quot;test start:&quot;)    # 测试用例后置动作    def tearDown(self):        print(&quot;test end&quot;)    def test_add(self):        c = Calculator(3, 5)        result = c.add()        self.assertEqual(result, 8)    def test_sub(self):        c = Calculator(7, 2)        result = c.sub()        self.assertEqual(result, 5)    def test_mul(self):        c = Calculator(3, 3)        result = c.mul()        self.assertEqual(result, 10)    def test_div(self):        c = Calculator(6, 2)        result = c.div()        self.assertEqual(result, 3)if __name__ == &#39;__main__&#39;:# 创建测试套件    suit = unittest.TestSuite()    suit.addTest(TestCalculator(&quot;test_add&quot;))    suit.addTest(TestCalculator(&quot;test_sub&quot;))    suit.addTest(TestCalculator(&quot;test_mul&quot;))    suit.addTest(TestCalculator(&quot;test_div&quot;))# 创建测试运行器    runner = unittest.TextTestRunner()    runner.run(suit)</code></pre><ul><li>首先，创建一个测试类并继承TestCase 类，在该类下面创建一条以“test”开头的方法为测试用例</li><li>在测试类中增加了 setUp()/tearDown()方法，用于定义测试用例的前置和后置动作。在当前测试中暂时用不上，这里定义了一些简单的打印</li><li>抛弃了unittest 提供的main()方法，而是调用TestSuite 类下面addTest()来添加测试用例。因为一次只能添加一条用例，所以需要指定测试类及测试方法。然后，再调用TextTestRunner 类下面的run()运行测试套件。</li><li>优点：相比main()方法。测试用例的执行顺序可以由测试套件的添加顺序控制，而main()方法只能按照测试类、方法的名称来执行测试用例。例如，TestA 类比TestB 类先执行，test_add()用例比test_div()用例先执行。</li><li>其次，当一个测试文件中有很多测试用例时，并不是每次都要执行所有的测试用例，尤其是比较耗时的UI 自动化测试。因而通过测试套件和测试运行器可以灵活地控制要执行的测试用例。</li></ul><h5 id="断言方法"><a href="#断言方法" class="headerlink" title="断言方法"></a>断言方法</h5><p>``</p><pre><code class="python">import unittestclass TestAssert(unittest.TestCase):    def test_equal(self):        self.assertEqual(2+52, 4)        self.assertEqual(&quot;pytgn&quot;, &quot;python&quot;)        self.assertNotEqual(&quot;hello&quot;, &quot;python&quot;)    def test_in(self):        self.assertIn(&quot;hello&quot;, &quot;hello world&quot;)        self.assertNotIn(&quot;hi&quot;, &quot;hello&quot;)    def test_true(self):        self.assertTrue(True)        self.assertFalse(False)if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><h5 id="测试用例的组织与discover-方法"><a href="#测试用例的组织与discover-方法" class="headerlink" title="测试用例的组织与discover 方法"></a>测试用例的组织与discover 方法</h5><p>针对 Calculator 类所编写的测试用例存在的问题：一个功能对应一条测试用例不够的；其次测试用例的划分，建议一个测试类对应一个被测试功能</p><p>``</p><pre><code class="python">class Calculator:    &quot;&quot;&quot; 用于完成两个数的加、减、乘、除&quot;&quot;&quot;    def __init__(self, a, b):        self.a = int(a)        self.b = int(b)    # 加法    def add(self):        return self.a + self.b    # 减法    def sub(self):        return self.a - self.b    # 乘法    def mul(self):        return self.a * self.b    # 除法    def div(self):        return self.a / self.bclass TestAdd(unittest.TestCase):    &quot;&quot;&quot; add()方法测试&quot;&quot;&quot;    def test_add_integer(self):        &quot;&quot;&quot; 整数相加测试&quot;&quot;&quot;        c = Calculator(3, 5)        self.assertEqual(c.add(), 8)    def test_add_decimals(self):        &quot;&quot;&quot; 小数相加测试&quot;&quot;&quot;        c = Calculator(3.2, 5.5)        self.assertEqual(c.add(), 8)    def test_add_string(self):        &quot;&quot;&quot; 字符串整数相加测试&quot;&quot;&quot;        c = Calculator(&quot;7&quot;, &quot;9&quot;)        self.assertEqual(c.add(), 16)    # ……class TestSub(unittest.TestCase):    &quot;&quot;&quot; sub()方法测试&quot;&quot;&quot;    pass# ……if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><h5 id="判断某年是否为闰年"><a href="#判断某年是否为闰年" class="headerlink" title="判断某年是否为闰年"></a>判断某年是否为闰年</h5><p>``</p><pre><code class="python">class LeapYear:    &quot;&quot;&quot;计算某年是否为闰年&quot;&quot;&quot;    def __init__ (self, year):        self.year = int(year)    def answer(self):        year = self.year        if year % 100 == 0:            if year % 400 == 0:                # 整百年能被400 整除的是闰年                return &quot;&#123;0&#125;是闰年&quot;.format(year)            else:                return &quot;&#123;0&#125;不是闰年&quot;.format(year)        else:            if year % 4 == 0:                # 非整百年能被4 整除的是闰年                return &quot;&#123;0&#125;是闰年&quot;.format(year)            else:                return &quot;&#123;0&#125;不是闰年&quot;.format(year)class TestLeapYear(unittest.TestCase):    def test_2000(self):        ly = LeapYear(2000)        self.assertEqual(ly.answer(), &quot;2000是闰年&quot;)    def test_2004(self):        ly = LeapYear(2004)        self.assertEqual(ly.answer(), &quot;2004是闰年&quot;)    def test_2017(self):        ly = LeapYear(2017)        self.assertEqual(ly.answer(), &quot;2017不是闰年&quot;)    def test_2100(self):        ly = LeapYear(2100)        self.assertEqual(ly.answer(), &quot;2100不是闰年&quot;)if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><h5 id="如何执行多个测试文件"><a href="#如何执行多个测试文件" class="headerlink" title="如何执行多个测试文件"></a>如何执行多个测试文件</h5><p>unittest 中的TestLoader 类提供的discover()方法可以从多个文件中查找测试用例。</p><p>该类根据各种标准加载测试用例，并将它们返回给测试套件。正常情况下，不需要创建这个类的实例。unittest 提供了可以共享的defaultTestLoader 类，可以使用其子类或方法创建实例，discover()方法就是其中之一。</p><pre><code class="python">discover(start_dir，pattern=&#39;test*.py&#39;，top_level_dir=None)找到指定目录及其子目录下的所有测试模块，只有匹配的文件名才能被加载。如果启动的不是顶层目录，那么顶层目录必须单独指定。    start_dir ：待测试的模块名或测试用例目录。    pattern=&#39;test*.py&#39; ：测试用例文件名的匹配原则。此处匹配文件名以“test”开头的“.py”类型的文件，星号“*”表示任意多个字符。    top_level_dir=None：测试模块的顶层目录，如果没有顶层目录，则默认为None。</code></pre><pre><code class="python">import unittesttest_dir = &#39;../test1107&#39;suits = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_unit*.py&#39;)if __name__ == &#39;__main__&#39;:    runner = unittest.TextTestRunner()    runner.run(suits)</code></pre><p>discover()方法会自动根据测试用例目录（test_dir）查找测试用例文件（test*.py），并将找到的测试用例添加到测试套件中，因此，可以直接通过run()方法执行测试套件suits。这种方式极大地简化了测试用例的查找，我们需要做的就是按照文件的匹配规则创建测试文件即可。</p>]]></content>
      
      
      <categories>
          
          <category> unittest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unittest概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium多窗口_警告框处理</title>
      <link href="/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/"/>
      <url>/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<pre><code class="python">#多窗口切换# 在页面操作过程中，有时单击某个链接会弹出新的窗口，这时就需要切换到新打开的窗口中进行操作。WebDriver 提供的switch_to.window()方法可以实现在不同的窗口间切换。# current_window_handle：获得当前窗口句柄。window_handles：返回所有窗口的句柄到当前会话。switch_to.window()：切换到相应的窗口。def test_window():    driver = webdriver.Chrome()    driver.get(&quot;https://www.baidu.com&quot;)    #获取百度搜索窗口句柄    search_window = driver.current_window_handle    driver.implicitly_wait(10)    driver.find_element_by_id(&quot;s-top-loginbtn&quot;).click()    driver.implicitly_wait(10)    driver.find_element_by_id(&#39;TANGRAM__PSP_11__regLink&#39;).click()    time.sleep(5)    all_handles = driver.window_handles    #进入注册窗口：暂时不适用，百度需要验证码才可以    for handle in all_handles:        if handle != search_window:            driver.switch_to.window(handle)            print(driver.title)            driver.find_element_by_id(&#39;TANGRAM__PSP_11__userName&#39;).send_keys(&#39;1fafa720fa6&#39;)            driver.find_element_by_id(&#39;TANGRAM__PSP_11__password&#39;).send_keys(&#39;1fa77242226&#39;)            time.sleep(5)            #关闭当前窗口            driver.close()        # 回到搜索窗口        driver.switch_to.window(search_window)        print(driver.title)        driver.quit()#警告框处理# 在 WebDriver 中处理JavaScript 生成的alert、confirm 和prompt 十分简单，具体做法是，# 首先使用switch_to.alert()方法定位，然后使用text、accept、dismiss、send_keys 等进行操作。# text：返回alert、confirm、prompt 中的文字信息。# accept()：接受现有警告框。# dismiss()：解散现有警告框。# send_keys()：在警告框中输入文本（如果可以输入的话）#可以使用 switch_to.alert()方法为百度搜索设置弹窗def test_alert():    driver = webdriver.Chrome()    driver.get(&#39;https://www.baidu.com&#39;)    # 打开搜索设置    # link = driver.find_element_by_link_text(&#39;设置&#39;).click()    driver.find_element_by_id(&#39;s-usersetting-top&#39;).click()    driver.find_element_by_link_text(&quot;搜索设置&quot;).click()    sleep(2)    # 保存设置    driver.find_element_by_class_name(&quot;prefpanelgo&quot;).click()    # 获取警告框    alert = driver.switch_to.alert    # 获取警告框提示信息    alert_text = alert.text    print(alert_text)    time.sleep(3)    # 接取警告框    alert.accept()    driver.quit()# 下拉框处理# WebDriver 提供了Select 类来处理下拉框。# Select类：用于定位&lt;select&gt;标签。# select_by_value()：通过value值定位下拉选项。# select_by_visible_text()：通过text值定位下拉选项。# select_by_index()：根据下拉选项的索引进行选择。第一个选项为0，第二个选项为1。def test_select():    driver = webdriver.Chrome()    path = r&#39;D:\7z\py\html\select.html&#39;    driver.get(path)    # 通过显示等待的方法判断元素是否出现    WebDriverWait(driver, 10).until(EC.visibility_of_element_located((By.NAME, &quot;anjing&quot;)))    select = driver.find_element_by_name(&#39;anjing&#39;)    # 根据下标进行选择，从0开始    Select(select).select_by_index(1)    time.sleep(2)    # 根据value的值选择    Select(select).select_by_value(&#39;daily&#39;)    time.sleep(2)    # 根基text选择    Select(select).select_by_visible_text(&#39;关注了吗？&#39;)    time.sleep(2)    # 判断选择是否预期    WebDriverWait(driver, 20).until(EC.element_located_to_be_selected((By.XPATH, &#39;//*[contains(text(),&quot;关注了&quot;)]&#39;)))    driver.quit()#上传文件def test_upfile():    file_path = os.path.abspath(r&#39;D:\7z\py\html&#39;)    driver = webdriver.Chrome()    upload_page = r&#39;D:\7z\py\html\select.html&#39;    driver.get(upload_page)    # 定位上传按钮，添加本地文件    time.sleep(3)    driver.find_element_by_id(&quot;inputfile&quot;).send_keys(file_path + &#39;/day02.html&#39;)#操作cookie# WebDriver 操作Cookie 的方法如下。# get_cookies()：获得所有Cookie。# get_cookie(name)：返回字典中key 为“name”的Cookie。# add_cookie(cookie_dict)：添加 Cookie。# delete_cookie(name,optionsString)：删除名为OpenString 的Cookie。# delete_all_cookies()：删除所有Cookie。def test_cookie():    driver = webdriver.Chrome()    driver.get(&quot;http://www.baidu.com&quot;)    # 获得所有Cookie 信息并打印    cookie = driver.get_cookies()    print(cookie)    # 添加Cookie 信息    driver.add_cookie(&#123;&#39;name&#39;: &#39;key-aaaaaaa&#39;, &#39;value&#39;: &#39;value-bbbbbb&#39;&#125;)    # 遍历指定的Cookies    for cookie in driver.get_cookies():        print(&quot;%s -&gt; %s&quot; % (cookie[&#39;name&#39;], cookie[&#39;value&#39;]))#调用javascript,实现浏览器滚动条的拖动效果def test_move():    from selenium import webdriver    driver = webdriver.Chrome()    driver.get(&quot;http://www.baidu.com&quot;)    #，通过set_window_size()方法将浏览器窗口设置为固定宽、高显示,目的是让窗口出现水平和垂直滚动条    driver.set_window_size(800, 600)    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)    driver.find_element_by_id(&quot;su&quot;).click()    # 通过JavaScript 设置浏览器窗口的滚动条位置    js = &quot;window.scrollTo(100,450);&quot;    driver.execute_script(js)    time.sleep(4)def test_picture():    from selenium import webdriver    driver = webdriver.Chrome()    driver.get(&#39;http://www.baidu.com&#39;)    # 截取当前窗口，指定截图图片的保存位置</code></pre><h4 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h4><pre><code>&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;上传表单&lt;/title&gt;#上传文件&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;rel=&quot;stylesheet&quot; &gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;jumbotron&quot;&gt;&lt;form class=&quot;form-inline&quot; role=&quot;form&quot;&gt;&lt;div class=&quot;form-group&quot;&gt;&lt;label class=&quot;sr-only&quot; for=&quot;name&quot;&gt;名称&lt;/label&gt;&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;placeholder=&quot;请输入名称&quot;&gt;&lt;/div&gt;&lt;div class=&quot;form-group&quot;&gt;&lt;label class=&quot;sr-only&quot; for=&quot;inputfile&quot;&gt;文件输入&lt;/label&gt;&lt;input type=&quot;file&quot; id=&quot;inputfile&quot;&gt;&lt;/div&gt;&lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;# select 选择&lt;form&gt;&lt;center&gt;&lt;select name=&quot;anjing&quot;&gt;&lt;option value=&quot;boke&quot;&gt;请关注今日天气&lt;/option&gt;&lt;option value=&quot;study&quot;&gt;今天大雨&lt;/option&gt;&lt;option value=&quot;daily&quot;&gt;写写什么&lt;/option&gt;&lt;option value=&quot;like&quot;&gt;喜欢的食物&lt;/option&gt;&lt;option value=&quot;attention&quot;&gt;关注点在哪里&lt;/option&gt;&lt;/center&gt;&lt;/select&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium多窗口_警告框处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium时间等待</title>
      <link href="/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/"/>
      <url>/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/</url>
      
        <content type="html"><![CDATA[<h4 id="获得验证信息"><a href="#获得验证信息" class="headerlink" title="获得验证信息"></a>获得验证信息</h4><pre><code class="python">from time import sleepfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWaitdef test_title():    #title：用于获取当前页面的标题    #current_url：用于获取当前页面的URL    #text：用于获取当前页面的文本信息    driver = webdriver.Chrome()    driver.get(&quot;https://www.baidu.com&quot;)    print(&#39;Before search================&#39;)    # 打印当前页面title    title = driver.title    print(&quot;title:&quot; + title) #title:百度一下，你就知道    # 打印当前页面URL    now_url = driver.current_url    print(&quot;URL:&quot; + now_url) # URL:https://www.baidu.com/    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)    driver.find_element_by_id(&quot;su&quot;).click()    sleep(2)    print(&#39;After search================&#39;)    # 再次打印当前页面title    title = driver.title    print(&quot;title:&quot; + title) #selenium_百度搜索    # 再次打印当前页面URL    now_url = driver.current_url    print(&quot;URL:&quot; + now_url)    # 获取搜索结果条数    # num = driver.find_element_by_class_name(&#39;nums&#39;).text    num = driver.find_element_by_css_selector(&#39;.hint_PIwZX.c_font_2AD7M&#39;).text    print(&quot;result:&quot; + num) #result:百度为您找到相关结果约100,000,000个    driver.quit()</code></pre><h4 id="显示等待和隐士等待"><a href="#显示等待和隐士等待" class="headerlink" title="显示等待和隐士等待"></a>显示等待和隐士等待</h4><p><img src="../images/%E9%A2%84%E6%9C%9F%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95.jpg" alt="预期判断方法"></p><pre><code class="python"># WebDriverWait 类是WebDriver 提供的等待方法。在设置时间内，默认每隔一段时间检# 测一次当前页面元素是否存在，如果超过设置时间仍检测不到，则抛出异常。具体格式如下# WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)# driver：浏览器驱动。# timeout：最长超时时间，默认以秒为单位。# poll_frequency：检测的间隔（步长）时间，默认为0.5s。# ignored_exceptions：超时后的异常信息，默认情况下抛出NoSuchElementException异常。# WebDriverWait()一般与until()或until_not()方法配合使用，下面是until()和until_not()方法的说明。until(method, message=″)# 调用该方法提供的驱动程序作为一个参数，直到返回值为True。until_not(method, message=″)调用该方法提供的驱动程序作为一个参数，直到返回值为False。def test_time():    driver = webdriver.Chrome()    driver.get(&quot;http://www.baidu.com&quot;)    element = WebDriverWait(driver, 5, 0.5).until(        expected_conditions.visibility_of_element_located((By.ID, &quot;kw&quot;))    )    element.send_keys(&#39;selenium&#39;)    driver.implicitly_wait(10) #隐式等待    driver.quit()</code></pre>]]></content>
      
      
      <categories>
          
          <category> selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium时间等待 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium定位方式</title>
      <link href="/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="项目能正常开展自动化测试的条件"><a href="#项目能正常开展自动化测试的条件" class="headerlink" title="项目能正常开展自动化测试的条件"></a>项目能正常开展自动化测试的条件</h4><pre><code>1.软件需求变动不频繁2.项目周期长3.自动化测试脚本可重复使用</code></pre><h4 id="css定位简单语法"><a href="#css定位简单语法" class="headerlink" title="css定位简单语法"></a>css定位简单语法</h4><p><img src="/.com//css%E9%80%89%E6%8B%A9%E5%99%A8.jpg" alt="css选择器的常用语法"></p><h4 id="常用的定位方式举例"><a href="#常用的定位方式举例" class="headerlink" title="常用的定位方式举例"></a>常用的定位方式举例</h4><pre><code class="python">import osimport time#导入selenium下面的webdriver模块from selenium import webdriverdef test_click():    try:        os.system(&quot;taskkill /f /im chromedriver.exe /t&quot;)    except:        pass    #调用webdriver模块下的Chrome()类    driver = webdriver.Chrome()    # 通过driver变量，调用Chrome()类提供的get()方法访问百度首页    # driver.maximize_window()    driver.get(&quot;https://www.baidu.com&quot;)    # driver.implicitly_wait(10)    time.sleep(4)    # driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;Selenium&quot;)    # driver.find_element_by_class_name(&#39;s_ipt&#39;).send_keys(&quot;测试开发&quot;)    # driver.find_element_by_tag_name(&#39;input&#39;).send_keys(&#39;mysql&#39;) #定位不到    # driver.find_element_by_link_text(&#39;贴吧&#39;).click()    # driver.find_element_by_partial_link_text(&#39;携手并进&#39;).click()    # xpath定位：利用元素属性定位    # driver.find_element_by_xpath(&#39;//*[@id=&quot;kw&quot;]&#39;).send_keys(&#39;hahah&#39;)    # driver.find_element_by_xpath(&quot;//*[@class=&#39;s_ipt&#39;]&quot;)    # 使用XPath 不局限于id、name和class 这三个属性值，元素的任意属性都可以使用，只要它能唯一标识一个元素    # driver.find_element_by_xpath(&quot;//input[@maxlength=&#39;100&#39;]&quot;).send_keys(&#39;aaa&#39;) #不能成功，数字不唯一    # driver.find_element_by_xpath(&quot;//input[@autocomplete=&#39;off&#39;]&quot;).send_keys(&#39;bbb&#39;) #可以成功    # driver.find_element_by_xpath(&quot;//input[@type=&#39;text&#39;]&quot;).send_keys(&#39;ccc&#39;)# 不能成功,type不唯一    #层级和属性定位    # driver.find_element_by_xpath(&quot;//form//span[@class=&#39;bg s_ipt_wr new-pmd quickdelete-wrap&#39;]/input[1]&quot;).send_keys(&quot;工程局&quot;)#定位失败    # driver.find_element_by_xpath(&quot;//span[@id=&#39;s_kw_wrap&#39;]/input[@name=&#39;wd&#39;]&quot;).send_keys(&quot;疫情最新&quot;) 定位失败，执行失败    # driver.find_element_by_xpath(&quot;//form[@id=&#39;form&#39;]/span[1]/input[1]&quot;).send_keys(&quot;form&quot;) 成功定位    #使用逻辑运算符定位    # driver.find_element_by_xpath(&quot;//input[@id=&#39;kw&#39; and @name=&#39;wd&#39;]&quot;).send_keys(&quot;逻辑运算&quot;) #成功定位    #使用contains方法定位    # driver.find_element_by_xpath(&quot;//form[contains(@id,&#39;form&#39;)]/span[1]/input&quot;).send_keys(&quot;contains&quot;) #定位成功    #使用text方法定位‘贴吧’    # driver.find_element_by_xpath(&quot;//a[contains(text(),&#39;贴吧&#39;)]&quot;).click() #定位成功    #使用css定位    #css是一种语言，用来描述html和xml文档的表现，css使用选择器为页面元素绑定属性，一般情况下，css定位速度比xpath定位速度快    #通过class定位    # driver.find_element_by_css_selector(&#39;.s_ipt&#39;).send_keys(&quot;css_selector&quot;) #成功定位    # 层级关系定位：    # driver.find_element_by_css_selector(&#39;form#form&gt;span&gt;input&#39;).send_keys(&quot;form&quot;) 成功定位    #通过id定位    # driver.find_element_by_css_selector(&#39;#kw&#39;).send_keys(&quot;立冬&quot;) #定位成功    #通过属性定位    # driver.find_element_by_css_selector(&#39;[autocomplete=off]&#39;).send_keys(&quot;隆冬&quot;) #定位成功    # driver.find_element_by_css_selector(&quot;[name=&#39;wd&#39;]&quot;).send_keys(&quot;小寒&quot;) #定位成功    # driver.find_element_by_css_selector(&quot;[type=&#39;text&#39;]&quot;).send_keys(&quot;hhh&quot;)#元素不唯一，失败，属性值可以选择加引号    #组合定位    # driver.find_element_by_css_selector(&quot;form#form &gt; span &gt;input.s_ipt&quot;).send_keys(&quot;组合定位&quot;) #定位成功    # driver.find_element_by_css_selector(&#39;form.fm &gt; span &gt;input.s_ipt&#39;).send_keys(&quot;class&quot;) # 定位成功    # driver.find_element_by_css_selector(&#39;form#form&gt; span &gt;input#kw&#39;).send_keys(&#39;dcc&#39;) #定位成功    #更多定位方法    #查找class 属性包含“s_ipt_wr”字符串的元素    # driver.find_element_by_css_selector(&quot;[class*=s_ipt]&quot;).send_keys(&#39;haaa&#39;)  #定位失败    # driver.find_element_by_css_selector(&quot;form &gt; input:nth-child(2)&quot;) #查找 form标签下面第2个input标签的元素    time.sleep(2)    # driver.find_element_by_id(&quot;su&quot;).click()    # driver.find_element_by_css_selector(&#39;#s-top-left &gt; a:nth-child(1)&#39;).click()  #定位百度首页新闻超链接，定位成功    driver.find_element_by_xpath(&quot;//input[@type=&#39;submit&#39;]&quot;).click()    # driver.find_element_by_css_selector(&quot;input[class~=&#39;btn&#39;]&quot;).click() #字符开头(&quot;input[class^=&#39;btn&#39;]&quot;)#字符结尾(&quot;input[class$=&#39;s_btn&#39;]&quot;) 定位失败    # driver.find_element_by_css_selector(&#39;.btn.self-btn.bg.s_btn&#39;).click()    time.sleep(2)    driver.close()    driver.quit()    # try:    #    #     os.system(&quot;taskkill /f /im chromedriver.exe /t&quot;)    # except:    #     pass</code></pre><h4 id="控制浏览器"><a href="#控制浏览器" class="headerlink" title="控制浏览器"></a>控制浏览器</h4><pre><code class="python">import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Bydef test_con():    driver = webdriver.Chrome()    driver.get(&quot;http://m.baidu.com&quot;)    #参数数字为像素    print(&quot;设置浏览器宽480、高800 显示&quot;)    driver.set_window_size(480, 800)    time.sleep(2)    driver.quit()def test_forward():    driver = webdriver.Chrome()    #访问百度首页    url = &quot;http://m.baidu.com&quot;    print(&quot;now access %s&quot;%(url))    driver.get(url)    #访问新闻页    url2=&#39;http://news.baidu.com&#39;    print(&quot;now access %s&quot; %(url2))    driver.get(url2)    time.sleep(2)    # 返回（后退）到百度首页    print(&quot;back to %s &quot; %(url))    driver.back()    time.sleep(2)    # 前进到新闻页    print(&quot;forward to %s&quot; %(url2))    driver.forward()    driver.quit()def test_common():    driver = webdriver.Chrome()    driver.get(&quot;https://www.baidu.com&quot;)    driver.refresh() #刷新浏览器    time.sleep(2)    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;cclean&quot;)    time.sleep(1)    driver.find_element_by_id(&quot;kw&quot;).clear() #先清理“cclean”    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)    driver.find_element_by_id(&quot;su&quot;).click()    driver.quit()#submit()：提交表单#有些搜索框不提供搜索按钮，而是通过按键盘上的回车键完成搜索内容的提交，这时可以通过submit()模拟def test_submit():    driver = webdriver.Chrome()    driver.get(&quot;https://www.baidu.com&quot;)    time.sleep(2)    search_text = driver.find_element_by_id(&#39;kw&#39;)    search_text.send_keys(&#39;selenium&#39;)    search_text.submit()    time.sleep(3)    driver.quit()#size：返回元素的尺寸。text：获取元素的文本。get_attribute(name)：获得属性值。is_displayed()：设置该元素是否用户可见def test_ele():    driver = webdriver.Chrome()    driver.get(&quot;https://www.baidu.com&quot;)    time.sleep(2)    size = driver.find_element(By.ID,&#39;kw&#39;).size    print(size)    # 返回文本信息    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;哈哈哈哈啊啊&quot;)    text = driver.find_element_by_id(&quot;kw&quot;).text    print(text)    # 返回元素的属性值，可以是id、name、type 或其他任意属性    attribute = driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)    print(attribute)    # 返回元素的结果是否可见，返回结果为True 或False    result = driver.find_element_by_id(&quot;kw&quot;).is_displayed()    print(result)    driver.quit()#鼠标操作，在WebDriver中，与鼠标操作相关的方法都封装在ActionChains 类中。ActionChains 类提供了鼠标操作的常用方法：#perform()：执行ActionChains 类中存储的所有行为。# context_click()：右击。# double_click()：双击。# drag_and_drop()：拖动。# move_to_element()：鼠标悬停def test_chain():    driver = webdriver.Chrome()    driver.get(&quot;https://www.baidu.cn&quot;)    time.sleep(5)    # 定位到要悬停的元素    above = driver.find_element_by_link_text(&quot;设置&quot;)    time.sleep(2)    # 对定位到的元素执行鼠标悬停操作    #调用 ActionChains 类，把浏览器驱动driver 作为参数传入。    #move_to_element()方法用于模拟鼠标移动到元素上，在调用时需要指定元素    #提交所有ActionChains 类中存储的行为    ActionChains(driver).move_to_element(above).perform()</code></pre>]]></content>
      
      
      <categories>
          
          <category> selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium定位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql8用户权限</title>
      <link href="/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/"/>
      <url>/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h4 id="mysql-的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权"><a href="#mysql-的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权" class="headerlink" title="mysql 的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权"></a>mysql 的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权</h4><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test1‘@’ip’;<br>create user ‘test1‘@’172.172.30.53’ identified by ‘Aa123456@@’;<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test2‘@’主机名’; （host要是mysql30-53）[update user set host=’%’ where user=’test2’;]<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test3‘@’localhost’;<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test4‘@’127.0.0.1’;<br>查看用户权限：show grants for myuser;     (show grants for root@’localhost’)<br>查看所有用户：select user,host from mysql.user;<br>查看单个用户的所有情况：select * from mysql.user where user=’myuser’\G</p><h4 id="授予用户权限和收回权限"><a href="#授予用户权限和收回权限" class="headerlink" title="授予用户权限和收回权限"></a>授予用户权限和收回权限</h4><p>创建用户：<br>create user ‘testss‘@’172.172.30.%’ identified by ‘Aa123456##’;<br>更新用户访问ip:<br>update user set host=’172.172.30.%’, where user=’testcc’;<br>授予用户远程访问的权限：<br>GRANT create,select, INSERT,UPDATE,DELETE,DROP,CREATE,RELOAD, PROCESS, REPLICATION CLIENT,BACKUP_ADMIN,REPLICATION_APPLIER,SESSION_VARIABLES_ADMIN ON <em>.</em> TO ‘testss‘@’172.172.30.%’  WITH GRANT OPTION;<br>grant insert ON <em>.</em> TO ‘testcc‘@’172.172.30.%’  WITH GRANT OPTION;<br>回收权限：revoke select on <em>.</em> from ‘data‘@’172.172.30.%’;</p><h4 id="查看mysql日志命令"><a href="#查看mysql日志命令" class="headerlink" title="查看mysql日志命令"></a>查看mysql日志命令</h4><p>获取binlog文件列表:<br>mysql&gt; show binary logs;<br>生成一个新的binlog日志：<br>mysql&gt; flush logs;<br>查看当前正在写入的binlog文件<br>mysql&gt; show master status\G<br>查看指定binlog文件的内容<br>mysql&gt; show binlog events in ‘mysql-bin.000002’<br>查看mysql的binlog日志是否开启：<br>show variables like ‘log_bin’;</p><h4 id="Mysql创建自动插入数据的存储过程"><a href="#Mysql创建自动插入数据的存储过程" class="headerlink" title="Mysql创建自动插入数据的存储过程"></a>Mysql创建自动插入数据的存储过程</h4><p>create table test(datetime datetime);<br>CREATE PROCEDURE user()<br>insert into test values(now());<br>CREATE EVENT IF NOT EXISTS eventJob<br>ON SCHEDULE EVERY 1 SECOND<br>ON COMPLETION PRESERVE<br>DO CALL user();<br>alter event eventJob on completion preserve enable;<br>SET GLOBAL event_scheduler = 1;</p><p>关闭定时器：<br>alter event eventJob  on completion preserve disable;<br>SET GLOBAL event_scheduler = 0；</p><h4 id="mysql插入当前时间"><a href="#mysql插入当前时间" class="headerlink" title="mysql插入当前时间"></a>mysql插入当前时间</h4><p>create table test(name varchar(255));<br>insert into test values (now());</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读写Excel文件-2</title>
      <link href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/"/>
      <url>/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/</url>
      
        <content type="html"><![CDATA[<h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p><p>本章我们继续讲解基于另一个三方库<code>openpyxl</code>如何进行Excel文件操作，首先需要先安装它。</p><pre><code class="Bash">pip install openpyxl</code></pre><p><code>openpyxl</code>的优点在于，当我们打开一个Excel文件后，既可以对它进行读操作，又可以对它进行写操作，而且在操作的便捷性上是优于<code>xlwt</code>和<code>xlrd</code>的。此外，如果要进行样式编辑和公式计算，使用<code>openpyxl</code>也远比上一个章节我们讲解的方式更为简单，而且<code>openpyxl</code>还支持数据透视和插入图表等操作，功能非常强大。有一点需要再次强调，<code>openpyxl</code>并不支持操作Office 2007以前版本的Excel文件。</p><h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xlsx”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p><pre><code class="Python">import datetimeimport openpyxl# 加载一个工作簿 ---&gt; Workbookwb = openpyxl.load_workbook(&#39;阿里巴巴2020年股票数据.xlsx&#39;)# 获取工作表的名字print(wb.sheetnames)# 获取工作表 ---&gt; Worksheetsheet = wb.worksheets[0]# 获得单元格的范围print(sheet.dimensions)# 获得行数和列数print(sheet.max_row, sheet.max_column)# 获取指定单元格的值print(sheet.cell(3, 3).value)print(sheet[&#39;C3&#39;].value)print(sheet[&#39;G255&#39;].value)# 获取多个单元格（嵌套元组）print(sheet[&#39;A2:C5&#39;])# 读取所有单元格的数据for row_ch in range(2, sheet.max_row + 1):    for col_ch in &#39;ABCDEFG&#39;:        value = sheet[f&#39;&#123;col_ch&#125;&#123;row_ch&#125;&#39;].value        if type(value) == datetime.datetime:            print(value.strftime(&#39;%Y年%m月%d日&#39;), end=&#39;\t&#39;)        elif type(value) == int:            print(f&#39;&#123;value:&lt;10d&#125;&#39;, end=&#39;\t&#39;)        elif type(value) == float:            print(f&#39;&#123;value:.4f&#125;&#39;, end=&#39;\t&#39;)        else:            print(value, end=&#39;\t&#39;)    print()</code></pre><blockquote><p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xlsx”可以通过后面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><p>需要提醒大家一点，<code>openpyxl</code>获取指定的单元格有两种方式，一种是通过<code>cell</code>方法，需要注意，该方法的行索引和列索引都是从<code>1</code>开始的，这是为了照顾用惯了Excel的人的习惯；另一种是通过索引运算，通过指定单元格的坐标，例如<code>C3</code>、<code>G255</code>，也可以取得对应的单元格，再通过单元格对象的<code>value</code>属性，就可以获取到单元格的值。通过上面的代码，相信大家还注意到了，可以通过类似<code>sheet[&#39;A2:C5&#39;]</code>或<code>sheet[&#39;A2&#39;:&#39;C5&#39;]</code>这样的切片操作获取多个单元格，该操作将返回嵌套的元组，相当于获取到了多行多列。</p><h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>下面我们使用<code>openpyxl</code>来进行写Excel操作。</p><pre><code class="Python">import randomimport openpyxl# 第一步：创建工作簿（Workbook）wb = openpyxl.Workbook()# 第二步：添加工作表（Worksheet）sheet = wb.activesheet.title = &#39;期末成绩&#39;titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)for col_index, title in enumerate(titles):    sheet.cell(1, col_index + 1, title)names = (&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;)for row_index, name in enumerate(names):    sheet.cell(row_index + 2, 1, name)    for col_index in range(2, 5):        sheet.cell(row_index + 2, col_index, random.randrange(50, 101))# 第四步：保存工作簿wb.save(&#39;考试成绩表.xlsx&#39;)</code></pre><h4 id="调整样式和公式计算"><a href="#调整样式和公式计算" class="headerlink" title="调整样式和公式计算"></a>调整样式和公式计算</h4><p>在使用<code>openpyxl</code>操作Excel时，如果要调整单元格的样式，可以直接通过单元格对象（<code>Cell</code>对象）的属性进行操作。单元格对象的属性包括字体（<code>font</code>）、对齐（<code>alignment</code>）、边框（<code>border</code>）等，具体的可以参考<code>openpyxl</code>的<a href="https://openpyxl.readthedocs.io/en/stable/index.html">官方文档</a>。在使用<code>openpyxl</code>时，如果需要做公式计算，可以完全按照Excel中的操作方式来进行，具体的代码如下所示。</p><pre><code class="Python">import openpyxlfrom openpyxl.styles import Font, Alignment, Border, Side# 对齐方式alignment = Alignment(horizontal=&#39;center&#39;, vertical=&#39;center&#39;)# 边框线条side = Side(color=&#39;ff7f50&#39;, style=&#39;mediumDashed&#39;)wb = openpyxl.load_workbook(&#39;考试成绩表.xlsx&#39;)sheet = wb.worksheets[0]# 调整行高和列宽sheet.row_dimensions[1].height = 30sheet.column_dimensions[&#39;E&#39;].width = 120sheet[&#39;E1&#39;] = &#39;平均分&#39;# 设置字体sheet.cell(1, 5).font = Font(size=18, bold=True, color=&#39;ff1493&#39;, name=&#39;华文楷体&#39;)# 设置对齐方式sheet.cell(1, 5).alignment = alignment# 设置单元格边框sheet.cell(1, 5).border = Border(left=side, top=side, right=side, bottom=side)for i in range(2, 7):    # 公式计算每个学生的平均分    sheet[f&#39;E&#123;i&#125;&#39;] = f&#39;=average(B&#123;i&#125;:D&#123;i&#125;)&#39;    sheet.cell(i, 5).font = Font(size=12, color=&#39;4169e1&#39;, italic=True)    sheet.cell(i, 5).alignment = alignmentwb.save(&#39;考试成绩表.xlsx&#39;)</code></pre><h3 id="生成统计图表"><a href="#生成统计图表" class="headerlink" title="生成统计图表"></a>生成统计图表</h3><p>通过<code>openpyxl</code>库，可以直接向Excel中插入统计图表，具体的做法跟在Excel中插入图表大体一致。我们可以创建指定类型的图表对象，然后通过该对象的属性对图表进行设置。当然，最为重要的是为图表绑定数据，即横轴代表什么，纵轴代表什么，具体的数值是多少。最后，可以将图表对象添加到表单中，具体的代码如下所示。</p><pre><code class="Python">from openpyxl import Workbookfrom openpyxl.chart import BarChart, Referencewb = Workbook(write_only=True)sheet = wb.create_sheet()rows = [    (&#39;类别&#39;, &#39;销售A组&#39;, &#39;销售B组&#39;),    (&#39;手机&#39;, 40, 30),    (&#39;平板&#39;, 50, 60),    (&#39;笔记本&#39;, 80, 70),    (&#39;外围设备&#39;, 20, 10),]# 向表单中添加行for row in rows:    sheet.append(row)# 创建图表对象chart = BarChart()chart.type = &#39;col&#39;chart.style = 10# 设置图表的标题chart.title = &#39;销售统计图&#39;# 设置图表纵轴的标题chart.y_axis.title = &#39;销量&#39;# 设置图表横轴的标题chart.x_axis.title = &#39;商品类别&#39;# 设置数据的范围data = Reference(sheet, min_col=2, min_row=1, max_row=5, max_col=3)# 设置分类的范围cats = Reference(sheet, min_col=1, min_row=2, max_row=5)# 给图表添加数据chart.add_data(data, titles_from_data=True)# 给图表设置分类chart.set_categories(cats)chart.shape = 4# 将图表添加到表单指定的单元格中sheet.add_chart(chart, &#39;A10&#39;)wb.save(&#39;demo.xlsx&#39;)</code></pre><p>运行上面的代码，打开生成的Excel文件，效果如下图所示。</p><img src="https://github.com/jackfrued/mypic/raw/master/20210819235009.png" alt="image-20210819235009026" width="75%"><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。如果数据体量较大或者处理数据的方式比较复杂，我们还是推荐大家使用Python数据分析神器之一的<code>pandas</code>库。</p>]]></content>
      
      
      <categories>
          
          <category> 处理Excel文件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读写Excel文件-1</title>
      <link href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-1/"/>
      <url>/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-1/</url>
      
        <content type="html"><![CDATA[<h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p><p>Python操作Excel需要三方库的支持，如果要兼容Excel 2007以前的版本，也就是<code>xls</code>格式的Excel文件，可以使用三方库<code>xlrd</code>和<code>xlwt</code>，前者用于读Excel文件，后者用于写Excel文件。如果使用较新版本的Excel，即操作<code>xlsx</code>格式的Excel文件，可以使用<code>openpyxl</code>库，当然这个库不仅仅可以操作Excel，还可以操作其他基于Office Open XML的电子表格文件。</p><p>本章我们先讲解基于<code>xlwt</code>和<code>xlrd</code>操作Excel文件，大家可以先使用下面的命令安装这两个三方库以及配合使用的工具模块<code>xlutils</code>。</p><pre><code class="Bash">pip install xlwt xlrd xlutils</code></pre><h3 id="读Excel文件"><a href="#读Excel文件" class="headerlink" title="读Excel文件"></a>读Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xls”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p><pre><code class="Python">import xlrd# 使用xlrd模块的open_workbook函数打开指定Excel文件并获得Book对象（工作簿）wb = xlrd.open_workbook(&#39;阿里巴巴2020年股票数据.xls&#39;)# 通过Book对象的sheet_names方法可以获取所有表单名称sheetnames = wb.sheet_names()print(sheetnames)# 通过指定的表单名称获取Sheet对象（工作表）sheet = wb.sheet_by_name(sheetnames[0])# 通过Sheet对象的nrows和ncols属性获取表单的行数和列数print(sheet.nrows, sheet.ncols)for row in range(sheet.nrows):    for col in range(sheet.ncols):        # 通过Sheet对象的cell方法获取指定Cell对象（单元格）        # 通过Cell对象的value属性获取单元格中的值        value = sheet.cell(row, col).value        # 对除首行外的其他行进行数据格式化处理        if row &gt; 0:            # 第1列的xldate类型先转成元组再格式化为“年月日”的格式            if col == 0:                # xldate_as_tuple函数的第二个参数只有0和1两个取值                # 其中0代表以1900-01-01为基准的日期，1代表以1904-01-01为基准的日期                value = xlrd.xldate_as_tuple(value, 0)                value = f&#39;&#123;value[0]&#125;年&#123;value[1]:&gt;02d&#125;月&#123;value[2]:&gt;02d&#125;日&#39;            # 其他列的number类型处理成小数点后保留两位有效数字的浮点数            else:                value = f&#39;&#123;value:.2f&#125;&#39;        print(value, end=&#39;\t&#39;)    print()# 获取最后一个单元格的数据类型# 0 - 空值，1 - 字符串，2 - 数字，3 - 日期，4 - 布尔，5 - 错误last_cell_type = sheet.cell_type(sheet.nrows - 1, sheet.ncols - 1)print(last_cell_type)# 获取第一行的值（列表）print(sheet.row_values(0))# 获取指定行指定列范围的数据（列表）# 第一个参数代表行索引，第二个和第三个参数代表列的开始（含）和结束（不含）索引print(sheet.row_slice(3, 0, 5))</code></pre><blockquote><p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xls”可以通过后面的百度云盘地址进行获取。链接:<a href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p></blockquote><p>相信通过上面的代码，大家已经了解到了如何读取一个Excel文件，如果想知道更多关于<code>xlrd</code>模块的知识，可以阅读它的<a href="https://xlrd.readthedocs.io/en/latest/">官方文档</a>。</p><h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>写入Excel文件可以通过<code>xlwt</code> 模块的<code>Workbook</code>类创建工作簿对象，通过工作簿对象的<code>add_sheet</code>方法可以添加工作表，通过工作表对象的<code>write</code>方法可以向指定单元格中写入数据，最后通过工作簿对象的<code>save</code>方法将工作簿写入到指定的文件或内存中。下面的代码实现了将<code>5</code>个学生<code>3</code>门课程的考试成绩写入Excel文件的操作。</p><pre><code class="Python">import randomimport xlwtstudent_names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]scores = [[random.randrange(50, 101) for _ in range(3)] for _ in range(5)]# 创建工作簿对象（Workbook）wb = xlwt.Workbook()# 创建工作表对象（Worksheet）sheet = wb.add_sheet(&#39;一年级二班&#39;)# 添加表头数据titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)for index, title in enumerate(titles):    sheet.write(0, index, title)# 将学生姓名和考试成绩写入单元格for row in range(len(scores)):    sheet.write(row + 1, 0, student_names[row])    for col in range(len(scores[row])):        sheet.write(row + 1, col + 1, scores[row][col])# 保存Excel工作簿wb.save(&#39;考试成绩表.xls&#39;)</code></pre><h4 id="调整单元格样式"><a href="#调整单元格样式" class="headerlink" title="调整单元格样式"></a>调整单元格样式</h4><p>在写Excel文件时，我们还可以为单元格设置样式，主要包括字体（Font）、对齐方式（Alignment）、边框（Border）和背景（Background）的设置，<code>xlwt</code>对这几项设置都封装了对应的类来支持。要设置单元格样式需要首先创建一个<code>XFStyle</code>对象，再通过该对象的属性对字体、对齐方式、边框等进行设定，例如在上面的例子中，如果希望将表头单元格的背景色修改为黄色，可以按照如下的方式进行操作。</p><pre><code class="Python">header_style = xlwt.XFStyle()pattern = xlwt.Pattern()pattern.pattern = xlwt.Pattern.SOLID_PATTERN# 0 - 黑色、1 - 白色、2 - 红色、3 - 绿色、4 - 蓝色、5 - 黄色、6 - 粉色、7 - 青色pattern.pattern_fore_colour = 5header_style.pattern = patterntitles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)for index, title in enumerate(titles):    sheet.write(0, index, title, header_style)</code></pre><p>如果希望为表头设置指定的字体，可以使用<code>Font</code>类并添加如下所示的代码。</p><pre><code class="Python">font = xlwt.Font()# 字体名称font.name = &#39;华文楷体&#39;# 字体大小（20是基准单位，18表示18px）font.height = 20 * 18# 是否使用粗体font.bold = True# 是否使用斜体font.italic = False# 字体颜色font.colour_index = 1header_style.font = font</code></pre><blockquote><p><strong>注意</strong>：上面代码中指定的字体名（<code>font.name</code>）应当是本地系统有的字体，例如在我的电脑上有名为“华文楷体”的字体。</p></blockquote><p>如果希望表头垂直居中对齐，可以使用下面的代码进行设置。</p><pre><code class="Python">align = xlwt.Alignment()# 垂直方向的对齐方式align.vert = xlwt.Alignment.VERT_CENTER# 水平方向的对齐方式align.horz = xlwt.Alignment.HORZ_CENTERheader_style.alignment = align</code></pre><p>如果希望给表头加上黄色的虚线边框，可以使用下面的代码来设置。</p><pre><code class="Python">borders = xlwt.Borders()props = (    (&#39;top&#39;, &#39;top_colour&#39;), (&#39;right&#39;, &#39;right_colour&#39;),    (&#39;bottom&#39;, &#39;bottom_colour&#39;), (&#39;left&#39;, &#39;left_colour&#39;))# 通过循环对四个方向的边框样式及颜色进行设定for position, color in props:    # 使用setattr内置函数动态给对象指定的属性赋值    setattr(borders, position, xlwt.Borders.DASHED)    setattr(borders, color, 5)header_style.borders = borders</code></pre><p>如果要调整单元格的宽度（列宽）和表头的高度（行高），可以按照下面的代码进行操作。</p><pre><code class="Python"># 设置行高为40pxsheet.row(0).set_style(xlwt.easyxf(f&#39;font:height &#123;20 * 40&#125;&#39;))titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)for index, title in enumerate(titles):    # 设置列宽为200px    sheet.col(index).width = 20 * 200    # 设置单元格的数据和样式    sheet.write(0, index, title, header_style)</code></pre><h4 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h4><p>对于前面打开的“阿里巴巴2020年股票数据.xls”文件，如果要统计全年收盘价（Close字段）的平均值以及全年交易量（Volume字段）的总和，可以使用Excel的公式计算即可。我们可以先使用<code>xlrd</code>读取Excel文件夹，然后通过<code>xlutils</code>三方库提供的<code>copy</code>函数将读取到的Excel文件转成<code>Workbook</code>对象进行写操作，在调用<code>write</code>方法时，可以将一个<code>Formula</code>对象写入单元格。</p><p>实现公式计算的代码如下所示。</p><pre><code class="Python">import xlrdimport xlwtfrom xlutils.copy import copywb_for_read = xlrd.open_workbook(&#39;阿里巴巴2020年股票数据.xls&#39;)sheet1 = wb_for_read.sheet_by_index(0)nrows, ncols = sheet1.nrows, sheet1.ncolswb_for_write = copy(wb_for_read)sheet2 = wb_for_write.get_sheet(0)sheet2.write(nrows, 4, xlwt.Formula(f&#39;average(E2:E&#123;nrows&#125;)&#39;))sheet2.write(nrows, 6, xlwt.Formula(f&#39;sum(G2:G&#123;nrows&#125;)&#39;))wb_for_write.save(&#39;阿里巴巴2020年股票数据汇总.xls&#39;)</code></pre><blockquote><p><strong>说明</strong>：上面的代码有一些小瑕疵，有兴趣的读者可以自行探索并思考如何解决。</p></blockquote><h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。当然，如果要对表格数据进行处理，使用Python数据分析神器之一的<code>pandas</code>库可能更为方便。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python处理csv文件</title>
      <link href="/2022/11/07/python%E5%A4%84%E7%90%86csv%E6%96%87%E4%BB%B6/"/>
      <url>/2022/11/07/python%E5%A4%84%E7%90%86csv%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CSV文件介绍"><a href="#1-CSV文件介绍" class="headerlink" title="1.CSV文件介绍"></a>1.CSV文件介绍</h3><p>CSV（Comma Separated Values）全称逗号分隔值文件是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，而且很多编程语言中都提供了对读写CSV文件的支持，因此CSV格式在数据处理和数据科学中被广泛应用。</p><p>CSV文件有以下特点：</p><ol><li>纯文本，使用某种字符集（如<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a>、<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>、<a href="https://zh.wikipedia.org/wiki/GB2312">GB2312</a>）等）；</li><li>由一条条的记录组成（典型的是每行一条记录）；</li><li>每条记录被分隔符（如逗号、分号、制表符等）分隔为字段（列）；</li><li>每条记录都有同样的字段序列。</li></ol><p>CSV文件可以使用文本编辑器或类似于Excel电子表格这类工具打开和编辑，当使用Excel这类电子表格打开CSV文件时，你甚至感觉不到CSV和Excel文件的区别。很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，这些内容并不是现在要讨论的重点。</p><h3 id="2-将数据写入CSV文件"><a href="#2-将数据写入CSV文件" class="headerlink" title="2.将数据写入CSV文件"></a>2.将数据写入CSV文件</h3><p>现有五个学生三门课程的考试成绩需要保存到一个CSV文件中，要达成这个目标，可以使用Python标准库中的<code>csv</code>模块，该模块的<code>writer</code>函数会返回一个<code>csvwriter</code>对象，通过该对象的<code>writerow</code>或<code>writerows</code>方法就可以将数据写入到CSV文件中，具体的代码如下所示。</p><pre><code class="Python">import csvimport randomwith open(&#39;scores.csv&#39;, &#39;w&#39;) as file:    writer = csv.writer(file)    writer.writerow([&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;])    names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]    for name in names:        scores = [random.randrange(50, 101) for _ in range(3)]        scores.insert(0, name)        writer.writerow(scores)</code></pre><p>生成的CSV文件的内容。</p><pre><code>姓名,语文,数学,英语关羽,98,86,61张飞,86,58,80赵云,95,73,70马超,83,97,55黄忠,61,54,87</code></pre><p>需要说明的是上面的<code>writer</code>函数，除了传入要写入数据的文件对象外，还可以<code>dialect</code>参数，它表示CSV文件的方言，默认值是<code>excel</code>。除此之外，还可以通过<code>delimiter</code>、<code>quotechar</code>、<code>quoting</code>参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。大家可以尝试将上面第5行代码修改为下面的代码，然后查看生成的CSV文件。</p><pre><code class="Python">writer = csv.writer(file, delimiter=&#39;|&#39;, quoting=csv.QUOTE_ALL)</code></pre><p>生成的CSV文件的内容。</p><pre><code>&quot;姓名&quot;|&quot;语文&quot;|&quot;数学&quot;|&quot;英语&quot;&quot;关羽&quot;|&quot;88&quot;|&quot;64&quot;|&quot;65&quot;&quot;张飞&quot;|&quot;76&quot;|&quot;93&quot;|&quot;79&quot;&quot;赵云&quot;|&quot;78&quot;|&quot;55&quot;|&quot;76&quot;&quot;马超&quot;|&quot;72&quot;|&quot;77&quot;|&quot;68&quot;&quot;黄忠&quot;|&quot;70&quot;|&quot;72&quot;|&quot;51&quot;</code></pre><h3 id="3-从CSV文件读取数据"><a href="#3-从CSV文件读取数据" class="headerlink" title="3.从CSV文件读取数据"></a>3.从CSV文件读取数据</h3><p>如果要读取刚才创建的CSV文件，可以使用下面的代码，通过<code>csv</code>模块的<code>reader</code>函数可以创建出<code>csvreader</code>对象，该对象是一个迭代器，可以通过<code>next</code>函数或<code>for-in</code>循环读取到文件中的数据。</p><pre><code class="Python">import csvwith open(&#39;scores.csv&#39;, &#39;r&#39;) as file:    reader = csv.reader(file, delimiter=&#39;|&#39;)    for data_list in reader:        print(reader.line_num, end=&#39;\t&#39;)        for elem in data_list:            print(elem, end=&#39;\t&#39;)        print()</code></pre><blockquote><p><strong>注意</strong>：上面的代码对<code>csvreader</code>对象做<code>for</code>循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。</p></blockquote><h3 id="4-简单的总结"><a href="#4-简单的总结" class="headerlink" title="4.简单的总结"></a>4.简单的总结</h3><p>将来如果大家使用Python做数据分析，很有可能会用到名为<code>pandas</code>的三方库，它是Python数据分析的神器之一。<code>pandas</code>中封装了名为<code>read_csv</code>和<code>to_csv</code>的函数用来读写CSV文件，其中<code>read_CSV</code>会将读取到的数据变成一个<code>DataFrame</code>对象，而<code>DataFrame</code>就是<code>pandas</code>库中最重要的类型，它封装了一系列用于数据处理的方法（清洗、转换、聚合等）；而<code>to_csv</code>会将<code>DataFrame</code>对象中的数据写入CSV文件，完成数据的持久化。<code>read_csv</code>函数和<code>to_csv</code>函数远远比原生的<code>csvreader</code>和<code>csvwriter</code>强大。</p>]]></content>
      
      
      <categories>
          
          <category> 处理Excel文件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读取excel内容</title>
      <link href="/2022/10/14/python%E8%AF%BB%E5%8F%96excle%E5%86%85%E5%AE%B9/"/>
      <url>/2022/10/14/python%E8%AF%BB%E5%8F%96excle%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="1-代码如下："><a href="#1-代码如下：" class="headerlink" title="1.代码如下："></a>1.代码如下：</h4><pre><code class="python">import xlrdimport xlsxwriter# 操作Excel的工具类class Excel():    # 初始化方法 参数type：为r是读取excel，为w是写入excel获取不同的实例，参数file_name是将要读取的文件    def __init__(self, type, file_name):        # 读取excel        if type == &#39;r&#39;:            # 打开文件            self.workbook = xlrd.open_workbook(file_name)            # 获取到所有的sheet_names,sheet1,sheet2获取到所有，获取到的是一个list            self.sheet_names = self.workbook.sheet_names()            # 装载所有数据的list            self.list_data = []        # 写入excel        elif type == &#39;w&#39;:            # 获得写入excel的实例            self.workbook = xlsxwriter.Workbook(file_name)    def read(self):        # 根据sheet_name去读取用例，并获取文件的总行数获取到每行的内容        for sheet_name in self.sheet_names:            # 通过每个sheetname获取到每个页的内容            sheet = self.workbook.sheet_by_name(sheet_name)            # 获取总行数            rosw = sheet.nrows            # 根据总行数进行读取            for i in range(0, rosw):                rowvalues = sheet.row_values(i)                # 将每一行的内容添加进去                self.list_data.append(rowvalues)            #     去除大标题第一行进行切割处理        # 将得到的excel数据返回进行处理        return self.list_data#将元素和链接表处理为json格式方便查询def element_tojson(element):    elements = &#123;&#125;    #将元素和接口信息组成key和value的形式方便查询    for e in element:        elements[e[0]] = &#123;&quot;type&quot;: e[1], &quot;url&quot;: e[2]&#125;    return elementsif __name__ == &#39;__main__&#39;:    file = &#39;../element/test1.xls&#39;    e = Excel(&#39;r&#39;, file)    list_read = e.read()    e = element_tojson(list_read)    print(e[&#39;获取短信验证码&#39;])    print(e)</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
