<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>月明星稀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="太阳当空照，花儿爱微笑">
<meta property="og:type" content="website">
<meta property="og:title" content="月明星稀">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="月明星稀">
<meta property="og:description" content="太阳当空照，花儿爱微笑">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="当时只道是寻常">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="月明星稀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">月明星稀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-selenium多窗口-警告框处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2022-11-11T03:19:14.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/selenium/">selenium</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/">selenium多窗口_警告框处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code class="python">#多窗口切换
# 在页面操作过程中，有时单击某个链接会弹出新的窗口，这时就需要切换到新打开的窗口中进行操作。WebDriver 提供的switch_to.window()方法可以实现在不同的窗口间切换。
# current_window_handle：获得当前窗口句柄。window_handles：返回所有窗口的句柄到当前会话。switch_to.window()：切换到相应的窗口。
def test_window():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    #获取百度搜索窗口句柄
    search_window = driver.current_window_handle
    driver.implicitly_wait(10)
    driver.find_element_by_id(&quot;s-top-loginbtn&quot;).click()
    driver.implicitly_wait(10)
    driver.find_element_by_id(&#39;TANGRAM__PSP_11__regLink&#39;).click()
    time.sleep(5)
    all_handles = driver.window_handles
    #进入注册窗口：暂时不适用，百度需要验证码才可以
    for handle in all_handles:
        if handle != search_window:
            driver.switch_to.window(handle)
            print(driver.title)
            driver.find_element_by_id(&#39;TANGRAM__PSP_11__userName&#39;).send_keys(&#39;1fafa720fa6&#39;)
            driver.find_element_by_id(&#39;TANGRAM__PSP_11__password&#39;).send_keys(&#39;1fa77242226&#39;)
            time.sleep(5)
            #关闭当前窗口
            driver.close()
        # 回到搜索窗口
        driver.switch_to.window(search_window)
        print(driver.title)
        driver.quit()

#警告框处理
# 在 WebDriver 中处理JavaScript 生成的alert、confirm 和prompt 十分简单，具体做法是，
# 首先使用switch_to.alert()方法定位，然后使用text、accept、dismiss、send_keys 等进行操作。
# text：返回alert、confirm、prompt 中的文字信息。
# accept()：接受现有警告框。
# dismiss()：解散现有警告框。
# send_keys()：在警告框中输入文本（如果可以输入的话）
#可以使用 switch_to.alert()方法为百度搜索设置弹窗
def test_alert():
    driver = webdriver.Chrome()
    driver.get(&#39;https://www.baidu.com&#39;)
    # 打开搜索设置
    # link = driver.find_element_by_link_text(&#39;设置&#39;).click()
    driver.find_element_by_id(&#39;s-usersetting-top&#39;).click()
    driver.find_element_by_link_text(&quot;搜索设置&quot;).click()
    sleep(2)
    # 保存设置
    driver.find_element_by_class_name(&quot;prefpanelgo&quot;).click()
    # 获取警告框
    alert = driver.switch_to.alert
    # 获取警告框提示信息
    alert_text = alert.text
    print(alert_text)
    time.sleep(3)
    # 接取警告框
    alert.accept()
    driver.quit()

# 下拉框处理
# WebDriver 提供了Select 类来处理下拉框。
# Select类：用于定位&lt;select&gt;标签。
# select_by_value()：通过value值定位下拉选项。
# select_by_visible_text()：通过text值定位下拉选项。
# select_by_index()：根据下拉选项的索引进行选择。第一个选项为0，第二个选项为1。
def test_select():
    driver = webdriver.Chrome()
    path = r&#39;D:\7z\py\html\select.html&#39;
    driver.get(path)
    # 通过显示等待的方法判断元素是否出现
    WebDriverWait(driver, 10).until(EC.visibility_of_element_located((By.NAME, &quot;anjing&quot;)))
    select = driver.find_element_by_name(&#39;anjing&#39;)
    # 根据下标进行选择，从0开始
    Select(select).select_by_index(1)
    time.sleep(2)
    # 根据value的值选择
    Select(select).select_by_value(&#39;daily&#39;)
    time.sleep(2)
    # 根基text选择
    Select(select).select_by_visible_text(&#39;关注了吗？&#39;)
    time.sleep(2)
    # 判断选择是否预期
    WebDriverWait(driver, 20).until(EC.element_located_to_be_selected((By.XPATH, &#39;//*[contains(text(),&quot;关注了&quot;)]&#39;)))
    driver.quit()

#上传文件
def test_upfile():
    file_path = os.path.abspath(r&#39;D:\7z\py\html&#39;)
    driver = webdriver.Chrome()
    upload_page = r&#39;D:\7z\py\html\select.html&#39;
    driver.get(upload_page)
    # 定位上传按钮，添加本地文件
    time.sleep(3)
    driver.find_element_by_id(&quot;inputfile&quot;).send_keys(file_path + &#39;/day02.html&#39;)

#操作cookie
# WebDriver 操作Cookie 的方法如下。
# get_cookies()：获得所有Cookie。
# get_cookie(name)：返回字典中key 为“name”的Cookie。
# add_cookie(cookie_dict)：添加 Cookie。
# delete_cookie(name,optionsString)：删除名为OpenString 的Cookie。
# delete_all_cookies()：删除所有Cookie。
def test_cookie():
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.baidu.com&quot;)
    # 获得所有Cookie 信息并打印
    cookie = driver.get_cookies()
    print(cookie)
    # 添加Cookie 信息
    driver.add_cookie(&#123;&#39;name&#39;: &#39;key-aaaaaaa&#39;, &#39;value&#39;: &#39;value-bbbbbb&#39;&#125;)
    # 遍历指定的Cookies
    for cookie in driver.get_cookies():
        print(&quot;%s -&gt; %s&quot; % (cookie[&#39;name&#39;], cookie[&#39;value&#39;]))

#调用javascript,实现浏览器滚动条的拖动效果
def test_move():
    from selenium import webdriver
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.baidu.com&quot;)
    #，通过set_window_size()方法将浏览器窗口设置为固定宽、高显示,目的是让窗口出现水平和垂直滚动条
    driver.set_window_size(800, 600)
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
    driver.find_element_by_id(&quot;su&quot;).click()
    # 通过JavaScript 设置浏览器窗口的滚动条位置
    js = &quot;window.scrollTo(100,450);&quot;
    driver.execute_script(js)
    time.sleep(4)
def test_picture():
    from selenium import webdriver
    driver = webdriver.Chrome()
    driver.get(&#39;http://www.baidu.com&#39;)
    # 截取当前窗口，指定截图图片的保存位置
</code></pre>
<h4 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h4><pre><code>&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;上传表单&lt;/title&gt;
#上传文件
&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;
rel=&quot;stylesheet&quot; &gt;
&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;jumbotron&quot;&gt;
&lt;form class=&quot;form-inline&quot; role=&quot;form&quot;&gt;
&lt;div class=&quot;form-group&quot;&gt;
&lt;label class=&quot;sr-only&quot; for=&quot;name&quot;&gt;名称&lt;/label&gt;
&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;
placeholder=&quot;请输入名称&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;form-group&quot;&gt;
&lt;label class=&quot;sr-only&quot; for=&quot;inputfile&quot;&gt;文件输入&lt;/label&gt;
&lt;input type=&quot;file&quot; id=&quot;inputfile&quot;&gt;
&lt;/div&gt;
&lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;

# select 选择
&lt;form&gt;
&lt;center&gt;
&lt;select name=&quot;anjing&quot;&gt;
&lt;option value=&quot;boke&quot;&gt;请关注今日天气&lt;/option&gt;
&lt;option value=&quot;study&quot;&gt;今天大雨&lt;/option&gt;
&lt;option value=&quot;daily&quot;&gt;写写什么&lt;/option&gt;
&lt;option value=&quot;like&quot;&gt;喜欢的食物&lt;/option&gt;
&lt;option value=&quot;attention&quot;&gt;关注点在哪里&lt;/option&gt;
&lt;/center&gt;
&lt;/select&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" data-id="cm7yic4k8001768vd6zhk9g5t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" rel="tag">selenium多窗口_警告框处理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selenium时间等待" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" class="article-date">
  <time datetime="2022-11-11T01:36:49.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/selenium/">selenium</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/">selenium时间等待</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="获得验证信息"><a href="#获得验证信息" class="headerlink" title="获得验证信息"></a>获得验证信息</h4><pre><code class="python">from time import sleep
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait


def test_title():
    #title：用于获取当前页面的标题
    #current_url：用于获取当前页面的URL
    #text：用于获取当前页面的文本信息
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    print(&#39;Before search================&#39;)
    # 打印当前页面title
    title = driver.title
    print(&quot;title:&quot; + title) #title:百度一下，你就知道
    # 打印当前页面URL
    now_url = driver.current_url
    print(&quot;URL:&quot; + now_url) # URL:https://www.baidu.com/
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
    driver.find_element_by_id(&quot;su&quot;).click()
    sleep(2)
    print(&#39;After search================&#39;)
    # 再次打印当前页面title
    title = driver.title
    print(&quot;title:&quot; + title) #selenium_百度搜索
    # 再次打印当前页面URL
    now_url = driver.current_url
    print(&quot;URL:&quot; + now_url)
    # 获取搜索结果条数
    # num = driver.find_element_by_class_name(&#39;nums&#39;).text
    num = driver.find_element_by_css_selector(&#39;.hint_PIwZX.c_font_2AD7M&#39;).text
    print(&quot;result:&quot; + num) #result:百度为您找到相关结果约100,000,000个
    driver.quit()
</code></pre>
<h4 id="显示等待和隐士等待"><a href="#显示等待和隐士等待" class="headerlink" title="显示等待和隐士等待"></a>显示等待和隐士等待</h4><p><img src="../images/%E9%A2%84%E6%9C%9F%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95.jpg" alt="预期判断方法"></p>
<pre><code class="python"># WebDriverWait 类是WebDriver 提供的等待方法。在设置时间内，默认每隔一段时间检
# 测一次当前页面元素是否存在，如果超过设置时间仍检测不到，则抛出异常。具体格式如下
# WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)
# driver：浏览器驱动。
# timeout：最长超时时间，默认以秒为单位。
# poll_frequency：检测的间隔（步长）时间，默认为0.5s。
# ignored_exceptions：超时后的异常信息，默认情况下抛出NoSuchElementException异常。
# WebDriverWait()一般与until()或until_not()方法配合使用，下面是until()和until_not()方法的说明。until(method, message=″)
# 调用该方法提供的驱动程序作为一个参数，直到返回值为True。until_not(method, message=″)调用该方法提供的驱动程序作为一个参数，直到返回值为False。
def test_time():
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.baidu.com&quot;)
    element = WebDriverWait(driver, 5, 0.5).until(
        expected_conditions.visibility_of_element_located((By.ID, &quot;kw&quot;))
    )
    element.send_keys(&#39;selenium&#39;)
    driver.implicitly_wait(10) #隐式等待
    driver.quit()
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" data-id="cm7yic4k9001d68vd80t08d5a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" rel="tag">selenium时间等待</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selenium定位方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2022-11-08T09:36:08.000Z" itemprop="datePublished">2022-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/selenium/">selenium</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/">selenium定位方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="项目能正常开展自动化测试的条件"><a href="#项目能正常开展自动化测试的条件" class="headerlink" title="项目能正常开展自动化测试的条件"></a>项目能正常开展自动化测试的条件</h4><pre><code>1.软件需求变动不频繁
2.项目周期长
3.自动化测试脚本可重复使用
</code></pre>
<h4 id="css定位简单语法"><a href="#css定位简单语法" class="headerlink" title="css定位简单语法"></a>css定位简单语法</h4><p><img src="/.com//css%E9%80%89%E6%8B%A9%E5%99%A8.jpg" alt="css选择器的常用语法"></p>
<h4 id="常用的定位方式举例"><a href="#常用的定位方式举例" class="headerlink" title="常用的定位方式举例"></a>常用的定位方式举例</h4><pre><code class="python">import os
import time
#导入selenium下面的webdriver模块
from selenium import webdriver
def test_click():
    try:
        os.system(&quot;taskkill /f /im chromedriver.exe /t&quot;)
    except:
        pass

    #调用webdriver模块下的Chrome()类
    driver = webdriver.Chrome()
    # 通过driver变量，调用Chrome()类提供的get()方法访问百度首页
    # driver.maximize_window()
    driver.get(&quot;https://www.baidu.com&quot;)
    # driver.implicitly_wait(10)
    time.sleep(4)
    # driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;Selenium&quot;)
    # driver.find_element_by_class_name(&#39;s_ipt&#39;).send_keys(&quot;测试开发&quot;)
    # driver.find_element_by_tag_name(&#39;input&#39;).send_keys(&#39;mysql&#39;) #定位不到
    # driver.find_element_by_link_text(&#39;贴吧&#39;).click()
    # driver.find_element_by_partial_link_text(&#39;携手并进&#39;).click()
    # xpath定位：利用元素属性定位
    # driver.find_element_by_xpath(&#39;//*[@id=&quot;kw&quot;]&#39;).send_keys(&#39;hahah&#39;)
    # driver.find_element_by_xpath(&quot;//*[@class=&#39;s_ipt&#39;]&quot;)
    # 使用XPath 不局限于id、name和class 这三个属性值，元素的任意属性都可以使用，只要它能唯一标识一个元素
    # driver.find_element_by_xpath(&quot;//input[@maxlength=&#39;100&#39;]&quot;).send_keys(&#39;aaa&#39;) #不能成功，数字不唯一
    # driver.find_element_by_xpath(&quot;//input[@autocomplete=&#39;off&#39;]&quot;).send_keys(&#39;bbb&#39;) #可以成功
    # driver.find_element_by_xpath(&quot;//input[@type=&#39;text&#39;]&quot;).send_keys(&#39;ccc&#39;)# 不能成功,type不唯一

    #层级和属性定位
    # driver.find_element_by_xpath(&quot;//form//span[@class=&#39;bg s_ipt_wr new-pmd quickdelete-wrap&#39;]/input[1]&quot;).send_keys(&quot;工程局&quot;)#定位失败
    # driver.find_element_by_xpath(&quot;//span[@id=&#39;s_kw_wrap&#39;]/input[@name=&#39;wd&#39;]&quot;).send_keys(&quot;疫情最新&quot;) 定位失败，执行失败
    # driver.find_element_by_xpath(&quot;//form[@id=&#39;form&#39;]/span[1]/input[1]&quot;).send_keys(&quot;form&quot;) 成功定位

    #使用逻辑运算符定位
    # driver.find_element_by_xpath(&quot;//input[@id=&#39;kw&#39; and @name=&#39;wd&#39;]&quot;).send_keys(&quot;逻辑运算&quot;) #成功定位

    #使用contains方法定位
    # driver.find_element_by_xpath(&quot;//form[contains(@id,&#39;form&#39;)]/span[1]/input&quot;).send_keys(&quot;contains&quot;) #定位成功

    #使用text方法定位‘贴吧’
    # driver.find_element_by_xpath(&quot;//a[contains(text(),&#39;贴吧&#39;)]&quot;).click() #定位成功

    #使用css定位
    #css是一种语言，用来描述html和xml文档的表现，css使用选择器为页面元素绑定属性，一般情况下，css定位速度比xpath定位速度快
    #通过class定位
    # driver.find_element_by_css_selector(&#39;.s_ipt&#39;).send_keys(&quot;css_selector&quot;) #成功定位
    # 层级关系定位：
    # driver.find_element_by_css_selector(&#39;form#form&gt;span&gt;input&#39;).send_keys(&quot;form&quot;) 成功定位
    #通过id定位
    # driver.find_element_by_css_selector(&#39;#kw&#39;).send_keys(&quot;立冬&quot;) #定位成功
    #通过属性定位
    # driver.find_element_by_css_selector(&#39;[autocomplete=off]&#39;).send_keys(&quot;隆冬&quot;) #定位成功
    # driver.find_element_by_css_selector(&quot;[name=&#39;wd&#39;]&quot;).send_keys(&quot;小寒&quot;) #定位成功
    # driver.find_element_by_css_selector(&quot;[type=&#39;text&#39;]&quot;).send_keys(&quot;hhh&quot;)#元素不唯一，失败，属性值可以选择加引号
    #组合定位
    # driver.find_element_by_css_selector(&quot;form#form &gt; span &gt;input.s_ipt&quot;).send_keys(&quot;组合定位&quot;) #定位成功
    # driver.find_element_by_css_selector(&#39;form.fm &gt; span &gt;input.s_ipt&#39;).send_keys(&quot;class&quot;) # 定位成功
    # driver.find_element_by_css_selector(&#39;form#form&gt; span &gt;input#kw&#39;).send_keys(&#39;dcc&#39;) #定位成功
    #更多定位方法
    #查找class 属性包含“s_ipt_wr”字符串的元素
    # driver.find_element_by_css_selector(&quot;[class*=s_ipt]&quot;).send_keys(&#39;haaa&#39;)  #定位失败
    # driver.find_element_by_css_selector(&quot;form &gt; input:nth-child(2)&quot;) #查找 form标签下面第2个input标签的元素
    time.sleep(2)

    # driver.find_element_by_id(&quot;su&quot;).click()
    # driver.find_element_by_css_selector(&#39;#s-top-left &gt; a:nth-child(1)&#39;).click()  #定位百度首页新闻超链接，定位成功
    driver.find_element_by_xpath(&quot;//input[@type=&#39;submit&#39;]&quot;).click()
    # driver.find_element_by_css_selector(&quot;input[class~=&#39;btn&#39;]&quot;).click() #字符开头(&quot;input[class^=&#39;btn&#39;]&quot;)#字符结尾(&quot;input[class$=&#39;s_btn&#39;]&quot;) 定位失败
    # driver.find_element_by_css_selector(&#39;.btn.self-btn.bg.s_btn&#39;).click()

    time.sleep(2)
    driver.close()

    driver.quit()
    # try:
    #
    #     os.system(&quot;taskkill /f /im chromedriver.exe /t&quot;)
    # except:
    #     pass
</code></pre>
<h4 id="控制浏览器"><a href="#控制浏览器" class="headerlink" title="控制浏览器"></a>控制浏览器</h4><pre><code class="python">import time

from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By


def test_con():
    driver = webdriver.Chrome()
    driver.get(&quot;http://m.baidu.com&quot;)
    #参数数字为像素
    print(&quot;设置浏览器宽480、高800 显示&quot;)
    driver.set_window_size(480, 800)
    time.sleep(2)
    driver.quit()
def test_forward():
    driver = webdriver.Chrome()
    #访问百度首页
    url = &quot;http://m.baidu.com&quot;
    print(&quot;now access %s&quot;%(url))
    driver.get(url)
    #访问新闻页
    url2=&#39;http://news.baidu.com&#39;
    print(&quot;now access %s&quot; %(url2))
    driver.get(url2)
    time.sleep(2)
    # 返回（后退）到百度首页
    print(&quot;back to %s &quot; %(url))
    driver.back()
    time.sleep(2)
    # 前进到新闻页
    print(&quot;forward to %s&quot; %(url2))
    driver.forward()
    driver.quit()
def test_common():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    driver.refresh() #刷新浏览器
    time.sleep(2)
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;cclean&quot;)
    time.sleep(1)
    driver.find_element_by_id(&quot;kw&quot;).clear() #先清理“cclean”
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
    driver.find_element_by_id(&quot;su&quot;).click()
    driver.quit()
#submit()：提交表单
#有些搜索框不提供搜索按钮，而是通过按键盘上的回车键完成搜索内容的提交，这时可以通过submit()模拟
def test_submit():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    time.sleep(2)
    search_text = driver.find_element_by_id(&#39;kw&#39;)
    search_text.send_keys(&#39;selenium&#39;)
    search_text.submit()
    time.sleep(3)
    driver.quit()
#size：返回元素的尺寸。text：获取元素的文本。get_attribute(name)：获得属性值。is_displayed()：设置该元素是否用户可见
def test_ele():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    time.sleep(2)
    size = driver.find_element(By.ID,&#39;kw&#39;).size
    print(size)
    # 返回文本信息
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;哈哈哈哈啊啊&quot;)
    text = driver.find_element_by_id(&quot;kw&quot;).text
    print(text)
    # 返回元素的属性值，可以是id、name、type 或其他任意属性
    attribute = driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)
    print(attribute)
    # 返回元素的结果是否可见，返回结果为True 或False
    result = driver.find_element_by_id(&quot;kw&quot;).is_displayed()
    print(result)
    driver.quit()
#鼠标操作，在WebDriver中，与鼠标操作相关的方法都封装在ActionChains 类中。ActionChains 类提供了鼠标操作的常用方法：
#perform()：执行ActionChains 类中存储的所有行为。
# context_click()：右击。
# double_click()：双击。
# drag_and_drop()：拖动。
# move_to_element()：鼠标悬停
def test_chain():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.cn&quot;)
    time.sleep(5)
    # 定位到要悬停的元素
    above = driver.find_element_by_link_text(&quot;设置&quot;)
    time.sleep(2)
    # 对定位到的元素执行鼠标悬停操作
    #调用 ActionChains 类，把浏览器驱动driver 作为参数传入。
    #move_to_element()方法用于模拟鼠标移动到元素上，在调用时需要指定元素
    #提交所有ActionChains 类中存储的行为
    ActionChains(driver).move_to_element(above).perform()
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/" data-id="cm7yic4k8001a68vd5mk8fcs1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/selenium%E5%AE%9A%E4%BD%8D/" rel="tag">selenium定位</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql8用户权限" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/" class="article-date">
  <time datetime="2022-11-07T03:11:19.000Z" itemprop="datePublished">2022-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/">mysql8用户权限</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="mysql-的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权"><a href="#mysql-的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权" class="headerlink" title="mysql 的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权"></a>mysql 的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权</h4><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test1‘@’ip’;<br>create user ‘test1‘@’172.172.30.53’ identified by ‘Aa123456@@’;<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test2‘@’主机名’; （host要是mysql30-53）[update user set host=’%’ where user=’test2’;]<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test3‘@’localhost’;<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test4‘@’127.0.0.1’;<br>查看用户权限：show grants for myuser;     (show grants for root@’localhost’)<br>查看所有用户：select user,host from mysql.user;<br>查看单个用户的所有情况：select * from mysql.user where user=’myuser’\G</p>
<h4 id="授予用户权限和收回权限"><a href="#授予用户权限和收回权限" class="headerlink" title="授予用户权限和收回权限"></a>授予用户权限和收回权限</h4><p>创建用户：<br>create user ‘testss‘@’172.172.30.%’ identified by ‘Aa123456##’;<br>更新用户访问ip:<br>update user set host=’172.172.30.%’, where user=’testcc’;<br>授予用户远程访问的权限：<br>GRANT create,select, INSERT,UPDATE,DELETE,DROP,CREATE,RELOAD, PROCESS, REPLICATION CLIENT,BACKUP_ADMIN,REPLICATION_APPLIER,SESSION_VARIABLES_ADMIN ON <em>.</em> TO ‘testss‘@’172.172.30.%’  WITH GRANT OPTION;<br>grant insert ON <em>.</em> TO ‘testcc‘@’172.172.30.%’  WITH GRANT OPTION;<br>回收权限：revoke select on <em>.</em> from ‘data‘@’172.172.30.%’;</p>
<h4 id="查看mysql日志命令"><a href="#查看mysql日志命令" class="headerlink" title="查看mysql日志命令"></a>查看mysql日志命令</h4><p>获取binlog文件列表:<br>mysql&gt; show binary logs;<br>生成一个新的binlog日志：<br>mysql&gt; flush logs;<br>查看当前正在写入的binlog文件<br>mysql&gt; show master status\G<br>查看指定binlog文件的内容<br>mysql&gt; show binlog events in ‘mysql-bin.000002’<br>查看mysql的binlog日志是否开启：<br>show variables like ‘log_bin’;</p>
<h4 id="Mysql创建自动插入数据的存储过程"><a href="#Mysql创建自动插入数据的存储过程" class="headerlink" title="Mysql创建自动插入数据的存储过程"></a>Mysql创建自动插入数据的存储过程</h4><p>create table test(datetime datetime);<br>CREATE PROCEDURE user()<br>insert into test values(now());<br>CREATE EVENT IF NOT EXISTS eventJob<br>ON SCHEDULE EVERY 1 SECOND<br>ON COMPLETION PRESERVE<br>DO CALL user();<br>alter event eventJob on completion preserve enable;<br>SET GLOBAL event_scheduler = 1;</p>
<p>关闭定时器：<br>alter event eventJob  on completion preserve disable;<br>SET GLOBAL event_scheduler = 0；</p>
<h4 id="mysql插入当前时间"><a href="#mysql插入当前时间" class="headerlink" title="mysql插入当前时间"></a>mysql插入当前时间</h4><p>create table test(name varchar(255));<br>insert into test values (now());</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/" data-id="cm7yic4jz000968vd5bxq4bnj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql%E6%9D%83%E9%99%90/" rel="tag">mysql权限</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python读写Excel文件-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/" class="article-date">
  <time datetime="2022-11-07T02:18:53.000Z" itemprop="datePublished">2022-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%84%E7%90%86Excel%E6%96%87%E4%BB%B6/">处理Excel文件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/">python读写Excel文件-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p>
<p>本章我们继续讲解基于另一个三方库<code>openpyxl</code>如何进行Excel文件操作，首先需要先安装它。</p>
<pre><code class="Bash">pip install openpyxl
</code></pre>
<p><code>openpyxl</code>的优点在于，当我们打开一个Excel文件后，既可以对它进行读操作，又可以对它进行写操作，而且在操作的便捷性上是优于<code>xlwt</code>和<code>xlrd</code>的。此外，如果要进行样式编辑和公式计算，使用<code>openpyxl</code>也远比上一个章节我们讲解的方式更为简单，而且<code>openpyxl</code>还支持数据透视和插入图表等操作，功能非常强大。有一点需要再次强调，<code>openpyxl</code>并不支持操作Office 2007以前版本的Excel文件。</p>
<h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xlsx”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p>
<pre><code class="Python">import datetime

import openpyxl

# 加载一个工作簿 ---&gt; Workbook
wb = openpyxl.load_workbook(&#39;阿里巴巴2020年股票数据.xlsx&#39;)
# 获取工作表的名字
print(wb.sheetnames)
# 获取工作表 ---&gt; Worksheet
sheet = wb.worksheets[0]
# 获得单元格的范围
print(sheet.dimensions)
# 获得行数和列数
print(sheet.max_row, sheet.max_column)

# 获取指定单元格的值
print(sheet.cell(3, 3).value)
print(sheet[&#39;C3&#39;].value)
print(sheet[&#39;G255&#39;].value)

# 获取多个单元格（嵌套元组）
print(sheet[&#39;A2:C5&#39;])

# 读取所有单元格的数据
for row_ch in range(2, sheet.max_row + 1):
    for col_ch in &#39;ABCDEFG&#39;:
        value = sheet[f&#39;&#123;col_ch&#125;&#123;row_ch&#125;&#39;].value
        if type(value) == datetime.datetime:
            print(value.strftime(&#39;%Y年%m月%d日&#39;), end=&#39;\t&#39;)
        elif type(value) == int:
            print(f&#39;&#123;value:&lt;10d&#125;&#39;, end=&#39;\t&#39;)
        elif type(value) == float:
            print(f&#39;&#123;value:.4f&#125;&#39;, end=&#39;\t&#39;)
        else:
            print(value, end=&#39;\t&#39;)
    print()
</code></pre>
<blockquote>
<p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xlsx”可以通过后面的百度云盘地址进行获取。链接:<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p>
</blockquote>
<p>需要提醒大家一点，<code>openpyxl</code>获取指定的单元格有两种方式，一种是通过<code>cell</code>方法，需要注意，该方法的行索引和列索引都是从<code>1</code>开始的，这是为了照顾用惯了Excel的人的习惯；另一种是通过索引运算，通过指定单元格的坐标，例如<code>C3</code>、<code>G255</code>，也可以取得对应的单元格，再通过单元格对象的<code>value</code>属性，就可以获取到单元格的值。通过上面的代码，相信大家还注意到了，可以通过类似<code>sheet[&#39;A2:C5&#39;]</code>或<code>sheet[&#39;A2&#39;:&#39;C5&#39;]</code>这样的切片操作获取多个单元格，该操作将返回嵌套的元组，相当于获取到了多行多列。</p>
<h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>下面我们使用<code>openpyxl</code>来进行写Excel操作。</p>
<pre><code class="Python">import random

import openpyxl

# 第一步：创建工作簿（Workbook）
wb = openpyxl.Workbook()

# 第二步：添加工作表（Worksheet）
sheet = wb.active
sheet.title = &#39;期末成绩&#39;

titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)
for col_index, title in enumerate(titles):
    sheet.cell(1, col_index + 1, title)

names = (&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;)
for row_index, name in enumerate(names):
    sheet.cell(row_index + 2, 1, name)
    for col_index in range(2, 5):
        sheet.cell(row_index + 2, col_index, random.randrange(50, 101))

# 第四步：保存工作簿
wb.save(&#39;考试成绩表.xlsx&#39;)
</code></pre>
<h4 id="调整样式和公式计算"><a href="#调整样式和公式计算" class="headerlink" title="调整样式和公式计算"></a>调整样式和公式计算</h4><p>在使用<code>openpyxl</code>操作Excel时，如果要调整单元格的样式，可以直接通过单元格对象（<code>Cell</code>对象）的属性进行操作。单元格对象的属性包括字体（<code>font</code>）、对齐（<code>alignment</code>）、边框（<code>border</code>）等，具体的可以参考<code>openpyxl</code>的<a target="_blank" rel="noopener" href="https://openpyxl.readthedocs.io/en/stable/index.html">官方文档</a>。在使用<code>openpyxl</code>时，如果需要做公式计算，可以完全按照Excel中的操作方式来进行，具体的代码如下所示。</p>
<pre><code class="Python">import openpyxl
from openpyxl.styles import Font, Alignment, Border, Side

# 对齐方式
alignment = Alignment(horizontal=&#39;center&#39;, vertical=&#39;center&#39;)
# 边框线条
side = Side(color=&#39;ff7f50&#39;, style=&#39;mediumDashed&#39;)

wb = openpyxl.load_workbook(&#39;考试成绩表.xlsx&#39;)
sheet = wb.worksheets[0]

# 调整行高和列宽
sheet.row_dimensions[1].height = 30
sheet.column_dimensions[&#39;E&#39;].width = 120

sheet[&#39;E1&#39;] = &#39;平均分&#39;
# 设置字体
sheet.cell(1, 5).font = Font(size=18, bold=True, color=&#39;ff1493&#39;, name=&#39;华文楷体&#39;)
# 设置对齐方式
sheet.cell(1, 5).alignment = alignment
# 设置单元格边框
sheet.cell(1, 5).border = Border(left=side, top=side, right=side, bottom=side)
for i in range(2, 7):
    # 公式计算每个学生的平均分
    sheet[f&#39;E&#123;i&#125;&#39;] = f&#39;=average(B&#123;i&#125;:D&#123;i&#125;)&#39;
    sheet.cell(i, 5).font = Font(size=12, color=&#39;4169e1&#39;, italic=True)
    sheet.cell(i, 5).alignment = alignment

wb.save(&#39;考试成绩表.xlsx&#39;)
</code></pre>
<h3 id="生成统计图表"><a href="#生成统计图表" class="headerlink" title="生成统计图表"></a>生成统计图表</h3><p>通过<code>openpyxl</code>库，可以直接向Excel中插入统计图表，具体的做法跟在Excel中插入图表大体一致。我们可以创建指定类型的图表对象，然后通过该对象的属性对图表进行设置。当然，最为重要的是为图表绑定数据，即横轴代表什么，纵轴代表什么，具体的数值是多少。最后，可以将图表对象添加到表单中，具体的代码如下所示。</p>
<pre><code class="Python">from openpyxl import Workbook
from openpyxl.chart import BarChart, Reference

wb = Workbook(write_only=True)
sheet = wb.create_sheet()

rows = [
    (&#39;类别&#39;, &#39;销售A组&#39;, &#39;销售B组&#39;),
    (&#39;手机&#39;, 40, 30),
    (&#39;平板&#39;, 50, 60),
    (&#39;笔记本&#39;, 80, 70),
    (&#39;外围设备&#39;, 20, 10),
]

# 向表单中添加行
for row in rows:
    sheet.append(row)

# 创建图表对象
chart = BarChart()
chart.type = &#39;col&#39;
chart.style = 10
# 设置图表的标题
chart.title = &#39;销售统计图&#39;
# 设置图表纵轴的标题
chart.y_axis.title = &#39;销量&#39;
# 设置图表横轴的标题
chart.x_axis.title = &#39;商品类别&#39;
# 设置数据的范围
data = Reference(sheet, min_col=2, min_row=1, max_row=5, max_col=3)
# 设置分类的范围
cats = Reference(sheet, min_col=1, min_row=2, max_row=5)
# 给图表添加数据
chart.add_data(data, titles_from_data=True)
# 给图表设置分类
chart.set_categories(cats)
chart.shape = 4
# 将图表添加到表单指定的单元格中
sheet.add_chart(chart, &#39;A10&#39;)

wb.save(&#39;demo.xlsx&#39;)
</code></pre>
<p>运行上面的代码，打开生成的Excel文件，效果如下图所示。</p>
<img src="https://github.com/jackfrued/mypic/raw/master/20210819235009.png" alt="image-20210819235009026" width="75%">

<h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。如果数据体量较大或者处理数据的方式比较复杂，我们还是推荐大家使用Python数据分析神器之一的<code>pandas</code>库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/" data-id="cm7yic4k7001268vdh957drji" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Excel/" rel="tag">Excel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python读写Excel文件-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-1/" class="article-date">
  <time datetime="2022-11-07T02:14:39.000Z" itemprop="datePublished">2022-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-1/">python读写Excel文件-1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p>
<p>Python操作Excel需要三方库的支持，如果要兼容Excel 2007以前的版本，也就是<code>xls</code>格式的Excel文件，可以使用三方库<code>xlrd</code>和<code>xlwt</code>，前者用于读Excel文件，后者用于写Excel文件。如果使用较新版本的Excel，即操作<code>xlsx</code>格式的Excel文件，可以使用<code>openpyxl</code>库，当然这个库不仅仅可以操作Excel，还可以操作其他基于Office Open XML的电子表格文件。</p>
<p>本章我们先讲解基于<code>xlwt</code>和<code>xlrd</code>操作Excel文件，大家可以先使用下面的命令安装这两个三方库以及配合使用的工具模块<code>xlutils</code>。</p>
<pre><code class="Bash">pip install xlwt xlrd xlutils
</code></pre>
<h3 id="读Excel文件"><a href="#读Excel文件" class="headerlink" title="读Excel文件"></a>读Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xls”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p>
<pre><code class="Python">import xlrd

# 使用xlrd模块的open_workbook函数打开指定Excel文件并获得Book对象（工作簿）
wb = xlrd.open_workbook(&#39;阿里巴巴2020年股票数据.xls&#39;)
# 通过Book对象的sheet_names方法可以获取所有表单名称
sheetnames = wb.sheet_names()
print(sheetnames)
# 通过指定的表单名称获取Sheet对象（工作表）
sheet = wb.sheet_by_name(sheetnames[0])
# 通过Sheet对象的nrows和ncols属性获取表单的行数和列数
print(sheet.nrows, sheet.ncols)
for row in range(sheet.nrows):
    for col in range(sheet.ncols):
        # 通过Sheet对象的cell方法获取指定Cell对象（单元格）
        # 通过Cell对象的value属性获取单元格中的值
        value = sheet.cell(row, col).value
        # 对除首行外的其他行进行数据格式化处理
        if row &gt; 0:
            # 第1列的xldate类型先转成元组再格式化为“年月日”的格式
            if col == 0:
                # xldate_as_tuple函数的第二个参数只有0和1两个取值
                # 其中0代表以1900-01-01为基准的日期，1代表以1904-01-01为基准的日期
                value = xlrd.xldate_as_tuple(value, 0)
                value = f&#39;&#123;value[0]&#125;年&#123;value[1]:&gt;02d&#125;月&#123;value[2]:&gt;02d&#125;日&#39;
            # 其他列的number类型处理成小数点后保留两位有效数字的浮点数
            else:
                value = f&#39;&#123;value:.2f&#125;&#39;
        print(value, end=&#39;\t&#39;)
    print()
# 获取最后一个单元格的数据类型
# 0 - 空值，1 - 字符串，2 - 数字，3 - 日期，4 - 布尔，5 - 错误
last_cell_type = sheet.cell_type(sheet.nrows - 1, sheet.ncols - 1)
print(last_cell_type)
# 获取第一行的值（列表）
print(sheet.row_values(0))
# 获取指定行指定列范围的数据（列表）
# 第一个参数代表行索引，第二个和第三个参数代表列的开始（含）和结束（不含）索引
print(sheet.row_slice(3, 0, 5))
</code></pre>
<blockquote>
<p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xls”可以通过后面的百度云盘地址进行获取。链接:<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p>
</blockquote>
<p>相信通过上面的代码，大家已经了解到了如何读取一个Excel文件，如果想知道更多关于<code>xlrd</code>模块的知识，可以阅读它的<a target="_blank" rel="noopener" href="https://xlrd.readthedocs.io/en/latest/">官方文档</a>。</p>
<h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>写入Excel文件可以通过<code>xlwt</code> 模块的<code>Workbook</code>类创建工作簿对象，通过工作簿对象的<code>add_sheet</code>方法可以添加工作表，通过工作表对象的<code>write</code>方法可以向指定单元格中写入数据，最后通过工作簿对象的<code>save</code>方法将工作簿写入到指定的文件或内存中。下面的代码实现了将<code>5</code>个学生<code>3</code>门课程的考试成绩写入Excel文件的操作。</p>
<pre><code class="Python">import random

import xlwt

student_names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]
scores = [[random.randrange(50, 101) for _ in range(3)] for _ in range(5)]
# 创建工作簿对象（Workbook）
wb = xlwt.Workbook()
# 创建工作表对象（Worksheet）
sheet = wb.add_sheet(&#39;一年级二班&#39;)
# 添加表头数据
titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)
for index, title in enumerate(titles):
    sheet.write(0, index, title)
# 将学生姓名和考试成绩写入单元格
for row in range(len(scores)):
    sheet.write(row + 1, 0, student_names[row])
    for col in range(len(scores[row])):
        sheet.write(row + 1, col + 1, scores[row][col])
# 保存Excel工作簿
wb.save(&#39;考试成绩表.xls&#39;)
</code></pre>
<h4 id="调整单元格样式"><a href="#调整单元格样式" class="headerlink" title="调整单元格样式"></a>调整单元格样式</h4><p>在写Excel文件时，我们还可以为单元格设置样式，主要包括字体（Font）、对齐方式（Alignment）、边框（Border）和背景（Background）的设置，<code>xlwt</code>对这几项设置都封装了对应的类来支持。要设置单元格样式需要首先创建一个<code>XFStyle</code>对象，再通过该对象的属性对字体、对齐方式、边框等进行设定，例如在上面的例子中，如果希望将表头单元格的背景色修改为黄色，可以按照如下的方式进行操作。</p>
<pre><code class="Python">header_style = xlwt.XFStyle()
pattern = xlwt.Pattern()
pattern.pattern = xlwt.Pattern.SOLID_PATTERN
# 0 - 黑色、1 - 白色、2 - 红色、3 - 绿色、4 - 蓝色、5 - 黄色、6 - 粉色、7 - 青色
pattern.pattern_fore_colour = 5
header_style.pattern = pattern
titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)
for index, title in enumerate(titles):
    sheet.write(0, index, title, header_style)
</code></pre>
<p>如果希望为表头设置指定的字体，可以使用<code>Font</code>类并添加如下所示的代码。</p>
<pre><code class="Python">font = xlwt.Font()
# 字体名称
font.name = &#39;华文楷体&#39;
# 字体大小（20是基准单位，18表示18px）
font.height = 20 * 18
# 是否使用粗体
font.bold = True
# 是否使用斜体
font.italic = False
# 字体颜色
font.colour_index = 1
header_style.font = font
</code></pre>
<blockquote>
<p><strong>注意</strong>：上面代码中指定的字体名（<code>font.name</code>）应当是本地系统有的字体，例如在我的电脑上有名为“华文楷体”的字体。</p>
</blockquote>
<p>如果希望表头垂直居中对齐，可以使用下面的代码进行设置。</p>
<pre><code class="Python">align = xlwt.Alignment()
# 垂直方向的对齐方式
align.vert = xlwt.Alignment.VERT_CENTER
# 水平方向的对齐方式
align.horz = xlwt.Alignment.HORZ_CENTER
header_style.alignment = align
</code></pre>
<p>如果希望给表头加上黄色的虚线边框，可以使用下面的代码来设置。</p>
<pre><code class="Python">borders = xlwt.Borders()
props = (
    (&#39;top&#39;, &#39;top_colour&#39;), (&#39;right&#39;, &#39;right_colour&#39;),
    (&#39;bottom&#39;, &#39;bottom_colour&#39;), (&#39;left&#39;, &#39;left_colour&#39;)
)
# 通过循环对四个方向的边框样式及颜色进行设定
for position, color in props:
    # 使用setattr内置函数动态给对象指定的属性赋值
    setattr(borders, position, xlwt.Borders.DASHED)
    setattr(borders, color, 5)
header_style.borders = borders
</code></pre>
<p>如果要调整单元格的宽度（列宽）和表头的高度（行高），可以按照下面的代码进行操作。</p>
<pre><code class="Python"># 设置行高为40px
sheet.row(0).set_style(xlwt.easyxf(f&#39;font:height &#123;20 * 40&#125;&#39;))
titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)
for index, title in enumerate(titles):
    # 设置列宽为200px
    sheet.col(index).width = 20 * 200
    # 设置单元格的数据和样式
    sheet.write(0, index, title, header_style)
</code></pre>
<h4 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h4><p>对于前面打开的“阿里巴巴2020年股票数据.xls”文件，如果要统计全年收盘价（Close字段）的平均值以及全年交易量（Volume字段）的总和，可以使用Excel的公式计算即可。我们可以先使用<code>xlrd</code>读取Excel文件夹，然后通过<code>xlutils</code>三方库提供的<code>copy</code>函数将读取到的Excel文件转成<code>Workbook</code>对象进行写操作，在调用<code>write</code>方法时，可以将一个<code>Formula</code>对象写入单元格。</p>
<p>实现公式计算的代码如下所示。</p>
<pre><code class="Python">import xlrd
import xlwt
from xlutils.copy import copy

wb_for_read = xlrd.open_workbook(&#39;阿里巴巴2020年股票数据.xls&#39;)
sheet1 = wb_for_read.sheet_by_index(0)
nrows, ncols = sheet1.nrows, sheet1.ncols
wb_for_write = copy(wb_for_read)
sheet2 = wb_for_write.get_sheet(0)
sheet2.write(nrows, 4, xlwt.Formula(f&#39;average(E2:E&#123;nrows&#125;)&#39;))
sheet2.write(nrows, 6, xlwt.Formula(f&#39;sum(G2:G&#123;nrows&#125;)&#39;))
wb_for_write.save(&#39;阿里巴巴2020年股票数据汇总.xls&#39;)
</code></pre>
<blockquote>
<p><strong>说明</strong>：上面的代码有一些小瑕疵，有兴趣的读者可以自行探索并思考如何解决。</p>
</blockquote>
<h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。当然，如果要对表格数据进行处理，使用Python数据分析神器之一的<code>pandas</code>库可能更为方便。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-1/" data-id="cm7yic4k6000z68vd3ryl0k10" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Excel/" rel="tag">Excel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python处理csv文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/07/python%E5%A4%84%E7%90%86csv%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2022-11-07T01:53:53.000Z" itemprop="datePublished">2022-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%84%E7%90%86Excel%E6%96%87%E4%BB%B6/">处理Excel文件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/07/python%E5%A4%84%E7%90%86csv%E6%96%87%E4%BB%B6/">python处理csv文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-CSV文件介绍"><a href="#1-CSV文件介绍" class="headerlink" title="1.CSV文件介绍"></a>1.CSV文件介绍</h3><p>CSV（Comma Separated Values）全称逗号分隔值文件是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，而且很多编程语言中都提供了对读写CSV文件的支持，因此CSV格式在数据处理和数据科学中被广泛应用。</p>
<p>CSV文件有以下特点：</p>
<ol>
<li>纯文本，使用某种字符集（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GB2312">GB2312</a>）等）；</li>
<li>由一条条的记录组成（典型的是每行一条记录）；</li>
<li>每条记录被分隔符（如逗号、分号、制表符等）分隔为字段（列）；</li>
<li>每条记录都有同样的字段序列。</li>
</ol>
<p>CSV文件可以使用文本编辑器或类似于Excel电子表格这类工具打开和编辑，当使用Excel这类电子表格打开CSV文件时，你甚至感觉不到CSV和Excel文件的区别。很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，这些内容并不是现在要讨论的重点。</p>
<h3 id="2-将数据写入CSV文件"><a href="#2-将数据写入CSV文件" class="headerlink" title="2.将数据写入CSV文件"></a>2.将数据写入CSV文件</h3><p>现有五个学生三门课程的考试成绩需要保存到一个CSV文件中，要达成这个目标，可以使用Python标准库中的<code>csv</code>模块，该模块的<code>writer</code>函数会返回一个<code>csvwriter</code>对象，通过该对象的<code>writerow</code>或<code>writerows</code>方法就可以将数据写入到CSV文件中，具体的代码如下所示。</p>
<pre><code class="Python">import csv
import random

with open(&#39;scores.csv&#39;, &#39;w&#39;) as file:
    writer = csv.writer(file)
    writer.writerow([&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;])
    names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]
    for name in names:
        scores = [random.randrange(50, 101) for _ in range(3)]
        scores.insert(0, name)
        writer.writerow(scores)
</code></pre>
<p>生成的CSV文件的内容。</p>
<pre><code>姓名,语文,数学,英语
关羽,98,86,61
张飞,86,58,80
赵云,95,73,70
马超,83,97,55
黄忠,61,54,87
</code></pre>
<p>需要说明的是上面的<code>writer</code>函数，除了传入要写入数据的文件对象外，还可以<code>dialect</code>参数，它表示CSV文件的方言，默认值是<code>excel</code>。除此之外，还可以通过<code>delimiter</code>、<code>quotechar</code>、<code>quoting</code>参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。大家可以尝试将上面第5行代码修改为下面的代码，然后查看生成的CSV文件。</p>
<pre><code class="Python">writer = csv.writer(file, delimiter=&#39;|&#39;, quoting=csv.QUOTE_ALL)
</code></pre>
<p>生成的CSV文件的内容。</p>
<pre><code>&quot;姓名&quot;|&quot;语文&quot;|&quot;数学&quot;|&quot;英语&quot;
&quot;关羽&quot;|&quot;88&quot;|&quot;64&quot;|&quot;65&quot;
&quot;张飞&quot;|&quot;76&quot;|&quot;93&quot;|&quot;79&quot;
&quot;赵云&quot;|&quot;78&quot;|&quot;55&quot;|&quot;76&quot;
&quot;马超&quot;|&quot;72&quot;|&quot;77&quot;|&quot;68&quot;
&quot;黄忠&quot;|&quot;70&quot;|&quot;72&quot;|&quot;51&quot;
</code></pre>
<h3 id="3-从CSV文件读取数据"><a href="#3-从CSV文件读取数据" class="headerlink" title="3.从CSV文件读取数据"></a>3.从CSV文件读取数据</h3><p>如果要读取刚才创建的CSV文件，可以使用下面的代码，通过<code>csv</code>模块的<code>reader</code>函数可以创建出<code>csvreader</code>对象，该对象是一个迭代器，可以通过<code>next</code>函数或<code>for-in</code>循环读取到文件中的数据。</p>
<pre><code class="Python">import csv

with open(&#39;scores.csv&#39;, &#39;r&#39;) as file:
    reader = csv.reader(file, delimiter=&#39;|&#39;)
    for data_list in reader:
        print(reader.line_num, end=&#39;\t&#39;)
        for elem in data_list:
            print(elem, end=&#39;\t&#39;)
        print()
</code></pre>
<blockquote>
<p><strong>注意</strong>：上面的代码对<code>csvreader</code>对象做<code>for</code>循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。</p>
</blockquote>
<h3 id="4-简单的总结"><a href="#4-简单的总结" class="headerlink" title="4.简单的总结"></a>4.简单的总结</h3><p>将来如果大家使用Python做数据分析，很有可能会用到名为<code>pandas</code>的三方库，它是Python数据分析的神器之一。<code>pandas</code>中封装了名为<code>read_csv</code>和<code>to_csv</code>的函数用来读写CSV文件，其中<code>read_CSV</code>会将读取到的数据变成一个<code>DataFrame</code>对象，而<code>DataFrame</code>就是<code>pandas</code>库中最重要的类型，它封装了一系列用于数据处理的方法（清洗、转换、聚合等）；而<code>to_csv</code>会将<code>DataFrame</code>对象中的数据写入CSV文件，完成数据的持久化。<code>read_csv</code>函数和<code>to_csv</code>函数远远比原生的<code>csvreader</code>和<code>csvwriter</code>强大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/07/python%E5%A4%84%E7%90%86csv%E6%96%87%E4%BB%B6/" data-id="cm7yic4k6000w68vd8zay9cu2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/csv/" rel="tag">csv</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python读取excle内容" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/14/python%E8%AF%BB%E5%8F%96excle%E5%86%85%E5%AE%B9/" class="article-date">
  <time datetime="2022-10-14T03:24:23.000Z" itemprop="datePublished">2022-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/14/python%E8%AF%BB%E5%8F%96excle%E5%86%85%E5%AE%B9/">python读取excel内容</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-代码如下："><a href="#1-代码如下：" class="headerlink" title="1.代码如下："></a>1.代码如下：</h4><pre><code class="python">import xlrd
import xlsxwriter

# 操作Excel的工具类
class Excel():
    # 初始化方法 参数type：为r是读取excel，为w是写入excel获取不同的实例，参数file_name是将要读取的文件
    def __init__(self, type, file_name):
        # 读取excel
        if type == &#39;r&#39;:
            # 打开文件
            self.workbook = xlrd.open_workbook(file_name)
            # 获取到所有的sheet_names,sheet1,sheet2获取到所有，获取到的是一个list
            self.sheet_names = self.workbook.sheet_names()
            # 装载所有数据的list
            self.list_data = []
        # 写入excel
        elif type == &#39;w&#39;:
            # 获得写入excel的实例
            self.workbook = xlsxwriter.Workbook(file_name)

    def read(self):
        # 根据sheet_name去读取用例，并获取文件的总行数获取到每行的内容
        for sheet_name in self.sheet_names:
            # 通过每个sheetname获取到每个页的内容
            sheet = self.workbook.sheet_by_name(sheet_name)
            # 获取总行数
            rosw = sheet.nrows
            # 根据总行数进行读取
            for i in range(0, rosw):
                rowvalues = sheet.row_values(i)
                # 将每一行的内容添加进去
                self.list_data.append(rowvalues)
            #     去除大标题第一行进行切割处理
        # 将得到的excel数据返回进行处理
        return self.list_data

#将元素和链接表处理为json格式方便查询
def element_tojson(element):
    elements = &#123;&#125;
    #将元素和接口信息组成key和value的形式方便查询
    for e in element:
        elements[e[0]] = &#123;&quot;type&quot;: e[1], &quot;url&quot;: e[2]&#125;
    return elements
if __name__ == &#39;__main__&#39;:
    file = &#39;../element/test1.xls&#39;
    e = Excel(&#39;r&#39;, file)
    list_read = e.read()
    e = element_tojson(list_read)
    print(e[&#39;获取短信验证码&#39;])
    print(e)
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/14/python%E8%AF%BB%E5%8F%96excle%E5%86%85%E5%AE%B9/" data-id="cm7yic4k7001568vd4wil3go6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jmeter/">jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%9F%BA%E7%A1%80/">linux基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/pytest/">pytest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/selenium/">selenium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/unittest/">unittest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%84%E7%90%86Excel%E6%96%87%E4%BB%B6/">处理Excel文件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/">接口测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrony/" rel="tag">Chrony</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Excel/" rel="tag">Excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csv/" rel="tag">csv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" rel="tag">jmeter_cookie处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" rel="tag">jmeter参数化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4/" rel="tag">linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql%E6%9D%83%E9%99%90/" rel="tag">mysql权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ntpd/" rel="tag">ntpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest/" rel="tag">pytest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" rel="tag">selenium多窗口_警告框处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%AE%9A%E4%BD%8D/" rel="tag">selenium定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" rel="tag">selenium时间等待</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" rel="tag">接口基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="tag">类与对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Chrony/" style="font-size: 10px;">Chrony</a> <a href="/tags/Excel/" style="font-size: 13.33px;">Excel</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/csv/" style="font-size: 10px;">csv</a> <a href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" style="font-size: 10px;">jmeter_cookie处理</a> <a href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" style="font-size: 10px;">jmeter参数化</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">linux命令</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/mysql%E6%9D%83%E9%99%90/" style="font-size: 10px;">mysql权限</a> <a href="/tags/ntpd/" style="font-size: 10px;">ntpd</a> <a href="/tags/pytest/" style="font-size: 10px;">pytest</a> <a href="/tags/pytest%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">pytest基础</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" style="font-size: 10px;">selenium多窗口_警告框处理</a> <a href="/tags/selenium%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">selenium定位</a> <a href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" style="font-size: 10px;">selenium时间等待</a> <a href="/tags/unittest%E6%A6%82%E5%BF%B5/" style="font-size: 13.33px;">unittest概念</a> <a href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">接口基础</a> <a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 20px;">类与对象</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE/">服务器同步时间配置</a>
          </li>
        
          <li>
            <a href="/2025/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/">mysql数据库插入数据</a>
          </li>
        
          <li>
            <a href="/2025/03/03/%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B0%81%E8%A3%85%E5%B1%9E%E6%80%A7%E5%90%8D/">在类中封装属性名</a>
          </li>
        
          <li>
            <a href="/2025/03/03/%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/">对象支持上下文管理协议</a>
          </li>
        
          <li>
            <a href="/2025/03/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/">自定义字符串的格式化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 当时只道是寻常<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>