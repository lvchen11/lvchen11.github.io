<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>月明星稀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="太阳当空照，花儿爱微笑">
<meta property="og:type" content="website">
<meta property="og:title" content="月明星稀">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="月明星稀">
<meta property="og:description" content="太阳当空照，花儿爱微笑">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="当时只道是寻常">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="月明星稀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">月明星稀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JMeter中使用“用户参数”实现参数化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/06/15/JMeter%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%80%9C%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E2%80%9D%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96/" class="article-date">
  <time datetime="2023-06-15T09:22:07.000Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/jmeter/">jmeter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/06/15/JMeter%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%80%9C%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E2%80%9D%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96/">JMeter中使用“用户参数”实现参数化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-用户参数组件介绍"><a href="#1-用户参数组件介绍" class="headerlink" title="1. 用户参数组件介绍"></a>1. <strong>用户参数组件介绍</strong></h4><p>​    用户参数（User  Parameter）组件在前置处理器元件中添加，前置处理器的作用是在取样器发出请求之前，执行一些操作。即：如果将前置处理器附加到取样器元件中，则它将在该取样器元件运行之前执行。常用操作如：取样器参数设置、环境变量设置、脚本预处理等。之前我们介绍过，JMeter中常用的参数化方式有四种：1、CSV数据文件设置（CSV Data Set Config）：这种方式是通常所指的参数化。数据存储在文件中，该种参数化方式取值范围大，灵活性强，适用于大量测试数据时的使用。</p>
<h5 id="1-1-用户参数（User-Parameter）"><a href="#1-1-用户参数（User-Parameter）" class="headerlink" title="1.1 用户参数（User Parameter）"></a>1.1 用户参数（User Parameter）</h5><p>​        适用于参数取值范围很小，需要少量测试数据时使用。</p>
<h5 id="1-2-用户自定义变量（User-Defined-Variables）"><a href="#1-2-用户自定义变量（User-Defined-Variables）" class="headerlink" title="1.2 用户自定义变量（User Defined Variables）"></a>1.2 用户自定义变量（User Defined Variables）</h5><p>​        更多用于设置全局变量，常用于数据库地址，测试环境、开发环境地址等常量配置。</p>
<h5 id="1-3-函数助手"><a href="#1-3-函数助手" class="headerlink" title="1.3  函数助手"></a>1.3  函数助手</h5><p>​        可使用函数生成随机数字和随机字符串实现参数化。本文以前置处理器中的<strong>用户参数</strong>组件为例，实现JMeter中的参数化。</p>
<h4 id="2-用户参数界面介绍"><a href="#2-用户参数界面介绍" class="headerlink" title="2. 用户参数界面介绍"></a>2. <strong>用户参数界面介绍</strong></h4><p>​    <strong>用户参数</strong>组件添加方式：选中“取样器”右键—&gt;添加—&gt;前置处理器—&gt;用户参数。</p>
<p><img src="../images/%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E7%95%8C%E9%9D%A2.jpg" alt="用户参数界面"></p>
<p>界面说明：</p>
<ul>
<li><strong>名称</strong>：用户参数组件的自定义名称，见名知意最好。</li>
<li><strong>注释</strong>：即添加一些备注信息，对该用户参数组件的简短说明，以便后期回顾时查看。</li>
<li><strong>每次迭代更新一次</strong>：不同的线程需要应用不同的用户数据，这时就需要勾选此选项。也就是根据线程组里设置的线程数，每个线程调用不同的用户数据，依次取值。但是我实际操作中，勾选不勾选都能够依次取值。（如果修改线程组界面中的循环次数，勾不勾选，都只用一个用户的值。）</li>
<li><strong>添加变量</strong>：横着添加一行变量信息，此变量会应用于每个用户。</li>
<li><strong>删除变量</strong>：删除所选中的一行数据。</li>
<li><strong>添加用户</strong>：竖着添加一个用户信息，一个用户就是一组测试数据。</li>
<li><strong>删除用户</strong>：删除所选中的一列数据。</li>
<li><strong>向上和向下按钮</strong>：就是上下移动所选中变量的位置。</li>
</ul>
<h4 id="3-使用“用户参数”组件实现参数化"><a href="#3-使用“用户参数”组件实现参数化" class="headerlink" title="3. 使用“用户参数”组件实现参数化"></a>3. <strong>使用“用户参数”组件实现参数化</strong></h4><p>​    需求，实现批量新建和删除标签</p>
<h5 id="3-1测试计划内包含的元件"><a href="#3-1测试计划内包含的元件" class="headerlink" title="3.1测试计划内包含的元件"></a>3.1<strong>测试计划内包含的元件</strong></h5><p><strong>添加元件操作步骤</strong>：</p>
<p>​    1、创建测试计划</p>
<p>​    2、创建线程组：选中“测试计划”右键—&gt;添加—&gt;线程（用户）—&gt;线程组。</p>
<p>​    3、在线程组中，添加取样器”HTTP请求“组件：选中“线程组”右键—&gt;添加—&gt;取样器—&gt; HTTP请求。</p>
<p>​    4、在取样器中，添加前置处理器“用户参数”组件：选中“取样器”右键—&gt;添加—&gt;前置处理器—&gt;用户参数。</p>
<p>​    5、在线程组中，添加监听器察看结果树组件：查看结果，选中“线程组”右键—&gt;添加—&gt;监听器—&gt;察看结果树。</p>
<p>最终测试计划中的元件如下：</p>
<p><img src="../images/%E6%A0%87%E7%AD%BE%E6%96%B0%E5%BB%BA.jpg" alt="标签新建"></p>
<h5 id="3-2-线程组元件内容"><a href="#3-2-线程组元件内容" class="headerlink" title="3.2 线程组元件内容"></a>3.2 <strong>线程组元件内容</strong></h5><p><img src="../images/%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E5%8C%96_%E7%BA%BF%E7%A8%8B%E6%95%B0.jpg" alt="用户参数化_线程数"></p>
<h5 id="3-3-HTTP请求组件内容"><a href="#3-3-HTTP请求组件内容" class="headerlink" title="3.3 HTTP请求组件内容"></a>3.3 <strong>HTTP请求组件内容</strong></h5><p><img src="../images/%E6%A0%87%E7%AD%BEhttp.jpg" alt="标签http"></p>
<h5 id="3-4-用户参数组件内容"><a href="#3-4-用户参数组件内容" class="headerlink" title="3.4 用户参数组件内容"></a>3.4 <strong>用户参数组件内容</strong></h5><p><img src="../images/%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E7%95%8C%E9%9D%A2.jpg" alt="用户参数界面"></p>
<h4 id="4-脚本运行结果"><a href="#4-脚本运行结果" class="headerlink" title="4. 脚本运行结果"></a>4. <strong>脚本运行结果</strong></h4><p><img src="../images/%E7%BB%93%E6%9E%9C.jpg" alt="结果"></p>
<h5 id="5-总结优先级说明："><a href="#5-总结优先级说明：" class="headerlink" title="5. 总结优先级说明："></a>5. <strong>总结</strong>优先级说明：</h5><ul>
<li>线程组下的用户参数组件 优先级高于 测试计划 里的用户自定义变量。</li>
<li>HTTP 请求下的用户参数组件 优先级高于 **线程组下 **的用户参数组件。</li>
<li>若有重名参数，优先取优先级高的用户参数。</li>
<li>若用户参数和用户自定义变量重名，则优先取用户参数组件中的值 。因为配置元件执行完再到前置处理器，所以前置处理器的值会覆盖配置元件中设置的值。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/JMeter%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%80%9C%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0%E2%80%9D%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96/" data-id="cm7yic4ju000368vd68if7ozg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" rel="tag">jmeter参数化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JMeter中实现跨线程组关联" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/06/15/JMeter%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%85%B3%E8%81%94/" class="article-date">
  <time datetime="2023-06-15T06:15:15.000Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/jmeter/">jmeter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/06/15/JMeter%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%85%B3%E8%81%94/">JMeter中实现跨线程组关联</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-JMeter中实现跨线程组关联说明"><a href="#1-JMeter中实现跨线程组关联说明" class="headerlink" title="1. JMeter中实现跨线程组关联说明"></a>1. JMeter中实现跨线程组关联说明</h4><h4 id="1-1-JMeter中实现跨线程组关联步骤"><a href="#1-1-JMeter中实现跨线程组关联步骤" class="headerlink" title="1.1 JMeter中实现跨线程组关联步骤"></a>1.1 <strong>JMeter中实现跨线程组关联步骤</strong></h4><p>​    1、先进行登陆请求。<br>​    2、记录登陆请求返回的Cookie，或者有关登录状态的token信息。<br>​    3、如果是Cookie，就用HTTP Cookie管理器获取。<br>​    4、如果是token，就用提取器进行提取。<br>​    5、然后通过函数助手中的__setProperty函数，把Cookie值升级为JMeter的全局属性，就可以在线程组和线程组之间共享了。<br>​    6、然后从另一个线程组中通过__property函数，获取全局数据。<br>​    7、然后把获取的Cookie或token，加入到查看购物车请求中，保持用户登陆状态。<br>​    8、如果是Cookie，就用添加到HTTP信息头管理器组件中。<br>​    9、如果是token，就添加到请求的参数中。<br>​    10、执行脚本，查看运行结果。</p>
<h4 id="2-测试计划内包含的元件"><a href="#2-测试计划内包含的元件" class="headerlink" title="2.测试计划内包含的元件"></a>2.<strong>测试计划内包含的元件</strong></h4><p>​    1、创建测试计划。<br>​    2、创建线程组：选中“测试计划”右键 —&gt; 添加 —&gt; 线程（用户） —&gt; 线程组。<br>​    3、在线程组中，添加配置元件HTTP Cookie管理器组件：选中“线程组”右键 —&gt; 添加 —&gt; 配置元件 —&gt; HTTP<br>Cookie管理器。<br>​    4、在线程组中，添加取样器“HTTP请求”组件：选中“线程组”右键 —&gt; 添加 —&gt; 取样器 —&gt; HTTP请求。<br>​    5、在线程组中，添加取样器“BeanShell 取样器”组件：选中“线程组”右键 —&gt; 添加 —&gt; 取样器 —&gt; BeanShell<br>取样器BeanShell 取样器。<br>​    6、在线程组中，添加配置元件“HTTP信息头管理器”组件：选中“线程组”右键 —&gt; 添加 —&gt; 配置元件 —&gt; HTTP信息头管理器。<br>​    7、在线程组中，添加监听器“察看结果树”组件：选中“线程组”右键 —&gt; 添加 —&gt; 监听器 —&gt; 察看结果树。</p>
<p>最终测试计划中的元件如下：</p>
<p><img src="../images/%E5%9B%BE%E5%83%8F.jpg" alt="图像"></p>
<h4 id="3-用户登陆请求的相关操作"><a href="#3-用户登陆请求的相关操作" class="headerlink" title="3. 用户登陆请求的相关操作"></a>3. 用户登陆请求的相关操作</h4><h5 id="3-1-进行登陆操作获取Cookie信息"><a href="#3-1-进行登陆操作获取Cookie信息" class="headerlink" title="3.1 进行登陆操作获取Cookie信息"></a>3.1 <strong>进行登陆操作获取Cookie信息</strong></h5><p><img src="../images/%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2.jpg" alt="登陆页面"></p>
<p>通过添加HTTP Cookie管理器组件，会把服务器返回来的Cookie信息，默认存储到线程变量中</p>
<p><strong>前提</strong>：jmeter.properties文件中，设置CookieManager.save.cookies=true</p>
<p>然后我们可以通过Debug Sampler（调试取样器）组件，查看到线程变量中的Cookie数据。</p>
<p><img src="../images/cookie%E5%AD%98%E6%94%BE.jpg" alt="cookie存放"></p>
<p>说明：保持用户登陆状态的Cookie数据： COOKIE_sid=40cbbff1-567f-4434-b414-1977dd321149，这样我们就找到Cookie的值了。</p>
<h5 id="3-2-把Cookie数据提升为JMeter的全局属性"><a href="#3-2-把Cookie数据提升为JMeter的全局属性" class="headerlink" title="3.2 把Cookie数据提升为JMeter的全局属性"></a>3.2 <strong>把Cookie数据提升为JMeter的全局属性</strong></h5><p>我们需要通过__setProperty函数，把Cookie数据提升为JMeter的全局属性。这样该Cookie就可以在JMeter脚本中，所有线程组里都可以使用了。（也就是可以在线程组和线程组之间通信）</p>
<p>接下来点击：工具 —&gt; 函数助手对话框，打开函数助手。（之前的版本在选项中）</p>
<p>然后选择__setProperty函数。</p>
<p>第一行填写：填写升级为全局属性后的变量名。（自定义即可）</p>
<p>第二行填写：定义全局属性的值。（我们就把Cookie属性的值，引用到这里）</p>
<p>Return Original Value of property (default false)?：返回属性的原始值（默认为 false），默认即可。<br><img src="../images/set.jpg" alt="set"></p>
<p>这样我们就把Cookie提升为JMeter的全局属性了，变量名叫kuayu_session。</p>
<p>JMeter的全局属性就相当于在“测试计划”界面中定义的用户定义的变里</p>
<h5 id="3-3-编写BeanShell取样器组件"><a href="#3-3-编写BeanShell取样器组件" class="headerlink" title="3.3 编写BeanShell取样器组件"></a>3.3 <strong>编写BeanShell取样器组件</strong></h5><p>上面生成的这个函数比较特殊，他必须放到BeanShell Sampler组件里面。当把这个函数放到BeanShell取样器组件里面后，就相当于把变量kuayu_session的值，放到了我们声明的公共空间里面。</p>
<p><img src="../images/%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.jpg" alt="设置为全局变量"></p>
<h4 id="4-新建标签请求的相关操作"><a href="#4-新建标签请求的相关操作" class="headerlink" title="4.新建标签请求的相关操作"></a>4.新建标签请求的相关操作</h4><h5 id="4-1-查看标签请求"><a href="#4-1-查看标签请求" class="headerlink" title="4.1 查看标签请求"></a>4.1 查看标签请求</h5><p><img src="../images/%E6%A0%87%E7%AD%BE%E6%96%B0%E5%BB%BA.jpg" alt="标签新建"></p>
<h5 id="4-2-获取JMeter全局属性"><a href="#4-2-获取JMeter全局属性" class="headerlink" title="4.2 获取JMeter全局属性"></a>4.2 <strong>获取JMeter全局属性</strong></h5><p>因为我们把用户登陆线程组中的Cookie属性提升为JMeter全局属性了。</p>
<p>需要在查看购物车线程组中把全局属性中的Cookie属性获取到，使用__Property函数。</p>
<p>打开函数助手：工具 —&gt; 函数助手对话框。（之前的版本在选项中）</p>
<p>选择__Property函数。</p>
<p>第一行：填写要获取的JMeter全局属性的变量名。（即：kuayu_session）</p>
<p>第二行：重用函数计算值的引用名。（可选填）</p>
<p>默认值：属性未定义时的默认值。</p>
<p><img src="../images/%E5%8F%96%E7%94%A8cookie.jpg" alt="取用cookie"></p>
<h5 id="4-3-HTTP信息头管理器内容"><a href="#4-3-HTTP信息头管理器内容" class="headerlink" title="4.3 HTTP信息头管理器内容"></a>4.3 <strong>HTTP信息头管理器内容</strong></h5><p>我们需要把上一步获取到的Cookie信息，放入新建标签的请求中。</p>
<p>因为是Cookie的相关数据，只能放在请求头的信息中。（如果要是token，就放在请求的参数中</p>
<p><img src="../images/http%E4%BF%A1%E6%81%AF%E5%A4%B4%E7%AE%A1%E7%90%86%E5%99%A8.jpg" alt="http信息头管理器"></p>
<p>这样查看新建标签请求，就带有用户的登陆状态了。</p>
<h5 id="4-4-设置线程组的启动时间"><a href="#4-4-设置线程组的启动时间" class="headerlink" title="4.4 设置线程组的启动时间"></a>4.4 <strong>设置线程组的启动时间</strong></h5><p>因为我们需要等待前面的登陆线程组执行完成后，在进行查看购物的请求，否则将获取不到我们需要的Cookie信息。</p>
<p>这时候就需要设置线程组元件界面中的调度器属性了。</p>
<p>我们把持续时间和启动延迟都设置成3，表示JMeter脚本启动3秒后，再执行查看购物线程组中的内容，并持续3秒钟。</p>
<p><img src="../images/%E8%B0%83%E5%BA%A6%E5%99%A8.jpg" alt="调度器"></p>
<p>调度器配置（Scheduler Configuration）说明:</p>
<ul>
<li>持续时间（秒）：如果选择了调度程序复选框，控制测试执行的持续时间，以秒为单位。</li>
<li>启动延迟（秒）：如果选择了调度程序复选框，控制测试在多久后启动执行，以秒为单位。</li>
</ul>
<h4 id="5-运行结果说明"><a href="#5-运行结果说明" class="headerlink" title="5 运行结果说明"></a>5 运行结果说明</h4><p><img src="../images/%E7%BB%93%E6%9E%9C.jpg" alt="结果"></p>
<h4 id="6-拓展说明（也很重点）"><a href="#6-拓展说明（也很重点）" class="headerlink" title="6. 拓展说明（也很重点）"></a>6. 拓展说明（也很重点）</h4><p>如上需求，在进行性能测试的时候，我们要保证登陆请求线程组中，所有用户登陆的Cookie或token都保存好，才能进入到下一个线程组中执行其他的跨域关联请求。</p>
<p>这样就会有两种实现方式：</p>
<p>1、像本篇文章一样，把需要关联的数据提升到全局属性。</p>
<p>但是这种方式只能适用于单线程跨域关联，如果是很多用户并发进行跨域关联，该种方式只是把最后一个登陆请求的Cookie或token进行了提升。所以下一个线程组中使用的登陆状态，都是登陆线程组最后一个人的请求状态。<br>2、第二种方式，把登陆请求中的Cookie或token信息，提取出来并保存到一个文件中。然后在其他关联跨域请求中，使用参数化的方式，把用户登陆的Cookie或token信息，传入到所需的请求中，从而实现跨域关联的操作。（推荐）</p>
<h5 id="6-1-第二种方式实现步骤："><a href="#6-1-第二种方式实现步骤：" class="headerlink" title="6.1 第二种方式实现步骤："></a>6.1 <strong>第二种方式实现步骤：</strong></h5><ol>
<li>每一个接口放在一个线程组中。</li>
<li>把登陆接口的返回Cookie数据，写入到.csv文件中。</li>
<li>jmeter写.csv文件，使用BeanShell。取样器添加后置处理器BeanShell postprocessor。</li>
<li>在下一个跨域关联接口使用数据，用参数化的方式导入.csv文件。</li>
</ol>
<p>提供BeanShell中的数据存储代码（简单示例）</p>
<pre><code class="shell">import java.io.FileWriter;
import java.io.BufferedWriter;


FileWriter fstream = new FileWriter(&quot;C:\\Users\\L\\Desktop\\JMeterScript\\user_session.csv&quot;, true);
BufferedWriter out = new BufferedWriter(fstream);
out.write(vars.get(&quot;COOKIE_ECS_ID&quot;)+&quot;\n&quot;);
out.close();
fstream.close();
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/JMeter%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B7%A8%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%85%B3%E8%81%94/" data-id="cm7yic4jx000768vdgzxxc33e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" rel="tag">jmeter_cookie处理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-property的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/17/python-property%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2023-05-17T05:45:05.000Z" itemprop="datePublished">2023-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/17/python-property%E7%9A%84%E4%BD%BF%E7%94%A8/">python @property的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-python的-property是python的一种装饰器，是用来修饰方法的"><a href="#1-python的-property是python的一种装饰器，是用来修饰方法的" class="headerlink" title="1. python的@property是python的一种装饰器，是用来修饰方法的"></a>1. python的@property是python的一种装饰器，是用来修饰方法的</h4><h5 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h5><p>使用@property装饰器来创建<strong>只读属性</strong>，@property装饰器会将<strong>方法</strong>转换为相同名称的<strong>只读属性</strong>,可以与所定义的属性配合使用，这样可以防止属性被修改。</p>
<h5 id="1-2-修饰方法，使方法可以像属性一样访问"><a href="#1-2-修饰方法，使方法可以像属性一样访问" class="headerlink" title="1.2  修饰方法，使方法可以像属性一样访问"></a>1.2  修饰方法，使方法可以像属性一样访问</h5><pre><code class="python">class DataSet(object):
  @property
  def method_with_property(self): ##含有@property
      return 15
  def method_without_property(self): ##不含@property
      return 15

l = DataSet()
print(l.method_with_property) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。
print(l.method_without_property())  #没有加@property , 必须使用正常的调用方法的形式，即在后面加()
# 两个输出都为15
</code></pre>
<p>如果使用property进行修饰后，又在调用的时候，方法后面添加了()， 那么就会显示错误信息：TypeError: ‘int’ object  is not callable，也就是说添加@property  后，这个方法就变成了一个属性，如果后面加入了()，那么就是当作函数来调用，而它却不是callable（可调用）的。</p>
<h5 id="1-3-不加括号"><a href="#1-3-不加括号" class="headerlink" title="1.3 不加括号"></a>1.3 不加括号</h5><p>没有使用property修饰，它是一种方法，如果把括号去掉，不会报错输出的就会是方法存放的地址。</p>
<pre><code class="python">class DataSet(object):
  def method_without_property(self): ##不含@property
      return 15
l = DataSet()
print(l.method_without_property） #没有加@property , 必须使用正常的调用方法的形式，即在后面加()
</code></pre>
<h4 id="2-与所定义的属性配合使用，这样可以防止属性被修改"><a href="#2-与所定义的属性配合使用，这样可以防止属性被修改" class="headerlink" title="2. 与所定义的属性配合使用，这样可以防止属性被修改"></a>2. 与所定义的属性配合使用，这样可以防止属性被修改</h4><p>​        由于python进行属性的定义时，没办法设置私有属性，因此要通过@property的方法来进行设置。这样可以隐藏属性名，让用户进行使用的时候无法随意修改。</p>
<pre><code class="python">class DataSet(object):
    def __init__(self):
        self._images = 1
        self._labels = 2 #定义属性的名称
    @property
    def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。
        return self._images 
    @property
    def labels(self):
        return self._labels
l = DataSet()
#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。
print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。
</code></pre>
<p>总结：类中定义私有属性有两种方式：一种用单下划线，表示这个属性是类的私有属性，不希望被外部访问到，但仅仅是不希望，还是可以被访问的；第二种是双下划线，表示这个属性就是类的私有属性，只能在类中被使用，不可以在实例化的对象中去使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/17/python-property%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="cm7yic4k5000u68vdaj11b0fg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pytest-parametrize-参数化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/23/pytest-parametrize-%E5%8F%82%E6%95%B0%E5%8C%96/" class="article-date">
  <time datetime="2023-02-23T08:16:38.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pytest/">pytest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/23/pytest-parametrize-%E5%8F%82%E6%95%B0%E5%8C%96/">pytest_parametrize()参数化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="pytest参数化"><a href="#pytest参数化" class="headerlink" title="pytest参数化"></a>pytest参数化</h5><ol>
<li>pytest.mark.parametrize()方式进行<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%82%E6%95%B0%E5%8C%96&spm=1001.2101.3001.7020">参数化</a></li>
<li>pytest.fixture()方式进行参数化，fixture装饰的函数可以作为参数传入其他函数</li>
<li>conftest.py 文件中存放参数化函数，可作用于模块内的所有</li>
<li>测试用例 支持元组，列表，支持列表嵌套列表，列表嵌套元组，列表嵌套字典，支持类和函数的参数化</li>
</ol>
<pre><code class="python">一，@pytest.mark.parametrize(&#39;参数名&#39;，list)方式

pytest.mark.parametrize(argnames, argvalues)，是pytest自带的装饰器之一

1. 传一个参数 @pytest.mark.parametrize(&#39;参数名&#39;，list)

2. 传两个参数@pytest.mark.parametrize(&#39;参数名1，参数名2&#39;，[(参数1_data[0], 参数2_data[0]),(参数1_data[1], 参数2_data[1])]) 进行参数化,参数值，是list,多组数据用元组类型; 传三个或更多参数也是这样传。list的每个元素都是一个元组，元组里的每个元素和按参数顺序一一对应
</code></pre>
<h6 id="单个变量"><a href="#单个变量" class="headerlink" title="单个变量"></a>单个变量</h6><pre><code class="python">import pytest
@pytest.mark.parametrize(&#39;user&#39;, (&quot;zhangsan&quot;, &quot;lisi&quot;))
def test_01(user):
    print(user)
</code></pre>
<h6 id="单个参数，参数为列表"><a href="#单个参数，参数为列表" class="headerlink" title="单个参数，参数为列表"></a>单个参数，参数为列表</h6><pre><code class="python">import pytest
datatest04 = [&#39;zhangsan&#39;, &#39;lisi&#39;]
@pytest.mark.parametrize(&#39;user&#39;, datatest04)
def test_04(user):
    print(user)
</code></pre>
<h6 id="多个变量，列表中嵌套元组。列表中，每一组数据用元组格式"><a href="#多个变量，列表中嵌套元组。列表中，每一组数据用元组格式" class="headerlink" title="多个变量，列表中嵌套元组。列表中，每一组数据用元组格式"></a>多个变量，列表中嵌套元组。列表中，每一组数据用元组格式</h6><pre><code class="python">import pytest
@pytest.mark.parametrize(&#39;user,password&#39;, [(&quot;zhangsan&quot;, &quot;111111&quot;), (&quot;lisi&quot;, &quot;222222&quot;)])
def test_02(user, password):
    print(user, password)
</code></pre>
<h6 id="多个变量，列表中嵌套列表。列表中，每一组数据用列表格式"><a href="#多个变量，列表中嵌套列表。列表中，每一组数据用列表格式" class="headerlink" title="多个变量，列表中嵌套列表。列表中，每一组数据用列表格式"></a>多个变量，列表中嵌套列表。列表中，每一组数据用列表格式</h6><pre><code class="python">import pytest
data = [[&quot;zhangsan&quot;, &quot;111111111&quot;], [&quot;lisi&quot;, &quot;2222222&quot;]]
@pytest.mark.parametrize(&#39;user,password&#39;, data)
def test_05(user, password):
    print(user, password)
</code></pre>
<h6 id="组合函数-笛卡尔集"><a href="#组合函数-笛卡尔集" class="headerlink" title="组合函数-笛卡尔集"></a>组合函数-笛卡尔集</h6><pre><code class="python">import pytest
data1 = [&quot;zhangsan&quot;, &quot;lisi&quot;]
data2 = [&quot;1111111&quot;, &quot;2222222&quot;]
@pytest.mark.parametrize(&#39;user&#39;, data1)
@pytest.mark.parametrize(&#39;password&#39;, data2)
def test_06(user, password):
    print(user, password)
</code></pre>
<h6 id="列表嵌套字典"><a href="#列表嵌套字典" class="headerlink" title="列表嵌套字典"></a>列表嵌套字典</h6><pre><code class="python">import pytest
datatest07 = [&#123;&quot;user&quot;: &quot;zhangsan&quot;, &quot;password&quot;: &quot;111111111&quot;&#125;, &#123;&quot;user&quot;: &quot;lisi&quot;, &quot;password&quot;: &quot;222222&quot;&#125;]
@pytest.mark.parametrize(&quot;data&quot;, datatest07)
def test_07(data):
    print(data)
    print(data[&quot;user&quot;], data[&quot;password&quot;])
# 执行结果
test0223.py::test_07[data0] PASSED                                       [ 50%]&#123;&#39;user&#39;: &#39;zhangsan&#39;, &#39;password&#39;: &#39;111111111&#39;&#125;
zhangsan 111111111

test0223.py::test_07[data1] PASSED                                       [100%]&#123;&#39;user&#39;: &#39;lisi&#39;, &#39;password&#39;: &#39;222222&#39;&#125;
lisi 222222
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/23/pytest-parametrize-%E5%8F%82%E6%95%B0%E5%8C%96/" data-id="cm7yic4k2000i68vd2xgfbbn7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pytest/" rel="tag">pytest</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pytest基础3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/23/pytest%E5%9F%BA%E7%A1%803/" class="article-date">
  <time datetime="2023-02-23T03:11:40.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pytest/">pytest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/23/pytest%E5%9F%BA%E7%A1%803/">pytest基础3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="pytest基础用法二"><a href="#pytest基础用法二" class="headerlink" title="pytest基础用法二"></a>pytest基础用法二</h5><pre><code class="python">前置条件：
1.文件路径：
Test_App
    - - test_abc.py
    - - pytest.ini
2.pyetst.ini配置文件内容：
[pytest]
  命令行参数
 addopts = -s
 搜索文件名
 python_files = test*.py
  搜索的类名
 python_classes = Test*
搜索的函数名
 python_functions = test_*
</code></pre>
<h5 id="跳过测试函数"><a href="#跳过测试函数" class="headerlink" title="跳过测试函数"></a>跳过测试函数</h5><pre><code class="python">根据特定的条件，不执行标识的测试函数.
 方法：
     skipif(condition, reason=None)
 参数：
     condition：跳过的条件，必传参数
     reason：标注原因，必传参数
 使用方法：
     @pytest.mark.skipif(condition, reason=&quot;xxx&quot;) 
</code></pre>
<pre><code class="python">import pytest
class Test_ABC:
    def setup_class(self):
        print(&quot;-------&gt;setup_class&quot;)
    def teardown_class(self):
        print(&quot;-------&gt;teardown_class&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
    @pytest.mark.skipif(condition=2&gt;1,reason = &quot;跳过该函数&quot;) # 跳过测试函数test_b
    def test_b(self):
        print(&quot;-------&gt;test_b&quot;)
        assert 0
# 执行结果：
test0223.py::Test_ABC::test_a -------&gt;setup_class
PASSED                                     [ 50%]-------&gt;test_a

test0223.py::Test_ABC::test_b SKIPPED (跳过该函数)                       [100%]
Skipped: 跳过该函数
-------&gt;teardown_class
</code></pre>
<h5 id="标记为预期失败函数"><a href="#标记为预期失败函数" class="headerlink" title="标记为预期失败函数"></a>标记为预期失败函数</h5><pre><code class="tex">标记测试函数为失败函数
 方法：
     xfail(condition=None, reason=None, raises=None, run=True, strict=False)
 常用参数：
     condition：预期失败的条件，必传参数
     reason：失败的原因，必传参数
 使用方法：
     @pytest.mark.xfail(condition, reason=&quot;xx&quot;)
</code></pre>
<pre><code class="python">import pytest
class Test_ABC:
    def setup_class(self):
        print(&quot;-------&gt;setup_class&quot;)
    def teardown_class(self):
        print(&quot;-------&gt;teardown_class&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
    @pytest.mark.xfail(2 &gt; 1, reason=&quot;标注为预期失败&quot;) # 标记为预期失败函数test_b
    def test_b(self):
       print(&quot;-------&gt;test_b&quot;)
       assert 0
if __name__ == &#39;__main__&#39;:
    pytest.main()
# 执行结果
-------&gt;setup_class
PASSED                                     [ 50%]-------&gt;test_a
XFAIL (标注为预期失败)                     [100%]-------&gt;test_b

self = &lt;test0223.Test_ABC object at 0x000001F92D538640&gt;

    @pytest.mark.xfail(2 &gt; 1, reason=&quot;标注为预期失败&quot;) # 标记为预期失败函数test_b
    def test_b(self):
       print(&quot;-------&gt;test_b&quot;)
&gt;      assert 0
E      assert 0
</code></pre>
<h5 id="函数数据参数化"><a href="#函数数据参数化" class="headerlink" title="函数数据参数化"></a>函数数据参数化</h5><pre><code class="python">方便测试函数对测试属于的获取。
 方法：
     parametrize(argnames, argvalues, indirect=False, ids=None, scope=None)
 常用参数：
     argnames：参数名
     argvalues：参数对应值，类型必须为list
                 当参数为一个时格式：[value]
                 当参数个数大于一个时，格式为:[(param_value1,param_value2.....),(param_value1,param_value2.....)]
 使用方法:
     @pytest.mark.parametrize(argnames,argvalues)
     ️ 参数值为N个，测试方法就会运行N次
</code></pre>
<pre><code class="python"># 单个参数示例
import pytest
class Test_ABC:
    def setup_class(self):
        print(&quot;-------&gt;setup_class&quot;)
    def teardown_class(self):
        print(&quot;-------&gt;teardown_class&quot;)

    @pytest.mark.parametrize(&quot;a&quot;, [3, 6])  # a参数被赋予两个值，函数会运行两遍
    def test_a(self, a):  # 参数必须和parametrize里面的参数一致
        print(&quot;test data:a=%d&quot; % a)
        assert a % 3 == 0
 # 运行结果
 test0223.py::Test_ABC::test_a[3] -------&gt;setup_class
PASSED                                  [ 50%]test data:a=3

test0223.py::Test_ABC::test_a[6] PASSED                                  [100%]test data:a=6
-------&gt;teardown_class
</code></pre>
<pre><code class="python"># 多个参数示例
import pytest
class Test_ABC:
    def setup_class(self):
        print(&quot;-------&gt;setup_class&quot;)
    def teardown_class(self):
        print(&quot;-------&gt;teardown_class&quot;)

    @pytest.mark.parametrize(&quot;a,b&quot;,[(1,2),(0,3)]) # 参数a,b均被赋予两个值，函数会运行两遍
    def test_a(self,a,b): # 参数必须和parametrize里面的参数一致
        print(&quot;test data:a=%d,b=%d&quot;%(a,b))
        assert a+b == 3
 # 执行结果
 test_abc.py 
    -------&gt;setup_class
    test data:a=1,b=2 # 运行第一次取值 a=1,b=2
    .
    test data:a=0,b=3 # 运行第二次取值 a=0,b=3
    .
    -------&gt;teardown_class
</code></pre>
<pre><code class="python"># 函数返回值类型示例：
import pytest


def return_test_data():
    return [(1, 2), (0, 3)]


class Test_ABC:
    def setup_class(self):
        print(&quot;-------&gt;setup_class&quot;)

    def teardown_class(self):
        print(&quot;-------&gt;teardown_class&quot;)

    @pytest.mark.parametrize(&quot;a,b&quot;, return_test_data())  # 使用函数返回值的形式传入参数值
    def test_a(self, a, b):
        print(&quot;test data:a=%d,b=%d&quot; % (a, b))
        assert a + b == 3
# 执行结果
test0223.py::Test_ABC::test_a[1-2] -------&gt;setup_class
PASSED                                [ 50%]test data:a=1,b=2

test0223.py::Test_ABC::test_a[0-3] PASSED                                [100%]test data:a=0,b=3
-------&gt;teardown_class
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/23/pytest%E5%9F%BA%E7%A1%803/" data-id="cm7yic4k4000q68vd47msas5p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pytest基础2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/23/pytest%E5%9F%BA%E7%A1%802/" class="article-date">
  <time datetime="2023-02-23T02:16:19.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pytest/">pytest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/23/pytest%E5%9F%BA%E7%A1%802/">pytest基础2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="pytest用法一"><a href="#pytest用法一" class="headerlink" title="pytest用法一"></a>pytest用法一</h4><pre><code class="python">前置条件：
1.文件路径：
Test_App
    - - test_abc.py
    - - pytest.ini
2.pyetst.ini配置文件内容：
[pytest]
  命令行参数
 addopts = -s
 搜索文件名
 python_files = test*.py
  搜索的类名
 python_classes = Test*
搜索的函数名
 python_functions = test_*
</code></pre>
<h5 id="pytest之fixture"><a href="#pytest之fixture" class="headerlink" title="pytest之fixture"></a>pytest之fixture</h5><p>fixture修饰器来标记固定的工厂函数,在其他函数，模块，类或整个工程调用它时会被激活并优先执行,通常会被用于完成预置处理和重复操作。</p>
<pre><code class="python">方法：fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None)
常用参数：
scope: 被标记方法的作用域
&quot;function&quot;(default): 作用于每个测试方法，每个test都运行一次
&quot;class&quot;: 作用于整个类，每个class的所有test只运行一次
&quot;module&quot;: 作用于整个模块，每个module的所有test只运行一次
&quot;session&quot;: 作用于整个session,每个session只运行一次
 params：(list类型)提供参数数据，供调用标记方法的函数使用
 autouse：是否自动运行,默认为False不运行，设置为True自动运行
</code></pre>
<h5 id="fixture第一个例子（通过参数引用）"><a href="#fixture第一个例子（通过参数引用）" class="headerlink" title="fixture第一个例子（通过参数引用）"></a>fixture第一个例子（通过参数引用）</h5><pre><code class="python">class Test_ABC:
    @pytest.fixture()
    def before(self):
        print(&quot;-------&gt;before&quot;)
    def test_a(self,before): # ️ test_a方法传入了被fixture标识的函数，已变量的形式
        print(&quot;-------&gt;test_a&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果：发现before会优先于测试函数运行
test0223.py::Test_ABC::test_a -------&gt;before
PASSED                                     [100%]-------&gt;test_a
</code></pre>
<h5 id="fixture第二个例子（通过函数引用）"><a href="#fixture第二个例子（通过函数引用）" class="headerlink" title="fixture第二个例子（通过函数引用）"></a>fixture第二个例子（通过函数引用）</h5><pre><code class="python">import pytest
@pytest.fixture() # fixture标记的函数可以应用于测试类外部
def before():
    print(&quot;-------&gt;before&quot;)
@pytest.mark.usefixtures(&quot;before&quot;)
class Test_ABC:
    def setup(self):
        print(&quot;-------&gt;setup&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
          pytest.main(&quot;-s  test_abc.py&quot;)
  执行结果：
      test_abc.py 
      -------&gt;before # 发现before会优先于测试类运行
      -------&gt;setup
      -------&gt;test_a
      .
</code></pre>
<h5 id="fixture第三个例子（默认设置为运行）"><a href="#fixture第三个例子（默认设置为运行）" class="headerlink" title="fixture第三个例子（默认设置为运行）"></a>fixture第三个例子（默认设置为运行）</h5><pre><code class="python">import pytest
@pytest.fixture(autouse=True) # 设置为默认运行
def before():
 print(&quot;-------&gt;before&quot;)
class Test_ABC:
 def setup(self):
     print(&quot;-------&gt;setup&quot;)
 def test_a(self):
     print(&quot;-------&gt;test_a&quot;)
     assert 1
if __name__ == &#39;__main__&#39;:
 pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果：
test0223.py::Test_ABC::test_a -------&gt;before #发现before自动优先于测试类运行
-------&gt;setup
PASSED                                     [100%]-------&gt;test_a
</code></pre>
<h5 id="fixture第四个例子-设置作用域为function"><a href="#fixture第四个例子-设置作用域为function" class="headerlink" title="fixture第四个例子(设置作用域为function)"></a>fixture第四个例子(设置作用域为function)</h5><pre><code class="python">import pytest
@pytest.fixture(scope=&#39;function&#39;,autouse=True) # 作用域设置为function，自动运行
def before():
    print(&quot;-------&gt;before&quot;)
class Test_ABC:
    def setup(self):
        print(&quot;-------&gt;setup&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
    def test_b(self):
        print(&quot;-------&gt;test_b&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果：
test0223.py::Test_ABC::test_a -------&gt;before # 运行第一次
-------&gt;setup
PASSED                                     [ 50%]-------&gt;test_a

test0223.py::Test_ABC::test_b -------&gt;before # 运行第二次
-------&gt;setup
PASSED                                     [100%]-------&gt;test_b
</code></pre>
<h5 id="fixture第五个例子-设置作用域为class"><a href="#fixture第五个例子-设置作用域为class" class="headerlink" title="fixture第五个例子(设置作用域为class)"></a>fixture第五个例子(设置作用域为class)</h5><pre><code class="python">import pytest
@pytest.fixture(scope=&#39;class&#39;,autouse=True) # 作用域设置为class，自动运行
def before():
    print(&quot;-------&gt;before&quot;)
class Test_ABC:
    def setup(self):
        print(&quot;-------&gt;setup&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
    def test_b(self):
        print(&quot;-------&gt;test_b&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果
test0223.py::Test_ABC::test_a -------&gt;before  # 发现只运行一次
-------&gt;setup
PASSED                                     [ 50%]-------&gt;test_a

test0223.py::Test_ABC::test_b -------&gt;setup
PASSED                                     [100%]-------&gt;test_b
</code></pre>
<h5 id="fixture第六个例子-返回值"><a href="#fixture第六个例子-返回值" class="headerlink" title="fixture第六个例子(返回值)"></a>fixture第六个例子(返回值)</h5><pre><code class="python">import pytest
@pytest.fixture()
def need_data():
    return 2  # 返回数字2
class Test_ABC:
    def test_a(self, need_data):
        print(&quot;-------&gt;test_a&quot;)
        assert need_data != 3  # 拿到返回值做一次断言
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
 # 执行结果
    test_abc.py 
    -------&gt;test_a
    .
</code></pre>
<pre><code class="python"># 示例二
import pytest
@pytest.fixture(params=[1, 2, 3])
def need_data(request):  # 传入参数request 系统封装参数
    return request.param  # 取列表中单个值，默认的取值方式
class Test_ABC:
     def test_a(self, need_data):
        print(&quot;-------&gt;test_a&quot;)
        assert need_data != 3  # 断言need_data不等于3
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果运行了三次
PASSED                                  [ 33%]-------&gt;test_a
PASSED                                  [ 66%]-------&gt;test_a
FAILED                                  [100%]-------&gt;test_a

test0223.py:10 (Test_ABC.test_a[3])
self = &lt;test0223.Test_ABC object at 0x000001F7D83E8550&gt;, need_data = 3

    def test_a(self, need_data):
        print(&quot;-------&gt;test_a&quot;)
&gt;       assert need_data != 3  # 断言need_data不等于3
E       assert 3 != 3

test0223.py:13: AssertionError
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/23/pytest%E5%9F%BA%E7%A1%802/" data-id="cm7yic4k4000o68vd8a9wanjc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pytest基础1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/22/pytest%E5%9F%BA%E7%A1%801/" class="article-date">
  <time datetime="2023-02-22T09:50:34.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pytest/">pytest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/22/pytest%E5%9F%BA%E7%A1%801/">pytest基础1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="pytest框架约束"><a href="#pytest框架约束" class="headerlink" title="pytest框架约束"></a>pytest框架约束</h4><p>1.所有的单测文件名都需要满足test_*.py格式或*_test.py格式。<br>2.在单测文件中，测试类以Test开头，并且不能带有 init 方法(注意：定义class时，需要以T开头，不然pytest是不会去运行该class的)<br>3.在单测类中，可以包含一个或多个test_开头的函数。此时，在执行pytest命令时，会自动从当前目录及子目录中寻找符合上述约束的测试函数来执行。</p>
<h5 id="控制测试用例执行"><a href="#控制测试用例执行" class="headerlink" title="控制测试用例执行"></a>控制测试用例执行</h5><p>1.在第N个用例失败后，结束测试执行</p>
<p>pytest -x                    # 第01次失败，就停止测试<br>pytest –maxfail=2     # 出现2个失败就终止测试</p>
<p>2.指定测试模式    pytest test_mod.py</p>
<p>3.指定测试目录    pytest    ./test/</p>
<p>4.通过node id 指定测试用例 ，nodeid由模块文件名、分隔符、类名、方法名、参数构成，                pytest test_mod.py::test_func</p>
<p>运行模块中的指定方法：pytest test_mod.py::TestClass::test_method</p>
<p>5.通过标记表达式执行  pytest -m slow   会执行被装饰器@pytest.mark.slow装饰的所有测试用例</p>
<p>6、通过包执行测试        pytest –pyargs pkg.testing  这条命令会自动导入包pkg.testing,并使用该包所在的目录，执行下面的用例</p>
<h4 id="其它运行方法"><a href="#其它运行方法" class="headerlink" title="其它运行方法"></a>其它运行方法</h4><p>1.多进程运行cases,当cases量很多时，运行时间也会变的很长，如果想缩短脚本运行的时长，就可以用多进程来运行。</p>
<p>安装pytest-xdist: pip install -U pytest-xdist</p>
<p>运行模式：pytest test_demo1.py -n NUM</p>
<p>2.重试运行cases:  在做接口测试时，有事会遇到503或短时的网络波动，导致case运行失败，而这并非是我们期望的结果，此时可以就可以通过重试运行cases的方式来解决。</p>
<p>安装pytest-rerunfailures：pip install -U pytest-rerunfailures</p>
<p>pytest test_se.py –reruns NUM</p>
<p>3.显示print内容：在运行测试脚本时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是在运行pytest时，这些内容不会显示出来。如果带上-s，就可以显示了。</p>
<p>pytest test_se.py -s -n 4</p>
<h5 id="pytest的set和teardown函数"><a href="#pytest的set和teardown函数" class="headerlink" title="pytest的set和teardown函数"></a>pytest的set和teardown函数</h5><p>1.setup和teardown主要分为：模块级，类，功能，函数级</p>
<p>函数级别setup()和teardown():运行于测试方法的始末</p>
<p>运行一次函数会运行一次setup和teardown</p>
<pre><code class="python">import pytest
class Test_ABC:
  # 函数级开始
  def setup(self):
      print(&quot;-------&gt;setup_method&quot;)
  # 函数级结束
  def teardown(self):
      print(&quot;-------&gt;teardown_method&quot;)
  def test_a(self):
      print(&quot;-------&gt;test_a&quot;)
      assert 1
  def test_b(self):
      print(&quot;-------&gt;test_b&quot;)
if __name__ == &#39;__main__&#39;:
              pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>
<pre><code class="python">执行结果：
test0223.py::Test_ABC::test_a -------&gt;setup_method
PASSED                                     [ 50%]-------&gt;test_a
-------&gt;teardown_method

test0223.py::Test_ABC::test_b -------&gt;setup_method
PASSED                                     [100%]-------&gt;test_b
-------&gt;teardown_method
</code></pre>
<p>类级别：运行于测试类的始末，即:在一个测试内只运行一次setup_class和teardown_class，不关心测试类内有多少个测试函数。</p>
<pre><code class="python">import pytest
class Test_ABC:
   # 测试类级开始
   def setup_class(self):
       print(&quot;-------&gt;setup_class&quot;)
   # 测试类级结束
   def teardown_class(self):
       print(&quot;-------&gt;teardown_class&quot;)
   def test_a(self):
       print(&quot;-------&gt;test_a&quot;)
       assert 1
   def test_b(self):
       print(&quot;-------&gt;test_b&quot;)
if __name__ == &#39;__main__&#39;:
  pytest.main(&quot;-s  test_abc.py&quot;)

执行结果：
test0223.py::Test_ABC::test_a -------&gt;setup_class  #第一次setup_class()
PASSED                                     [ 50%]-------&gt;test_a

test0223.py::Test_ABC::test_b PASSED                                     [100%]-------&gt;test_b
-------&gt;teardown_class    # 第一次teardown_class()
</code></pre>
<h5 id="Pytest配置文件"><a href="#Pytest配置文件" class="headerlink" title="Pytest配置文件"></a>Pytest配置文件</h5><p>pytest的配置文件通常放在测试目录下，名称为pytest.ini，命令行运行时会使用该配置文件中的配置.</p>
<pre><code class="python"># 配置pytest命令行运行参数
[pytest]
addopts = -s...  # 空格分隔，可添加多个命令行参数 -所有参数均为插件包的参数配置测试搜索的路径
testpaths =./ scripts  # 当前目录下的scripts文件夹 -可自定义
# 配置测试搜索的文件名称
python_files = test *.py
# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件 -可自定义
配置测试搜索的测试类名
python_classes = Test_ *

# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件中，以Test开头的类 -可自定义
配置测试搜索的测试函数名

python_functions = test_ *

# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件中，以Test开头的类内，以test_开头的方法 -可自定义
# 前置条件
    - Test_App
    - - test_abc.py
    - - pytest.ini
# pytest.ini的配置文件内容
      [pytest]
    # 命令行参数
     addopts = -s
    # 搜索文件名
     python_files = test_*.py
     # 搜索的类名
     python_classes = Test_*
     #搜索的函数名
        python_functions = test_*
</code></pre>
<h5 id="pytest测试报告"><a href="#pytest测试报告" class="headerlink" title="pytest测试报告"></a>pytest测试报告</h5><pre><code class="text">pytest-HTML是一个插件，pytest用于生成测试结果的HTML报告
安装方式：pip install pytest-html                   pip install pytest-html
通过命令行方式，生成xm l /html格式的测试报告，存储于用户指定路径。插件名称：pytes t -html
使用方法： 命令行格式：pytest --html = 用户路径 / report.html
</code></pre>
<pre><code class="python">import pytest


class Test_ABC:
    def setup_class(self):
        print(&quot;-------&gt;setup_class&quot;)

    def teardown_class(self):
        print(&quot;-------&gt;teardown_class&quot;)

    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1

    def test_b(self):
        print(&quot;-------&gt;test_b&quot;)
        assert 0  # 断言失败```

运行方式：
1.
修改Test_App / pytest.ini文件，添加报告参数，即：addopts = -s - -html =./ report.html
# -s:输出程序运行信息
# --html=./report.html 在当前目录下生成report.html文件
️
若要生成xml文件，可将 - -html =./ report.html
改成 - -html =./ report.xml
2.
命令行进入Test_App目录
3.
执行命令： pytest
执行结果：
1.
在当前目录会生成assets文件夹和report.html文件
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/22/pytest%E5%9F%BA%E7%A1%801/" data-id="cm7yic4k3000k68vdcy6u0ttl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTML测试报告" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" class="article-date">
  <time datetime="2022-11-21T05:50:48.000Z" itemprop="datePublished">2022-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/unittest/">unittest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/">HTML测试报告</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="HTML下载与安装"><a href="#HTML下载与安装" class="headerlink" title="HTML下载与安装"></a>HTML下载与安装</h4><p>HTMLTestRunner.py 文件，既可以把它当作Python 的第三方库来使用，也可以将把它当作项目的一部分来使用。建议将该文件放到python的lib目录下；如果把 HTMLTestRunner 当作项目的一部分来使用，就把它放到项目目录中。可以方便地定制生成的HTMLTestRunner 报告,文件目录结构如下：</p>
<p><img src="/.com//../imags/$%7Bfiilename%7D/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-16690114393791.jpg"></p>
<pre><code class="python">#test_unittest1.py文件
import unittest
from selenium import webdriver
from time import sleep

class TestBaidu(unittest.TestCase):
    driver = None

    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)

    def test_search_key_selenium(self):
        &quot;&quot;&quot;&quot; 搜索关键字：selenium &quot;&quot;&quot;  # 加了注释的测试报告
        search_key = &quot;selenium&quot;
        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)

    def test_search_key_unittest(self):
        &quot;&quot;&quot; 搜索关键字：unittest&quot;&quot;&quot;
        search_key = &quot;unittest&quot;
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main()



</code></pre>
<pre><code class="python">#run_tests.py文件
import unittest
from HTMLTestRunner import HTMLTestRunner
import time

# 定义测试用例的目录为当前目录下的test_case 目录
test_dir = &#39;./test_case&#39;
suit = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;)

# if __name__ == &#39;__main__&#39;:
#     # 生成HTML 格式的报告
#     fp = open(&#39;./test_report/result.html&#39;, &#39;wb&#39;)
#     runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)
#     runner.run(suit)
#     fp.close()


if __name__ == &#39;__main__&#39;:
    # 取当前日期时间，修改测试报告名称，确保测试报告不会被覆盖
    # strftime()方法以指定的格式获取当前日期时间
    now_time = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)
    fp = open(&#39;./test_report/&#39;+ now_time +&#39;result.html&#39;, &#39;wb&#39;)
    runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)
    runner.run(suit)
    fp.close()
</code></pre>
<h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><pre><code class="python">import codecs
import csv
import unittest
from itertools import islice
from time import sleep

from selenium import webdriver
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
        cls.test_data = []
        with codecs.open(&#39;data.csv&#39;, &#39;r&#39;, &#39;utf_8_sig&#39;) as f:
            data = csv.reader(f)
            for line in islice(data, 1, None):
                cls.test_data.append(line)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(3)
    def test_search_selenium(self):
        self.baidu_search(self.test_data[0][1])
    def test_search_unittest(self):
        self.baidu_search(self.test_data[1][1])
    def test_search_parameterized(self):
        self.baidu_search(self.test_data[2][1])
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
    verbosity是一个选项,表示测试结果的信息复杂度，有0、1、2 三个值
    0 (静默模式): 你只能获得总的测试用例数和总的结果 比如 总共10个 失败2 成功8
    1 (默认模式): 非常类似静默模式 只是在每个成功的用例前面有个“.” 每个失败的用例前面有个 “F”
    2 (详细模式):测试结果会显示每个测试用例的所有相关的信息
    并且 你在命令行里加入不同的参数可以起到一样的效果
    加入 --quiet 参数 等效于 verbosity=0
    加入--verbose参数等效于 verbosity=2
    什么都不加就是 verbosity=1
</code></pre>
<h4 id="Parameterized"><a href="#Parameterized" class="headerlink" title="Parameterized"></a>Parameterized</h4><pre><code class="python">import unittest
from time import sleep
from selenium import webdriver
from parameterized import parameterized
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)
    # 通过Parameterized 实现参数化
    @parameterized.expand([
    (&quot;case1&quot;, &quot;selenium&quot;),
    (&quot;case2&quot;, &quot;unittest&quot;),
    (&quot;case3&quot;, &quot;parameterized&quot;),
    ])
    def test_search(self, name, search_key):
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
</code></pre>
<h4 id="DDT"><a href="#DDT" class="headerlink" title="DDT"></a>DDT</h4><pre><code class="python">#列举了三组参数化，第一组为列表，第二组为元组，第三组为字典。需要注意的是，字典的key与测试方法的参数要保持一致。
import unittest
from time import sleep

from selenium import webdriver
from ddt import ddt, data, file_data, unpack
@ddt
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(3)
    # 参数化使用方式一
    @data([&quot;case1&quot;, &quot;selenium&quot;], [&quot;case2&quot;, &quot;ddt&quot;], [&quot;case3&quot;, &quot;python&quot;])
    @unpack
    def test_search1(self, case, search_key):
        print(&quot;第一组测试用例：&quot;, case)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    # 参数化使用方式二
    @data((&quot;case1&quot;, &quot;selenium&quot;), (&quot;case2&quot;, &quot;ddt&quot;), (&quot;case3&quot;, &quot;python&quot;))
    @unpack
    def test_search2(self, case, search_key):
        print(&quot;第二组测试用例：&quot;, case)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    # 参数化使用方式三
    @data(&#123;&quot;search_key&quot;: &quot;selenium&quot;&#125;, &#123;&quot;search_key&quot;: &quot;ddt&quot;&#125;, &#123;&quot;search_key&quot;:
    &quot;python&quot;&#125;)
    @unpack
    def test_search3(self, search_key):
        print(&quot;第三组测试用例：&quot;, search_key)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
</code></pre>
<p>DDT 同样支持数据文件的参数化。它封装了数据文件的读取,不需要关心数据文件是如何被读取进来的</p>
<pre><code class="python">#创建ddt_data_file.json文件
&#123;
&quot;case1&quot;: &#123;&quot;search_key&quot;: &quot;python1&quot;&#125;,
&quot;case2&quot;: &#123;&quot;search_key&quot;: &quot;ddt1&quot;&#125;,
&quot;case3&quot;: &#123;&quot;search_key&quot;: &quot;Selenium1&quot;&#125;
&#125;
</code></pre>
<pre><code class="python">import unittest
from time import sleep

from selenium import webdriver
from ddt import ddt, data, file_data, unpack
@ddt
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(3)
        
    @file_data(&#39;ddt_data_file.json&#39;)
    def test_search4(self, search_key):
        print(&quot;第四组测试用例：&quot;, search_key)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
</code></pre>
<p>DDT 还支持yaml 格式的数据文件</p>
<pre><code class="python">case1:
- search_key: &quot;python&quot;
case2:
- search_key: &quot;ddt&quot;
case3:
- search_key: &quot;unittest&quot;
</code></pre>
<pre><code class="python">@file_data(&#39;ddt_data_file.yaml&#39;)
def test_search5(self, case):
search_key = case[0][&quot;search_key&quot;]
print(&quot;第五组测试用例：&quot;, search_key)
self.baidu_search(search_key)
self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
</code></pre>
<h4 id="自动发送邮件功能"><a href="#自动发送邮件功能" class="headerlink" title="自动发送邮件功能"></a>自动发送邮件功能</h4><pre><code class="python">import time
import unittest
import yagmail
from HTMLTestRunner import HTMLTestRunner
#把测试报告作为附件发送到指定邮箱
def send_mail(report):
    yag = yagmail.SMTP(user=&quot;sender@126.com&quot;,
    password=&quot;a123456&quot;,
    host=&#39;smtp.126.com&#39;)
    subject = &quot;主题，自动化测试报告&quot;
    contents = &quot;正文，请查看附件。&quot;
    yag.send(&#39;receiver@126.com&#39;, subject, contents, report)
    print(&#39;email has send out !&#39;)
if __name__ == &#39;__main__&#39;:
    # 定义测试用例的目录为当前目录
    test_dir = &#39;./test_case&#39;
    suit = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;)
    # 获取当前日期和时间
    now_time = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)
    html_report = &#39;./test_report/&#39; + now_time + &#39;result.html&#39;
    fp = open(html_report, &#39;wb&#39;)
    # 调用HTMLTestRunner，运行测试用例
    runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)
    runner.run(suit)
    fp.close()
    send_mail(html_report)  # 发送报告
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" data-id="cm7yic4js000168vdad9h66vp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-unittest执行用例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/" class="article-date">
  <time datetime="2022-11-18T02:26:22.000Z" itemprop="datePublished">2022-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/unittest/">unittest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/">unittest执行用例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="测试用例的执行顺序"><a href="#测试用例的执行顺序" class="headerlink" title="测试用例的执行顺序"></a>测试用例的执行顺序</h4><p>测试用例的执行顺序涉及多个层级：多个测试目录&gt;多个测试文件&gt;多个测试类&gt;多个测试方法（测试用例）</p>
<p>``</p>
<pre><code class="python">import unittest
class TestBdd(unittest.TestCase):
    def setUp(self):
        print(&quot;test TestBdd:&quot;)
    def test_ccc(self):
        print(&quot;test ccc&quot;)
    def test_aaa(self):
        print(&quot;test aaa&quot;)

class TestAdd(unittest.TestCase):
    def setUp(self):
        print(&quot;test TestAdd:&quot;)
    def test_bbb(self):
        print(&quot;test bbb&quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<p>unittest 默认根据ASCII 码的顺序加载测试用例的（数字与字母的顺序为0<del>9，A</del>Z，a~z），所以TestAdd 类会优先于TestBdd 类被执行，test_aaa()方法会优先于test_ccc()方法被执行，也就是说，它并不是按照测试用例的创建顺序从上到下执行的。</p>
<p>声明测试套件TestSuite 类，通过addTest()方法按照一定的顺序来加载测试用<br>例。</p>
<p>现在的执行顺序与addTest()方法加载测试用例的顺序相同。不过，当测试用例非常多时，不推荐用这种方法创建测试套件。最好的方法是通过命名控制执行顺序</p>
<p>``</p>
<pre><code class="python">if __name__ == &#39;__main__&#39;:
    # 构造测试集
    suite = unittest.TestSuite()
    suite.addTest(TestBdd(&quot;test_aaa&quot;))
    suite.addTest(TestBdd(&quot;test_ccc&quot;))
    suite.addTest(TestAdd(&quot;test_bbb&quot;))
    # 执行测试
    runner = unittest.TextTestRunner()
    runner.run(suite)
</code></pre>
<h4 id="执行多级目录的测试用例"><a href="#执行多级目录的测试用例" class="headerlink" title="执行多级目录的测试用例"></a>执行多级目录的测试用例</h4><p>当测试用例的数量达到一定量级时，就要考虑目录划分，</p>
<p>``</p>
<pre><code>test_project
├──/test_case/
│ ├── test_bbb/
│ │ ├── test_ccc/
│ │ │ └── test_c.py
│ │ └── test_b.py
│ ├── test_ddd/
│ │ └── test_d.py
│ └── test_a.py
└─ run_tests.py
</code></pre>
<p>对于上面的目录结构，如果将discover()方法中的start_dir 参数定为“./test_case”目<br>录，那么只能加载test_a.py 文件中的测试用例。如何让unittest 查找test_case/下子目录中的测试文件呢？方法很简单，就是在每个子目录下放一个__init__.py 文件。<strong>init</strong>.py 文件的作用是将一个目录标记成一个标准的Python 模块。</p>
<h4 id="跳过测试和预期失败"><a href="#跳过测试和预期失败" class="headerlink" title="跳过测试和预期失败"></a>跳过测试和预期失败</h4><p>``</p>
<pre><code>import unittest
class MyTest(unittest.TestCase):
    @unittest.skip(&quot;直接跳过测试&quot;)  # unittest.skip(reason)无条件地跳过装饰的测试，需要说明跳过测试的原因
    def test_skip(self):
        print(&quot;test aaa&quot;)
    @unittest.skipIf(3 &gt; 2, &quot;当条件为真时跳过测试&quot;)# unittest.skipIf(condition, reason) 如果条件为真，则跳过装饰的测试。
    def test_skip_if(self):
        print(&#39;test bbb&#39;)

    @unittest.skipUnless(3 &gt; 2, &quot;当条件为真时执行测试&quot;)#unittest.skipUnless(condition, reason)当条件为真时，执行装饰的测试
    def test_skip_unless(self):
        print(&#39;test ccc&#39;)

    @unittest.expectedFailure   #unittest.expectedFailure()不管执行结果是否失败，都将测试标记为失败。
    def test_expected_failure(self):
        self.assertEqual(2, 3)

if __name__ == &#39;__main__&#39;:
        unittest.main() 
</code></pre>
<h5 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h5><pre><code class="python">import unittest
def setUpModule():
    print(&quot;test module start &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)
def tearDownModule():
    print(&quot;test module end &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)
class MyTest(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        print(&quot;test class start =======&gt;&quot;)
    @classmethod
    def tearDownClass(cls):
        print(&quot;test class end =======&gt;&quot;)
    def setUp(self):
        print(&quot;test case start --&gt;&quot;)
    def tearDown(self):
        print(&quot;test case end --&gt;&quot;)
    def test_case1(self):
        print(&quot;test case1&quot;)
    def test_case2(self):
        print(&quot;test case2&quot;)
if __name__ == &#39;__main__&#39;:
    unittest.main()

setUpModule/tearDownModule：在整个模块的开始与结束时被执行。
setUpClass/tearDownClass：在测试类的开始与结束时被执行。
setUp/tearDown：在测试用例的开始与结束时被执行。
需要注意的是，setUpClass/tearDownClass 为类方法，需要通过@classmethod 进行装饰。
另外，方法的参数为cls。其实，cls 与self 并没有什么本质区别，都只表示方法的第一个
参数。
</code></pre>
<h4 id="编写web自动化测试"><a href="#编写web自动化测试" class="headerlink" title="编写web自动化测试"></a>编写web自动化测试</h4><p>``</p>
<pre><code class="python">import unittest
from time import sleep
from selenium import webdriver
class TestBaidu(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.base_url = &quot;https://www.baidu.com&quot;

    def test_search_key_selenium(self):
        self.driver.get(self.base_url)

        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)
        title = self.driver.title
        self.assertEqual(title, &quot;selenium_百度搜索&quot;)

    def test_search_key_unittest(self):
        self.driver.get(self.base_url)

        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;unittest&quot;)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)
        title = self.driver.title
        self.assertEqual(title, &quot;unittest_百度搜索&quot;)

    def tearDown(self):
        self.driver.quit()

if __name__ == &#39;__main__&#39;:
    unittest.main()
 上面的代码不做过多介绍，都是以 unittest 创建测试类和方法的。方法中的代码是Selenium 脚本,代码存在一些问题，
</code></pre>
<p>观察上面代码可以发现，两个测试用例中的步骤是一样的，唯一的区别是搜索的关键字和断言的结果不同，使用模块化，把操作步骤封装成一个方法。</p>
<p>``</p>
<pre><code class="python">import unittest

from selenium import webdriver
from time import sleep


class TestBaidu(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)

    def test_search_key_selenium(self):
        search_key = &quot;selenium&quot;
        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)

    def test_search_key_unittest(self):
        search_key = &quot;unittest&quot;
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    def tearDown(self):
        self.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main()
#baidu_search()方法不会被当作测试用例执行，因为根据unittest 查找和执行测试用例的规则，它只会把以“test”开头的方法当作测试用例
</code></pre>
<p>减少浏览器的启动和关闭次数</p>
<p>``</p>
<pre><code class="python">import unittest
from selenium import webdriver
from time import sleep
class TestBaidu(unittest.TestCase):
    driver = None

    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)

    def test_search_key_selenium(self):
        search_key = &quot;selenium&quot;
        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)

    def test_search_key_unittest(self):
        search_key = &quot;unittest&quot;
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/" data-id="cm7yic4ka001j68vd0e9bd3pi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-unittest基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/15/unittest%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-11-15T05:14:49.000Z" itemprop="datePublished">2022-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/unittest/">unittest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/15/unittest%E5%9F%BA%E7%A1%80/">unittest单元测试框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="unittest功能"><a href="#unittest功能" class="headerlink" title="unittest功能"></a>unittest功能</h4><ol>
<li>提供测试用例组织和执行</li>
<li>提供丰富的断言方法</li>
<li>提供丰富的日志</li>
</ol>
<h4 id="基础代码实现"><a href="#基础代码实现" class="headerlink" title="基础代码实现"></a>基础代码实现</h4><p>``</p>
<pre><code class="python">import unittest
class Calculator:
    &quot;&quot;&quot; 用于完成两个数的加、减、乘、除&quot;&quot;&quot;
    def __init__(self, a, b):
        self.a = int(a)
        self.b = int(b)
    # 加法
    def add(self):
        return self.a + self.b
    # 减法
    def sub(self):
        return self.a - self.b
    # 乘法
    def mul(self):
        return self.a * self.b
    # 除法
    def div(self):
        return self.a / self.b

def test_add():
    c = Calculator(3, 5)
    result = c.add()
    assert result == 8, &#39;加法运算失败!&#39;
def test_sub():
    c = Calculator(7, 2)
    result = c.sub()
    assert result == 5, &#39;减法运算失败!&#39;
def test_mul():
    c = Calculator(3, 3)
    result = c.mul()
    assert result == 10, &#39;乘法运算失败!&#39;
def test_div():
    c = Calculator(6, 2)
    result = c.div()
    assert result == 3, &#39;除法运算失败!&#39;
if __name__ == &#39;__main__&#39;:
    test_add()
    test_sub()
    test_mul()
    test_div()
</code></pre>
<p>这样的测试存在着一些问题。首先，我们需要自己定义断言失败的提示；其次，当<br>测试函数运行失败后，后面的测试函数将不再执行；最后，执行结果无法统计    </p>
<h5 id="通过-unittest-单元测试框架重新编写测试用例"><a href="#通过-unittest-单元测试框架重新编写测试用例" class="headerlink" title="通过 unittest 单元测试框架重新编写测试用例"></a>通过 unittest 单元测试框架重新编写测试用例</h5><p>``</p>
<pre><code class="python">class TestCalculator(unittest.TestCase):
    def test_add(self):
        c = Calculator(3, 5)
        result = c.add()
        self.assertEqual(result, 8)
    def test_sub(self):
        c = Calculator(7, 2)
        result = c.sub()
        self.assertEqual(result, 5)
    def test_mul(self):
        c = Calculator(3, 3)
        result = c.mul()
        self.assertEqual(result, 10)
    def test_div(self):
        c = Calculator(6, 2)
        result = c.div()
        self.assertEqual(result, 3)
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<ol>
<li>创建一个测试类，这里为TestCalculator 类，必须要继承unittest 模块的TestCase类。</li>
<li>创建一个测试方法，该方法必须以“test”开头。</li>
<li>通过unittest 提供的assertEqual()方法来断言结果是否与预期结果相同。该方法由TestCase 父类提供，由于继承了该类，所以可以通过self 调用。</li>
<li>最后，调用unittest 的main()来执行测试用例，它会按照前面的两条规则查找测试用例并执行。</li>
</ol>
<h5 id="四个重要的概念：Test-Case、Test-Suite、Test-Runner-和Test-Fixture。"><a href="#四个重要的概念：Test-Case、Test-Suite、Test-Runner-和Test-Fixture。" class="headerlink" title="四个重要的概念：Test Case、Test Suite、Test Runner 和Test Fixture。"></a>四个重要的概念：Test Case、Test Suite、Test Runner 和Test Fixture。</h5><ol>
<li>Test Case 是最小的测试单元，用于检查特定输入集合的特定返回值。unittest 提供了TestCase 基类，我们创建的测试类需要继承该基类，它可以用来创建新的测试用例。</li>
<li>测试套件是测试用例、测试套件或两者的集合，用于组装一组要运行的测试。unittest提供了TestSuite 类来创建测试套件。</li>
<li>Test Runner 是一个组件，用于协调测试的执行并向用户提供结果。Test Runner 可以使用图形界面、文本界面或返回特殊值来展示执行测试的结果。unittest 提供了TextTestRunner类运行测试用例，为了生成HTML 格式的测试报告，后面会选择使用HTMLTestRunner 运行类。</li>
<li>Test Fixture 代表执行一个或多个测试所需的环境准备，以及关联的清理动作。例如，创建临时或代理数据库、目录，或启动服务器进程,unittest 中提供了setUp()/tearDown()、setUpClass()/tearDownClass()等方法来完成这些操作</li>
</ol>
<p>``</p>
<pre><code class="python">class TestCalculator(unittest.TestCase):
    # 测试用例前置动作
    def setUp(self):
        print(&quot;test start:&quot;)
    # 测试用例后置动作
    def tearDown(self):
        print(&quot;test end&quot;)
    def test_add(self):
        c = Calculator(3, 5)
        result = c.add()
        self.assertEqual(result, 8)
    def test_sub(self):
        c = Calculator(7, 2)
        result = c.sub()
        self.assertEqual(result, 5)

    def test_mul(self):
        c = Calculator(3, 3)
        result = c.mul()
        self.assertEqual(result, 10)

    def test_div(self):
        c = Calculator(6, 2)
        result = c.div()
        self.assertEqual(result, 3)

if __name__ == &#39;__main__&#39;:
# 创建测试套件
    suit = unittest.TestSuite()
    suit.addTest(TestCalculator(&quot;test_add&quot;))
    suit.addTest(TestCalculator(&quot;test_sub&quot;))
    suit.addTest(TestCalculator(&quot;test_mul&quot;))
    suit.addTest(TestCalculator(&quot;test_div&quot;))
# 创建测试运行器
    runner = unittest.TextTestRunner()
    runner.run(suit)
</code></pre>
<ul>
<li>首先，创建一个测试类并继承TestCase 类，在该类下面创建一条以“test”开头的方法为测试用例</li>
<li>在测试类中增加了 setUp()/tearDown()方法，用于定义测试用例的前置和后置动作。在当前测试中暂时用不上，这里定义了一些简单的打印</li>
<li>抛弃了unittest 提供的main()方法，而是调用TestSuite 类下面addTest()来添加测试用例。因为一次只能添加一条用例，所以需要指定测试类及测试方法。然后，再调用TextTestRunner 类下面的run()运行测试套件。</li>
<li>优点：相比main()方法。测试用例的执行顺序可以由测试套件的添加顺序控制，而main()方法只能按照测试类、方法的名称来执行测试用例。例如，TestA 类比TestB 类先执行，test_add()用例比test_div()用例先执行。</li>
<li>其次，当一个测试文件中有很多测试用例时，并不是每次都要执行所有的测试用例，尤其是比较耗时的UI 自动化测试。因而通过测试套件和测试运行器可以灵活地控制要执行的测试用例。</li>
</ul>
<h5 id="断言方法"><a href="#断言方法" class="headerlink" title="断言方法"></a>断言方法</h5><p>``</p>
<pre><code class="python">import unittest
class TestAssert(unittest.TestCase):
    def test_equal(self):
        self.assertEqual(2+52, 4)
        self.assertEqual(&quot;pytgn&quot;, &quot;python&quot;)
        self.assertNotEqual(&quot;hello&quot;, &quot;python&quot;)
    def test_in(self):
        self.assertIn(&quot;hello&quot;, &quot;hello world&quot;)
        self.assertNotIn(&quot;hi&quot;, &quot;hello&quot;)
    def test_true(self):
        self.assertTrue(True)
        self.assertFalse(False)
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<h5 id="测试用例的组织与discover-方法"><a href="#测试用例的组织与discover-方法" class="headerlink" title="测试用例的组织与discover 方法"></a>测试用例的组织与discover 方法</h5><p>针对 Calculator 类所编写的测试用例存在的问题：一个功能对应一条测试用例不够的；其次测试用例的划分，建议一个测试类对应一个被测试功能</p>
<p>``</p>
<pre><code class="python">class Calculator:
    &quot;&quot;&quot; 用于完成两个数的加、减、乘、除&quot;&quot;&quot;
    def __init__(self, a, b):
        self.a = int(a)
        self.b = int(b)
    # 加法
    def add(self):
        return self.a + self.b
    # 减法
    def sub(self):
        return self.a - self.b
    # 乘法
    def mul(self):
        return self.a * self.b
    # 除法
    def div(self):
        return self.a / self.b
class TestAdd(unittest.TestCase):
    &quot;&quot;&quot; add()方法测试&quot;&quot;&quot;
    def test_add_integer(self):
        &quot;&quot;&quot; 整数相加测试&quot;&quot;&quot;
        c = Calculator(3, 5)
        self.assertEqual(c.add(), 8)
    def test_add_decimals(self):
        &quot;&quot;&quot; 小数相加测试&quot;&quot;&quot;
        c = Calculator(3.2, 5.5)
        self.assertEqual(c.add(), 8)
    def test_add_string(self):
        &quot;&quot;&quot; 字符串整数相加测试&quot;&quot;&quot;
        c = Calculator(&quot;7&quot;, &quot;9&quot;)
        self.assertEqual(c.add(), 16)
    # ……

class TestSub(unittest.TestCase):
    &quot;&quot;&quot; sub()方法测试&quot;&quot;&quot;
    pass
# ……
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<h5 id="判断某年是否为闰年"><a href="#判断某年是否为闰年" class="headerlink" title="判断某年是否为闰年"></a>判断某年是否为闰年</h5><p>``</p>
<pre><code class="python">class LeapYear:
    &quot;&quot;&quot;计算某年是否为闰年&quot;&quot;&quot;
    def __init__ (self, year):
        self.year = int(year)
    def answer(self):
        year = self.year
        if year % 100 == 0:
            if year % 400 == 0:
                # 整百年能被400 整除的是闰年
                return &quot;&#123;0&#125;是闰年&quot;.format(year)
            else:
                return &quot;&#123;0&#125;不是闰年&quot;.format(year)
        else:
            if year % 4 == 0:
                # 非整百年能被4 整除的是闰年
                return &quot;&#123;0&#125;是闰年&quot;.format(year)
            else:
                return &quot;&#123;0&#125;不是闰年&quot;.format(year)



class TestLeapYear(unittest.TestCase):
    def test_2000(self):
        ly = LeapYear(2000)
        self.assertEqual(ly.answer(), &quot;2000是闰年&quot;)
    def test_2004(self):
        ly = LeapYear(2004)
        self.assertEqual(ly.answer(), &quot;2004是闰年&quot;)
    def test_2017(self):
        ly = LeapYear(2017)
        self.assertEqual(ly.answer(), &quot;2017不是闰年&quot;)
    def test_2100(self):
        ly = LeapYear(2100)
        self.assertEqual(ly.answer(), &quot;2100不是闰年&quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<h5 id="如何执行多个测试文件"><a href="#如何执行多个测试文件" class="headerlink" title="如何执行多个测试文件"></a>如何执行多个测试文件</h5><p>unittest 中的TestLoader 类提供的discover()方法可以从多个文件中查找测试用例。</p>
<p>该类根据各种标准加载测试用例，并将它们返回给测试套件。正常情况下，不需要创建这个类的实例。unittest 提供了可以共享的defaultTestLoader 类，可以使用其子类或方法创建实例，discover()方法就是其中之一。</p>
<pre><code class="python">discover(start_dir，pattern=&#39;test*.py&#39;，top_level_dir=None)
找到指定目录及其子目录下的所有测试模块，只有匹配的文件名才能被加载。如果启动的不是顶层目录，那么顶层目录必须单独指定。
    start_dir ：待测试的模块名或测试用例目录。
    pattern=&#39;test*.py&#39; ：测试用例文件名的匹配原则。此处匹配文件名以“test”开头的“.py”类型的文件，星号“*”表示任意多个字符。
    top_level_dir=None：测试模块的顶层目录，如果没有顶层目录，则默认为None。
</code></pre>
<pre><code class="python">import unittest
test_dir = &#39;../test1107&#39;
suits = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_unit*.py&#39;)
if __name__ == &#39;__main__&#39;:
    runner = unittest.TextTestRunner()
    runner.run(suits)
</code></pre>
<p>discover()方法会自动根据测试用例目录（test_dir）查找测试用例文件（test*.py），并将找到的测试用例添加到测试套件中，因此，可以直接通过run()方法执行测试套件suits。这种方式极大地简化了测试用例的查找，我们需要做的就是按照文件的匹配规则创建测试文件即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/15/unittest%E5%9F%BA%E7%A1%80/" data-id="cm7yic4k9001f68vdbumi8r5m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jmeter/">jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%9F%BA%E7%A1%80/">linux基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/pytest/">pytest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/selenium/">selenium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/unittest/">unittest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%84%E7%90%86Excel%E6%96%87%E4%BB%B6/">处理Excel文件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/">接口测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrony/" rel="tag">Chrony</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Excel/" rel="tag">Excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csv/" rel="tag">csv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" rel="tag">jmeter_cookie处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" rel="tag">jmeter参数化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4/" rel="tag">linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql%E6%9D%83%E9%99%90/" rel="tag">mysql权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ntpd/" rel="tag">ntpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest/" rel="tag">pytest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" rel="tag">selenium多窗口_警告框处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%AE%9A%E4%BD%8D/" rel="tag">selenium定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" rel="tag">selenium时间等待</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" rel="tag">接口基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="tag">类与对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Chrony/" style="font-size: 10px;">Chrony</a> <a href="/tags/Excel/" style="font-size: 13.33px;">Excel</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/csv/" style="font-size: 10px;">csv</a> <a href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" style="font-size: 10px;">jmeter_cookie处理</a> <a href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" style="font-size: 10px;">jmeter参数化</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">linux命令</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/mysql%E6%9D%83%E9%99%90/" style="font-size: 10px;">mysql权限</a> <a href="/tags/ntpd/" style="font-size: 10px;">ntpd</a> <a href="/tags/pytest/" style="font-size: 10px;">pytest</a> <a href="/tags/pytest%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">pytest基础</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" style="font-size: 10px;">selenium多窗口_警告框处理</a> <a href="/tags/selenium%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">selenium定位</a> <a href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" style="font-size: 10px;">selenium时间等待</a> <a href="/tags/unittest%E6%A6%82%E5%BF%B5/" style="font-size: 13.33px;">unittest概念</a> <a href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">接口基础</a> <a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 20px;">类与对象</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE/">服务器同步时间配置</a>
          </li>
        
          <li>
            <a href="/2025/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/">mysql数据库插入数据</a>
          </li>
        
          <li>
            <a href="/2025/03/03/%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B0%81%E8%A3%85%E5%B1%9E%E6%80%A7%E5%90%8D/">在类中封装属性名</a>
          </li>
        
          <li>
            <a href="/2025/03/03/%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/">对象支持上下文管理协议</a>
          </li>
        
          <li>
            <a href="/2025/03/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/">自定义字符串的格式化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 当时只道是寻常<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>