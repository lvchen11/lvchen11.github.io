<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>月明星稀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="太阳当空照，花儿爱微笑">
<meta property="og:type" content="website">
<meta property="og:title" content="月明星稀">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="月明星稀">
<meta property="og:description" content="太阳当空照，花儿爱微笑">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="当时只道是寻常">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="月明星稀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">月明星稀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-pytest基础2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/23/pytest%E5%9F%BA%E7%A1%802/" class="article-date">
  <time datetime="2023-02-23T02:16:19.000Z" itemprop="datePublished">2023-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pytest/">pytest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/23/pytest%E5%9F%BA%E7%A1%802/">pytest基础2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="pytest用法一"><a href="#pytest用法一" class="headerlink" title="pytest用法一"></a>pytest用法一</h4><pre><code class="python">前置条件：
1.文件路径：
Test_App
    - - test_abc.py
    - - pytest.ini
2.pyetst.ini配置文件内容：
[pytest]
  命令行参数
 addopts = -s
 搜索文件名
 python_files = test*.py
  搜索的类名
 python_classes = Test*
搜索的函数名
 python_functions = test_*
</code></pre>
<h5 id="pytest之fixture"><a href="#pytest之fixture" class="headerlink" title="pytest之fixture"></a>pytest之fixture</h5><p>fixture修饰器来标记固定的工厂函数,在其他函数，模块，类或整个工程调用它时会被激活并优先执行,通常会被用于完成预置处理和重复操作。</p>
<pre><code class="python">方法：fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None)
常用参数：
scope: 被标记方法的作用域
&quot;function&quot;(default): 作用于每个测试方法，每个test都运行一次
&quot;class&quot;: 作用于整个类，每个class的所有test只运行一次
&quot;module&quot;: 作用于整个模块，每个module的所有test只运行一次
&quot;session&quot;: 作用于整个session,每个session只运行一次
 params：(list类型)提供参数数据，供调用标记方法的函数使用
 autouse：是否自动运行,默认为False不运行，设置为True自动运行
</code></pre>
<h5 id="fixture第一个例子（通过参数引用）"><a href="#fixture第一个例子（通过参数引用）" class="headerlink" title="fixture第一个例子（通过参数引用）"></a>fixture第一个例子（通过参数引用）</h5><pre><code class="python">class Test_ABC:
    @pytest.fixture()
    def before(self):
        print(&quot;-------&gt;before&quot;)
    def test_a(self,before): # ️ test_a方法传入了被fixture标识的函数，已变量的形式
        print(&quot;-------&gt;test_a&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果：发现before会优先于测试函数运行
test0223.py::Test_ABC::test_a -------&gt;before
PASSED                                     [100%]-------&gt;test_a
</code></pre>
<h5 id="fixture第二个例子（通过函数引用）"><a href="#fixture第二个例子（通过函数引用）" class="headerlink" title="fixture第二个例子（通过函数引用）"></a>fixture第二个例子（通过函数引用）</h5><pre><code class="python">import pytest
@pytest.fixture() # fixture标记的函数可以应用于测试类外部
def before():
    print(&quot;-------&gt;before&quot;)
@pytest.mark.usefixtures(&quot;before&quot;)
class Test_ABC:
    def setup(self):
        print(&quot;-------&gt;setup&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
          pytest.main(&quot;-s  test_abc.py&quot;)
  执行结果：
      test_abc.py 
      -------&gt;before # 发现before会优先于测试类运行
      -------&gt;setup
      -------&gt;test_a
      .
</code></pre>
<h5 id="fixture第三个例子（默认设置为运行）"><a href="#fixture第三个例子（默认设置为运行）" class="headerlink" title="fixture第三个例子（默认设置为运行）"></a>fixture第三个例子（默认设置为运行）</h5><pre><code class="python">import pytest
@pytest.fixture(autouse=True) # 设置为默认运行
def before():
 print(&quot;-------&gt;before&quot;)
class Test_ABC:
 def setup(self):
     print(&quot;-------&gt;setup&quot;)
 def test_a(self):
     print(&quot;-------&gt;test_a&quot;)
     assert 1
if __name__ == &#39;__main__&#39;:
 pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果：
test0223.py::Test_ABC::test_a -------&gt;before #发现before自动优先于测试类运行
-------&gt;setup
PASSED                                     [100%]-------&gt;test_a
</code></pre>
<h5 id="fixture第四个例子-设置作用域为function"><a href="#fixture第四个例子-设置作用域为function" class="headerlink" title="fixture第四个例子(设置作用域为function)"></a>fixture第四个例子(设置作用域为function)</h5><pre><code class="python">import pytest
@pytest.fixture(scope=&#39;function&#39;,autouse=True) # 作用域设置为function，自动运行
def before():
    print(&quot;-------&gt;before&quot;)
class Test_ABC:
    def setup(self):
        print(&quot;-------&gt;setup&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
    def test_b(self):
        print(&quot;-------&gt;test_b&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果：
test0223.py::Test_ABC::test_a -------&gt;before # 运行第一次
-------&gt;setup
PASSED                                     [ 50%]-------&gt;test_a

test0223.py::Test_ABC::test_b -------&gt;before # 运行第二次
-------&gt;setup
PASSED                                     [100%]-------&gt;test_b
</code></pre>
<h5 id="fixture第五个例子-设置作用域为class"><a href="#fixture第五个例子-设置作用域为class" class="headerlink" title="fixture第五个例子(设置作用域为class)"></a>fixture第五个例子(设置作用域为class)</h5><pre><code class="python">import pytest
@pytest.fixture(scope=&#39;class&#39;,autouse=True) # 作用域设置为class，自动运行
def before():
    print(&quot;-------&gt;before&quot;)
class Test_ABC:
    def setup(self):
        print(&quot;-------&gt;setup&quot;)
    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1
    def test_b(self):
        print(&quot;-------&gt;test_b&quot;)
        assert 1
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果
test0223.py::Test_ABC::test_a -------&gt;before  # 发现只运行一次
-------&gt;setup
PASSED                                     [ 50%]-------&gt;test_a

test0223.py::Test_ABC::test_b -------&gt;setup
PASSED                                     [100%]-------&gt;test_b
</code></pre>
<h5 id="fixture第六个例子-返回值"><a href="#fixture第六个例子-返回值" class="headerlink" title="fixture第六个例子(返回值)"></a>fixture第六个例子(返回值)</h5><pre><code class="python">import pytest
@pytest.fixture()
def need_data():
    return 2  # 返回数字2
class Test_ABC:
    def test_a(self, need_data):
        print(&quot;-------&gt;test_a&quot;)
        assert need_data != 3  # 拿到返回值做一次断言
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
 # 执行结果
    test_abc.py 
    -------&gt;test_a
    .
</code></pre>
<pre><code class="python"># 示例二
import pytest
@pytest.fixture(params=[1, 2, 3])
def need_data(request):  # 传入参数request 系统封装参数
    return request.param  # 取列表中单个值，默认的取值方式
class Test_ABC:
     def test_a(self, need_data):
        print(&quot;-------&gt;test_a&quot;)
        assert need_data != 3  # 断言need_data不等于3
if __name__ == &#39;__main__&#39;:
    pytest.main(&quot;-s  test_abc.py&quot;)
# 执行结果运行了三次
PASSED                                  [ 33%]-------&gt;test_a
PASSED                                  [ 66%]-------&gt;test_a
FAILED                                  [100%]-------&gt;test_a

test0223.py:10 (Test_ABC.test_a[3])
self = &lt;test0223.Test_ABC object at 0x000001F7D83E8550&gt;, need_data = 3

    def test_a(self, need_data):
        print(&quot;-------&gt;test_a&quot;)
&gt;       assert need_data != 3  # 断言need_data不等于3
E       assert 3 != 3

test0223.py:13: AssertionError
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/23/pytest%E5%9F%BA%E7%A1%802/" data-id="cm7lnedwn000ih4vd91177ego" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pytest基础1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/22/pytest%E5%9F%BA%E7%A1%801/" class="article-date">
  <time datetime="2023-02-22T09:50:34.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pytest/">pytest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/22/pytest%E5%9F%BA%E7%A1%801/">pytest基础1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="pytest框架约束"><a href="#pytest框架约束" class="headerlink" title="pytest框架约束"></a>pytest框架约束</h4><p>1.所有的单测文件名都需要满足test_*.py格式或*_test.py格式。<br>2.在单测文件中，测试类以Test开头，并且不能带有 init 方法(注意：定义class时，需要以T开头，不然pytest是不会去运行该class的)<br>3.在单测类中，可以包含一个或多个test_开头的函数。此时，在执行pytest命令时，会自动从当前目录及子目录中寻找符合上述约束的测试函数来执行。</p>
<h5 id="控制测试用例执行"><a href="#控制测试用例执行" class="headerlink" title="控制测试用例执行"></a>控制测试用例执行</h5><p>1.在第N个用例失败后，结束测试执行</p>
<p>pytest -x                    # 第01次失败，就停止测试<br>pytest –maxfail=2     # 出现2个失败就终止测试</p>
<p>2.指定测试模式    pytest test_mod.py</p>
<p>3.指定测试目录    pytest    ./test/</p>
<p>4.通过node id 指定测试用例 ，nodeid由模块文件名、分隔符、类名、方法名、参数构成，                pytest test_mod.py::test_func</p>
<p>运行模块中的指定方法：pytest test_mod.py::TestClass::test_method</p>
<p>5.通过标记表达式执行  pytest -m slow   会执行被装饰器@pytest.mark.slow装饰的所有测试用例</p>
<p>6、通过包执行测试        pytest –pyargs pkg.testing  这条命令会自动导入包pkg.testing,并使用该包所在的目录，执行下面的用例</p>
<h4 id="其它运行方法"><a href="#其它运行方法" class="headerlink" title="其它运行方法"></a>其它运行方法</h4><p>1.多进程运行cases,当cases量很多时，运行时间也会变的很长，如果想缩短脚本运行的时长，就可以用多进程来运行。</p>
<p>安装pytest-xdist: pip install -U pytest-xdist</p>
<p>运行模式：pytest test_demo1.py -n NUM</p>
<p>2.重试运行cases:  在做接口测试时，有事会遇到503或短时的网络波动，导致case运行失败，而这并非是我们期望的结果，此时可以就可以通过重试运行cases的方式来解决。</p>
<p>安装pytest-rerunfailures：pip install -U pytest-rerunfailures</p>
<p>pytest test_se.py –reruns NUM</p>
<p>3.显示print内容：在运行测试脚本时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是在运行pytest时，这些内容不会显示出来。如果带上-s，就可以显示了。</p>
<p>pytest test_se.py -s -n 4</p>
<h5 id="pytest的set和teardown函数"><a href="#pytest的set和teardown函数" class="headerlink" title="pytest的set和teardown函数"></a>pytest的set和teardown函数</h5><p>1.setup和teardown主要分为：模块级，类，功能，函数级</p>
<p>函数级别setup()和teardown():运行于测试方法的始末</p>
<p>运行一次函数会运行一次setup和teardown</p>
<pre><code class="python">import pytest
class Test_ABC:
  # 函数级开始
  def setup(self):
      print(&quot;-------&gt;setup_method&quot;)
  # 函数级结束
  def teardown(self):
      print(&quot;-------&gt;teardown_method&quot;)
  def test_a(self):
      print(&quot;-------&gt;test_a&quot;)
      assert 1
  def test_b(self):
      print(&quot;-------&gt;test_b&quot;)
if __name__ == &#39;__main__&#39;:
              pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>
<pre><code class="python">执行结果：
test0223.py::Test_ABC::test_a -------&gt;setup_method
PASSED                                     [ 50%]-------&gt;test_a
-------&gt;teardown_method

test0223.py::Test_ABC::test_b -------&gt;setup_method
PASSED                                     [100%]-------&gt;test_b
-------&gt;teardown_method
</code></pre>
<p>类级别：运行于测试类的始末，即:在一个测试内只运行一次setup_class和teardown_class，不关心测试类内有多少个测试函数。</p>
<pre><code class="python">import pytest
class Test_ABC:
   # 测试类级开始
   def setup_class(self):
       print(&quot;-------&gt;setup_class&quot;)
   # 测试类级结束
   def teardown_class(self):
       print(&quot;-------&gt;teardown_class&quot;)
   def test_a(self):
       print(&quot;-------&gt;test_a&quot;)
       assert 1
   def test_b(self):
       print(&quot;-------&gt;test_b&quot;)
if __name__ == &#39;__main__&#39;:
  pytest.main(&quot;-s  test_abc.py&quot;)

执行结果：
test0223.py::Test_ABC::test_a -------&gt;setup_class  #第一次setup_class()
PASSED                                     [ 50%]-------&gt;test_a

test0223.py::Test_ABC::test_b PASSED                                     [100%]-------&gt;test_b
-------&gt;teardown_class    # 第一次teardown_class()
</code></pre>
<h5 id="Pytest配置文件"><a href="#Pytest配置文件" class="headerlink" title="Pytest配置文件"></a>Pytest配置文件</h5><p>pytest的配置文件通常放在测试目录下，名称为pytest.ini，命令行运行时会使用该配置文件中的配置.</p>
<pre><code class="python"># 配置pytest命令行运行参数
[pytest]
addopts = -s...  # 空格分隔，可添加多个命令行参数 -所有参数均为插件包的参数配置测试搜索的路径
testpaths =./ scripts  # 当前目录下的scripts文件夹 -可自定义
# 配置测试搜索的文件名称
python_files = test *.py
# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件 -可自定义
配置测试搜索的测试类名
python_classes = Test_ *

# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件中，以Test开头的类 -可自定义
配置测试搜索的测试函数名

python_functions = test_ *

# 当前目录下的scripts文件夹下，以test开头，以.py结尾的所有文件中，以Test开头的类内，以test_开头的方法 -可自定义
# 前置条件
    - Test_App
    - - test_abc.py
    - - pytest.ini
# pytest.ini的配置文件内容
      [pytest]
    # 命令行参数
     addopts = -s
    # 搜索文件名
     python_files = test_*.py
     # 搜索的类名
     python_classes = Test_*
     #搜索的函数名
        python_functions = test_*
</code></pre>
<h5 id="pytest测试报告"><a href="#pytest测试报告" class="headerlink" title="pytest测试报告"></a>pytest测试报告</h5><pre><code class="text">pytest-HTML是一个插件，pytest用于生成测试结果的HTML报告
安装方式：pip install pytest-html                   pip install pytest-html
通过命令行方式，生成xm l /html格式的测试报告，存储于用户指定路径。插件名称：pytes t -html
使用方法： 命令行格式：pytest --html = 用户路径 / report.html
</code></pre>
<pre><code class="python">import pytest


class Test_ABC:
    def setup_class(self):
        print(&quot;-------&gt;setup_class&quot;)

    def teardown_class(self):
        print(&quot;-------&gt;teardown_class&quot;)

    def test_a(self):
        print(&quot;-------&gt;test_a&quot;)
        assert 1

    def test_b(self):
        print(&quot;-------&gt;test_b&quot;)
        assert 0  # 断言失败```

运行方式：
1.
修改Test_App / pytest.ini文件，添加报告参数，即：addopts = -s - -html =./ report.html
# -s:输出程序运行信息
# --html=./report.html 在当前目录下生成report.html文件
️
若要生成xml文件，可将 - -html =./ report.html
改成 - -html =./ report.xml
2.
命令行进入Test_App目录
3.
执行命令： pytest
执行结果：
1.
在当前目录会生成assets文件夹和report.html文件
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/22/pytest%E5%9F%BA%E7%A1%801/" data-id="cm7lnedwn000kh4vd6mjdgh2w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTML测试报告" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" class="article-date">
  <time datetime="2022-11-21T05:50:48.000Z" itemprop="datePublished">2022-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/unittest/">unittest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/">HTML测试报告</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="HTML下载与安装"><a href="#HTML下载与安装" class="headerlink" title="HTML下载与安装"></a>HTML下载与安装</h4><p>HTMLTestRunner.py 文件，既可以把它当作Python 的第三方库来使用，也可以将把它当作项目的一部分来使用。建议将该文件放到python的lib目录下；如果把 HTMLTestRunner 当作项目的一部分来使用，就把它放到项目目录中。可以方便地定制生成的HTMLTestRunner 报告,文件目录结构如下：</p>
<p><img src="/.com//../imags/$%7Bfiilename%7D/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-16690114393791.jpg"></p>
<pre><code class="python">#test_unittest1.py文件
import unittest
from selenium import webdriver
from time import sleep

class TestBaidu(unittest.TestCase):
    driver = None

    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)

    def test_search_key_selenium(self):
        &quot;&quot;&quot;&quot; 搜索关键字：selenium &quot;&quot;&quot;  # 加了注释的测试报告
        search_key = &quot;selenium&quot;
        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)

    def test_search_key_unittest(self):
        &quot;&quot;&quot; 搜索关键字：unittest&quot;&quot;&quot;
        search_key = &quot;unittest&quot;
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main()



</code></pre>
<pre><code class="python">#run_tests.py文件
import unittest
from HTMLTestRunner import HTMLTestRunner
import time

# 定义测试用例的目录为当前目录下的test_case 目录
test_dir = &#39;./test_case&#39;
suit = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;)

# if __name__ == &#39;__main__&#39;:
#     # 生成HTML 格式的报告
#     fp = open(&#39;./test_report/result.html&#39;, &#39;wb&#39;)
#     runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)
#     runner.run(suit)
#     fp.close()


if __name__ == &#39;__main__&#39;:
    # 取当前日期时间，修改测试报告名称，确保测试报告不会被覆盖
    # strftime()方法以指定的格式获取当前日期时间
    now_time = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)
    fp = open(&#39;./test_report/&#39;+ now_time +&#39;result.html&#39;, &#39;wb&#39;)
    runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)
    runner.run(suit)
    fp.close()
</code></pre>
<h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><pre><code class="python">import codecs
import csv
import unittest
from itertools import islice
from time import sleep

from selenium import webdriver
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
        cls.test_data = []
        with codecs.open(&#39;data.csv&#39;, &#39;r&#39;, &#39;utf_8_sig&#39;) as f:
            data = csv.reader(f)
            for line in islice(data, 1, None):
                cls.test_data.append(line)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(3)
    def test_search_selenium(self):
        self.baidu_search(self.test_data[0][1])
    def test_search_unittest(self):
        self.baidu_search(self.test_data[1][1])
    def test_search_parameterized(self):
        self.baidu_search(self.test_data[2][1])
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
    verbosity是一个选项,表示测试结果的信息复杂度，有0、1、2 三个值
    0 (静默模式): 你只能获得总的测试用例数和总的结果 比如 总共10个 失败2 成功8
    1 (默认模式): 非常类似静默模式 只是在每个成功的用例前面有个“.” 每个失败的用例前面有个 “F”
    2 (详细模式):测试结果会显示每个测试用例的所有相关的信息
    并且 你在命令行里加入不同的参数可以起到一样的效果
    加入 --quiet 参数 等效于 verbosity=0
    加入--verbose参数等效于 verbosity=2
    什么都不加就是 verbosity=1
</code></pre>
<h4 id="Parameterized"><a href="#Parameterized" class="headerlink" title="Parameterized"></a>Parameterized</h4><pre><code class="python">import unittest
from time import sleep
from selenium import webdriver
from parameterized import parameterized
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)
    # 通过Parameterized 实现参数化
    @parameterized.expand([
    (&quot;case1&quot;, &quot;selenium&quot;),
    (&quot;case2&quot;, &quot;unittest&quot;),
    (&quot;case3&quot;, &quot;parameterized&quot;),
    ])
    def test_search(self, name, search_key):
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
</code></pre>
<h4 id="DDT"><a href="#DDT" class="headerlink" title="DDT"></a>DDT</h4><pre><code class="python">#列举了三组参数化，第一组为列表，第二组为元组，第三组为字典。需要注意的是，字典的key与测试方法的参数要保持一致。
import unittest
from time import sleep

from selenium import webdriver
from ddt import ddt, data, file_data, unpack
@ddt
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(3)
    # 参数化使用方式一
    @data([&quot;case1&quot;, &quot;selenium&quot;], [&quot;case2&quot;, &quot;ddt&quot;], [&quot;case3&quot;, &quot;python&quot;])
    @unpack
    def test_search1(self, case, search_key):
        print(&quot;第一组测试用例：&quot;, case)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    # 参数化使用方式二
    @data((&quot;case1&quot;, &quot;selenium&quot;), (&quot;case2&quot;, &quot;ddt&quot;), (&quot;case3&quot;, &quot;python&quot;))
    @unpack
    def test_search2(self, case, search_key):
        print(&quot;第二组测试用例：&quot;, case)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    # 参数化使用方式三
    @data(&#123;&quot;search_key&quot;: &quot;selenium&quot;&#125;, &#123;&quot;search_key&quot;: &quot;ddt&quot;&#125;, &#123;&quot;search_key&quot;:
    &quot;python&quot;&#125;)
    @unpack
    def test_search3(self, search_key):
        print(&quot;第三组测试用例：&quot;, search_key)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
</code></pre>
<p>DDT 同样支持数据文件的参数化。它封装了数据文件的读取,不需要关心数据文件是如何被读取进来的</p>
<pre><code class="python">#创建ddt_data_file.json文件
&#123;
&quot;case1&quot;: &#123;&quot;search_key&quot;: &quot;python1&quot;&#125;,
&quot;case2&quot;: &#123;&quot;search_key&quot;: &quot;ddt1&quot;&#125;,
&quot;case3&quot;: &#123;&quot;search_key&quot;: &quot;Selenium1&quot;&#125;
&#125;
</code></pre>
<pre><code class="python">import unittest
from time import sleep

from selenium import webdriver
from ddt import ddt, data, file_data, unpack
@ddt
class TestBaidu(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(3)
        
    @file_data(&#39;ddt_data_file.json&#39;)
    def test_search4(self, search_key):
        print(&quot;第四组测试用例：&quot;, search_key)
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main(verbosity=2)
</code></pre>
<p>DDT 还支持yaml 格式的数据文件</p>
<pre><code class="python">case1:
- search_key: &quot;python&quot;
case2:
- search_key: &quot;ddt&quot;
case3:
- search_key: &quot;unittest&quot;
</code></pre>
<pre><code class="python">@file_data(&#39;ddt_data_file.yaml&#39;)
def test_search5(self, case):
search_key = case[0][&quot;search_key&quot;]
print(&quot;第五组测试用例：&quot;, search_key)
self.baidu_search(search_key)
self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
</code></pre>
<h4 id="自动发送邮件功能"><a href="#自动发送邮件功能" class="headerlink" title="自动发送邮件功能"></a>自动发送邮件功能</h4><pre><code class="python">import time
import unittest
import yagmail
from HTMLTestRunner import HTMLTestRunner
#把测试报告作为附件发送到指定邮箱
def send_mail(report):
    yag = yagmail.SMTP(user=&quot;sender@126.com&quot;,
    password=&quot;a123456&quot;,
    host=&#39;smtp.126.com&#39;)
    subject = &quot;主题，自动化测试报告&quot;
    contents = &quot;正文，请查看附件。&quot;
    yag.send(&#39;receiver@126.com&#39;, subject, contents, report)
    print(&#39;email has send out !&#39;)
if __name__ == &#39;__main__&#39;:
    # 定义测试用例的目录为当前目录
    test_dir = &#39;./test_case&#39;
    suit = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;)
    # 获取当前日期和时间
    now_time = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)
    html_report = &#39;./test_report/&#39; + now_time + &#39;result.html&#39;
    fp = open(html_report, &#39;wb&#39;)
    # 调用HTMLTestRunner，运行测试用例
    runner = HTMLTestRunner(stream=fp,title=&quot;百度搜索测试报告&quot;,description=&quot;运行环境：Windows 10, Chrome 浏览器&quot;)
    runner.run(suit)
    fp.close()
    send_mail(html_report)  # 发送报告
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/HTML%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/" data-id="cm7lnedwd0001h4vd3bk78f0u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-unittest执行用例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/" class="article-date">
  <time datetime="2022-11-18T02:26:22.000Z" itemprop="datePublished">2022-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/unittest/">unittest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/">unittest执行用例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="测试用例的执行顺序"><a href="#测试用例的执行顺序" class="headerlink" title="测试用例的执行顺序"></a>测试用例的执行顺序</h4><p>测试用例的执行顺序涉及多个层级：多个测试目录&gt;多个测试文件&gt;多个测试类&gt;多个测试方法（测试用例）</p>
<p>``</p>
<pre><code class="python">import unittest
class TestBdd(unittest.TestCase):
    def setUp(self):
        print(&quot;test TestBdd:&quot;)
    def test_ccc(self):
        print(&quot;test ccc&quot;)
    def test_aaa(self):
        print(&quot;test aaa&quot;)

class TestAdd(unittest.TestCase):
    def setUp(self):
        print(&quot;test TestAdd:&quot;)
    def test_bbb(self):
        print(&quot;test bbb&quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<p>unittest 默认根据ASCII 码的顺序加载测试用例的（数字与字母的顺序为0<del>9，A</del>Z，a~z），所以TestAdd 类会优先于TestBdd 类被执行，test_aaa()方法会优先于test_ccc()方法被执行，也就是说，它并不是按照测试用例的创建顺序从上到下执行的。</p>
<p>声明测试套件TestSuite 类，通过addTest()方法按照一定的顺序来加载测试用<br>例。</p>
<p>现在的执行顺序与addTest()方法加载测试用例的顺序相同。不过，当测试用例非常多时，不推荐用这种方法创建测试套件。最好的方法是通过命名控制执行顺序</p>
<p>``</p>
<pre><code class="python">if __name__ == &#39;__main__&#39;:
    # 构造测试集
    suite = unittest.TestSuite()
    suite.addTest(TestBdd(&quot;test_aaa&quot;))
    suite.addTest(TestBdd(&quot;test_ccc&quot;))
    suite.addTest(TestAdd(&quot;test_bbb&quot;))
    # 执行测试
    runner = unittest.TextTestRunner()
    runner.run(suite)
</code></pre>
<h4 id="执行多级目录的测试用例"><a href="#执行多级目录的测试用例" class="headerlink" title="执行多级目录的测试用例"></a>执行多级目录的测试用例</h4><p>当测试用例的数量达到一定量级时，就要考虑目录划分，</p>
<p>``</p>
<pre><code>test_project
├──/test_case/
│ ├── test_bbb/
│ │ ├── test_ccc/
│ │ │ └── test_c.py
│ │ └── test_b.py
│ ├── test_ddd/
│ │ └── test_d.py
│ └── test_a.py
└─ run_tests.py
</code></pre>
<p>对于上面的目录结构，如果将discover()方法中的start_dir 参数定为“./test_case”目<br>录，那么只能加载test_a.py 文件中的测试用例。如何让unittest 查找test_case/下子目录中的测试文件呢？方法很简单，就是在每个子目录下放一个__init__.py 文件。<strong>init</strong>.py 文件的作用是将一个目录标记成一个标准的Python 模块。</p>
<h4 id="跳过测试和预期失败"><a href="#跳过测试和预期失败" class="headerlink" title="跳过测试和预期失败"></a>跳过测试和预期失败</h4><p>``</p>
<pre><code>import unittest
class MyTest(unittest.TestCase):
    @unittest.skip(&quot;直接跳过测试&quot;)  # unittest.skip(reason)无条件地跳过装饰的测试，需要说明跳过测试的原因
    def test_skip(self):
        print(&quot;test aaa&quot;)
    @unittest.skipIf(3 &gt; 2, &quot;当条件为真时跳过测试&quot;)# unittest.skipIf(condition, reason) 如果条件为真，则跳过装饰的测试。
    def test_skip_if(self):
        print(&#39;test bbb&#39;)

    @unittest.skipUnless(3 &gt; 2, &quot;当条件为真时执行测试&quot;)#unittest.skipUnless(condition, reason)当条件为真时，执行装饰的测试
    def test_skip_unless(self):
        print(&#39;test ccc&#39;)

    @unittest.expectedFailure   #unittest.expectedFailure()不管执行结果是否失败，都将测试标记为失败。
    def test_expected_failure(self):
        self.assertEqual(2, 3)

if __name__ == &#39;__main__&#39;:
        unittest.main() 
</code></pre>
<h5 id="Fixture"><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h5><pre><code class="python">import unittest
def setUpModule():
    print(&quot;test module start &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)
def tearDownModule():
    print(&quot;test module end &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)
class MyTest(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        print(&quot;test class start =======&gt;&quot;)
    @classmethod
    def tearDownClass(cls):
        print(&quot;test class end =======&gt;&quot;)
    def setUp(self):
        print(&quot;test case start --&gt;&quot;)
    def tearDown(self):
        print(&quot;test case end --&gt;&quot;)
    def test_case1(self):
        print(&quot;test case1&quot;)
    def test_case2(self):
        print(&quot;test case2&quot;)
if __name__ == &#39;__main__&#39;:
    unittest.main()

setUpModule/tearDownModule：在整个模块的开始与结束时被执行。
setUpClass/tearDownClass：在测试类的开始与结束时被执行。
setUp/tearDown：在测试用例的开始与结束时被执行。
需要注意的是，setUpClass/tearDownClass 为类方法，需要通过@classmethod 进行装饰。
另外，方法的参数为cls。其实，cls 与self 并没有什么本质区别，都只表示方法的第一个
参数。
</code></pre>
<h4 id="编写web自动化测试"><a href="#编写web自动化测试" class="headerlink" title="编写web自动化测试"></a>编写web自动化测试</h4><p>``</p>
<pre><code class="python">import unittest
from time import sleep
from selenium import webdriver
class TestBaidu(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.base_url = &quot;https://www.baidu.com&quot;

    def test_search_key_selenium(self):
        self.driver.get(self.base_url)

        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)
        title = self.driver.title
        self.assertEqual(title, &quot;selenium_百度搜索&quot;)

    def test_search_key_unittest(self):
        self.driver.get(self.base_url)

        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;unittest&quot;)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)
        title = self.driver.title
        self.assertEqual(title, &quot;unittest_百度搜索&quot;)

    def tearDown(self):
        self.driver.quit()

if __name__ == &#39;__main__&#39;:
    unittest.main()
 上面的代码不做过多介绍，都是以 unittest 创建测试类和方法的。方法中的代码是Selenium 脚本,代码存在一些问题，
</code></pre>
<p>观察上面代码可以发现，两个测试用例中的步骤是一样的，唯一的区别是搜索的关键字和断言的结果不同，使用模块化，把操作步骤封装成一个方法。</p>
<p>``</p>
<pre><code class="python">import unittest

from selenium import webdriver
from time import sleep


class TestBaidu(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)

    def test_search_key_selenium(self):
        search_key = &quot;selenium&quot;
        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)

    def test_search_key_unittest(self):
        search_key = &quot;unittest&quot;
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    def tearDown(self):
        self.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main()
#baidu_search()方法不会被当作测试用例执行，因为根据unittest 查找和执行测试用例的规则，它只会把以“test”开头的方法当作测试用例
</code></pre>
<p>减少浏览器的启动和关闭次数</p>
<p>``</p>
<pre><code class="python">import unittest
from selenium import webdriver
from time import sleep
class TestBaidu(unittest.TestCase):
    driver = None

    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Chrome()
        cls.base_url = &quot;https://www.baidu.com&quot;
    def baidu_search(self, search_key):
        self.driver.get(self.base_url)
        self.driver.find_element_by_id(&quot;kw&quot;).send_keys(search_key)
        self.driver.find_element_by_id(&quot;su&quot;).click()
        sleep(2)

    def test_search_key_selenium(self):
        search_key = &quot;selenium&quot;
        self.baidu_search(search_key) # 调用baidu_search方法，直接传入search_key
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)

    def test_search_key_unittest(self):
        search_key = &quot;unittest&quot;
        self.baidu_search(search_key)
        self.assertEqual(self.driver.title, search_key + &quot;_百度搜索&quot;)
    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/18/unittest%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B/" data-id="cm7lnedwv001fh4vd5y640cwe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-unittest基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/15/unittest%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-11-15T05:14:49.000Z" itemprop="datePublished">2022-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/unittest/">unittest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/15/unittest%E5%9F%BA%E7%A1%80/">unittest单元测试框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="unittest功能"><a href="#unittest功能" class="headerlink" title="unittest功能"></a>unittest功能</h4><ol>
<li>提供测试用例组织和执行</li>
<li>提供丰富的断言方法</li>
<li>提供丰富的日志</li>
</ol>
<h4 id="基础代码实现"><a href="#基础代码实现" class="headerlink" title="基础代码实现"></a>基础代码实现</h4><p>``</p>
<pre><code class="python">import unittest
class Calculator:
    &quot;&quot;&quot; 用于完成两个数的加、减、乘、除&quot;&quot;&quot;
    def __init__(self, a, b):
        self.a = int(a)
        self.b = int(b)
    # 加法
    def add(self):
        return self.a + self.b
    # 减法
    def sub(self):
        return self.a - self.b
    # 乘法
    def mul(self):
        return self.a * self.b
    # 除法
    def div(self):
        return self.a / self.b

def test_add():
    c = Calculator(3, 5)
    result = c.add()
    assert result == 8, &#39;加法运算失败!&#39;
def test_sub():
    c = Calculator(7, 2)
    result = c.sub()
    assert result == 5, &#39;减法运算失败!&#39;
def test_mul():
    c = Calculator(3, 3)
    result = c.mul()
    assert result == 10, &#39;乘法运算失败!&#39;
def test_div():
    c = Calculator(6, 2)
    result = c.div()
    assert result == 3, &#39;除法运算失败!&#39;
if __name__ == &#39;__main__&#39;:
    test_add()
    test_sub()
    test_mul()
    test_div()
</code></pre>
<p>这样的测试存在着一些问题。首先，我们需要自己定义断言失败的提示；其次，当<br>测试函数运行失败后，后面的测试函数将不再执行；最后，执行结果无法统计    </p>
<h5 id="通过-unittest-单元测试框架重新编写测试用例"><a href="#通过-unittest-单元测试框架重新编写测试用例" class="headerlink" title="通过 unittest 单元测试框架重新编写测试用例"></a>通过 unittest 单元测试框架重新编写测试用例</h5><p>``</p>
<pre><code class="python">class TestCalculator(unittest.TestCase):
    def test_add(self):
        c = Calculator(3, 5)
        result = c.add()
        self.assertEqual(result, 8)
    def test_sub(self):
        c = Calculator(7, 2)
        result = c.sub()
        self.assertEqual(result, 5)
    def test_mul(self):
        c = Calculator(3, 3)
        result = c.mul()
        self.assertEqual(result, 10)
    def test_div(self):
        c = Calculator(6, 2)
        result = c.div()
        self.assertEqual(result, 3)
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<ol>
<li>创建一个测试类，这里为TestCalculator 类，必须要继承unittest 模块的TestCase类。</li>
<li>创建一个测试方法，该方法必须以“test”开头。</li>
<li>通过unittest 提供的assertEqual()方法来断言结果是否与预期结果相同。该方法由TestCase 父类提供，由于继承了该类，所以可以通过self 调用。</li>
<li>最后，调用unittest 的main()来执行测试用例，它会按照前面的两条规则查找测试用例并执行。</li>
</ol>
<h5 id="四个重要的概念：Test-Case、Test-Suite、Test-Runner-和Test-Fixture。"><a href="#四个重要的概念：Test-Case、Test-Suite、Test-Runner-和Test-Fixture。" class="headerlink" title="四个重要的概念：Test Case、Test Suite、Test Runner 和Test Fixture。"></a>四个重要的概念：Test Case、Test Suite、Test Runner 和Test Fixture。</h5><ol>
<li>Test Case 是最小的测试单元，用于检查特定输入集合的特定返回值。unittest 提供了TestCase 基类，我们创建的测试类需要继承该基类，它可以用来创建新的测试用例。</li>
<li>测试套件是测试用例、测试套件或两者的集合，用于组装一组要运行的测试。unittest提供了TestSuite 类来创建测试套件。</li>
<li>Test Runner 是一个组件，用于协调测试的执行并向用户提供结果。Test Runner 可以使用图形界面、文本界面或返回特殊值来展示执行测试的结果。unittest 提供了TextTestRunner类运行测试用例，为了生成HTML 格式的测试报告，后面会选择使用HTMLTestRunner 运行类。</li>
<li>Test Fixture 代表执行一个或多个测试所需的环境准备，以及关联的清理动作。例如，创建临时或代理数据库、目录，或启动服务器进程,unittest 中提供了setUp()/tearDown()、setUpClass()/tearDownClass()等方法来完成这些操作</li>
</ol>
<p>``</p>
<pre><code class="python">class TestCalculator(unittest.TestCase):
    # 测试用例前置动作
    def setUp(self):
        print(&quot;test start:&quot;)
    # 测试用例后置动作
    def tearDown(self):
        print(&quot;test end&quot;)
    def test_add(self):
        c = Calculator(3, 5)
        result = c.add()
        self.assertEqual(result, 8)
    def test_sub(self):
        c = Calculator(7, 2)
        result = c.sub()
        self.assertEqual(result, 5)

    def test_mul(self):
        c = Calculator(3, 3)
        result = c.mul()
        self.assertEqual(result, 10)

    def test_div(self):
        c = Calculator(6, 2)
        result = c.div()
        self.assertEqual(result, 3)

if __name__ == &#39;__main__&#39;:
# 创建测试套件
    suit = unittest.TestSuite()
    suit.addTest(TestCalculator(&quot;test_add&quot;))
    suit.addTest(TestCalculator(&quot;test_sub&quot;))
    suit.addTest(TestCalculator(&quot;test_mul&quot;))
    suit.addTest(TestCalculator(&quot;test_div&quot;))
# 创建测试运行器
    runner = unittest.TextTestRunner()
    runner.run(suit)
</code></pre>
<ul>
<li>首先，创建一个测试类并继承TestCase 类，在该类下面创建一条以“test”开头的方法为测试用例</li>
<li>在测试类中增加了 setUp()/tearDown()方法，用于定义测试用例的前置和后置动作。在当前测试中暂时用不上，这里定义了一些简单的打印</li>
<li>抛弃了unittest 提供的main()方法，而是调用TestSuite 类下面addTest()来添加测试用例。因为一次只能添加一条用例，所以需要指定测试类及测试方法。然后，再调用TextTestRunner 类下面的run()运行测试套件。</li>
<li>优点：相比main()方法。测试用例的执行顺序可以由测试套件的添加顺序控制，而main()方法只能按照测试类、方法的名称来执行测试用例。例如，TestA 类比TestB 类先执行，test_add()用例比test_div()用例先执行。</li>
<li>其次，当一个测试文件中有很多测试用例时，并不是每次都要执行所有的测试用例，尤其是比较耗时的UI 自动化测试。因而通过测试套件和测试运行器可以灵活地控制要执行的测试用例。</li>
</ul>
<h5 id="断言方法"><a href="#断言方法" class="headerlink" title="断言方法"></a>断言方法</h5><p>``</p>
<pre><code class="python">import unittest
class TestAssert(unittest.TestCase):
    def test_equal(self):
        self.assertEqual(2+52, 4)
        self.assertEqual(&quot;pytgn&quot;, &quot;python&quot;)
        self.assertNotEqual(&quot;hello&quot;, &quot;python&quot;)
    def test_in(self):
        self.assertIn(&quot;hello&quot;, &quot;hello world&quot;)
        self.assertNotIn(&quot;hi&quot;, &quot;hello&quot;)
    def test_true(self):
        self.assertTrue(True)
        self.assertFalse(False)
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<h5 id="测试用例的组织与discover-方法"><a href="#测试用例的组织与discover-方法" class="headerlink" title="测试用例的组织与discover 方法"></a>测试用例的组织与discover 方法</h5><p>针对 Calculator 类所编写的测试用例存在的问题：一个功能对应一条测试用例不够的；其次测试用例的划分，建议一个测试类对应一个被测试功能</p>
<p>``</p>
<pre><code class="python">class Calculator:
    &quot;&quot;&quot; 用于完成两个数的加、减、乘、除&quot;&quot;&quot;
    def __init__(self, a, b):
        self.a = int(a)
        self.b = int(b)
    # 加法
    def add(self):
        return self.a + self.b
    # 减法
    def sub(self):
        return self.a - self.b
    # 乘法
    def mul(self):
        return self.a * self.b
    # 除法
    def div(self):
        return self.a / self.b
class TestAdd(unittest.TestCase):
    &quot;&quot;&quot; add()方法测试&quot;&quot;&quot;
    def test_add_integer(self):
        &quot;&quot;&quot; 整数相加测试&quot;&quot;&quot;
        c = Calculator(3, 5)
        self.assertEqual(c.add(), 8)
    def test_add_decimals(self):
        &quot;&quot;&quot; 小数相加测试&quot;&quot;&quot;
        c = Calculator(3.2, 5.5)
        self.assertEqual(c.add(), 8)
    def test_add_string(self):
        &quot;&quot;&quot; 字符串整数相加测试&quot;&quot;&quot;
        c = Calculator(&quot;7&quot;, &quot;9&quot;)
        self.assertEqual(c.add(), 16)
    # ……

class TestSub(unittest.TestCase):
    &quot;&quot;&quot; sub()方法测试&quot;&quot;&quot;
    pass
# ……
if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<h5 id="判断某年是否为闰年"><a href="#判断某年是否为闰年" class="headerlink" title="判断某年是否为闰年"></a>判断某年是否为闰年</h5><p>``</p>
<pre><code class="python">class LeapYear:
    &quot;&quot;&quot;计算某年是否为闰年&quot;&quot;&quot;
    def __init__ (self, year):
        self.year = int(year)
    def answer(self):
        year = self.year
        if year % 100 == 0:
            if year % 400 == 0:
                # 整百年能被400 整除的是闰年
                return &quot;&#123;0&#125;是闰年&quot;.format(year)
            else:
                return &quot;&#123;0&#125;不是闰年&quot;.format(year)
        else:
            if year % 4 == 0:
                # 非整百年能被4 整除的是闰年
                return &quot;&#123;0&#125;是闰年&quot;.format(year)
            else:
                return &quot;&#123;0&#125;不是闰年&quot;.format(year)



class TestLeapYear(unittest.TestCase):
    def test_2000(self):
        ly = LeapYear(2000)
        self.assertEqual(ly.answer(), &quot;2000是闰年&quot;)
    def test_2004(self):
        ly = LeapYear(2004)
        self.assertEqual(ly.answer(), &quot;2004是闰年&quot;)
    def test_2017(self):
        ly = LeapYear(2017)
        self.assertEqual(ly.answer(), &quot;2017不是闰年&quot;)
    def test_2100(self):
        ly = LeapYear(2100)
        self.assertEqual(ly.answer(), &quot;2100不是闰年&quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<h5 id="如何执行多个测试文件"><a href="#如何执行多个测试文件" class="headerlink" title="如何执行多个测试文件"></a>如何执行多个测试文件</h5><p>unittest 中的TestLoader 类提供的discover()方法可以从多个文件中查找测试用例。</p>
<p>该类根据各种标准加载测试用例，并将它们返回给测试套件。正常情况下，不需要创建这个类的实例。unittest 提供了可以共享的defaultTestLoader 类，可以使用其子类或方法创建实例，discover()方法就是其中之一。</p>
<pre><code class="python">discover(start_dir，pattern=&#39;test*.py&#39;，top_level_dir=None)
找到指定目录及其子目录下的所有测试模块，只有匹配的文件名才能被加载。如果启动的不是顶层目录，那么顶层目录必须单独指定。
    start_dir ：待测试的模块名或测试用例目录。
    pattern=&#39;test*.py&#39; ：测试用例文件名的匹配原则。此处匹配文件名以“test”开头的“.py”类型的文件，星号“*”表示任意多个字符。
    top_level_dir=None：测试模块的顶层目录，如果没有顶层目录，则默认为None。
</code></pre>
<pre><code class="python">import unittest
test_dir = &#39;../test1107&#39;
suits = unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_unit*.py&#39;)
if __name__ == &#39;__main__&#39;:
    runner = unittest.TextTestRunner()
    runner.run(suits)
</code></pre>
<p>discover()方法会自动根据测试用例目录（test_dir）查找测试用例文件（test*.py），并将找到的测试用例添加到测试套件中，因此，可以直接通过run()方法执行测试套件suits。这种方式极大地简化了测试用例的查找，我们需要做的就是按照文件的匹配规则创建测试文件即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/15/unittest%E5%9F%BA%E7%A1%80/" data-id="cm7lnedwu001dh4vd1jxdcwbs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selenium多窗口-警告框处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2022-11-11T03:19:14.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/selenium/">selenium</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/">selenium多窗口_警告框处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code class="python">#多窗口切换
# 在页面操作过程中，有时单击某个链接会弹出新的窗口，这时就需要切换到新打开的窗口中进行操作。WebDriver 提供的switch_to.window()方法可以实现在不同的窗口间切换。
# current_window_handle：获得当前窗口句柄。window_handles：返回所有窗口的句柄到当前会话。switch_to.window()：切换到相应的窗口。
def test_window():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    #获取百度搜索窗口句柄
    search_window = driver.current_window_handle
    driver.implicitly_wait(10)
    driver.find_element_by_id(&quot;s-top-loginbtn&quot;).click()
    driver.implicitly_wait(10)
    driver.find_element_by_id(&#39;TANGRAM__PSP_11__regLink&#39;).click()
    time.sleep(5)
    all_handles = driver.window_handles
    #进入注册窗口：暂时不适用，百度需要验证码才可以
    for handle in all_handles:
        if handle != search_window:
            driver.switch_to.window(handle)
            print(driver.title)
            driver.find_element_by_id(&#39;TANGRAM__PSP_11__userName&#39;).send_keys(&#39;1fafa720fa6&#39;)
            driver.find_element_by_id(&#39;TANGRAM__PSP_11__password&#39;).send_keys(&#39;1fa77242226&#39;)
            time.sleep(5)
            #关闭当前窗口
            driver.close()
        # 回到搜索窗口
        driver.switch_to.window(search_window)
        print(driver.title)
        driver.quit()

#警告框处理
# 在 WebDriver 中处理JavaScript 生成的alert、confirm 和prompt 十分简单，具体做法是，
# 首先使用switch_to.alert()方法定位，然后使用text、accept、dismiss、send_keys 等进行操作。
# text：返回alert、confirm、prompt 中的文字信息。
# accept()：接受现有警告框。
# dismiss()：解散现有警告框。
# send_keys()：在警告框中输入文本（如果可以输入的话）
#可以使用 switch_to.alert()方法为百度搜索设置弹窗
def test_alert():
    driver = webdriver.Chrome()
    driver.get(&#39;https://www.baidu.com&#39;)
    # 打开搜索设置
    # link = driver.find_element_by_link_text(&#39;设置&#39;).click()
    driver.find_element_by_id(&#39;s-usersetting-top&#39;).click()
    driver.find_element_by_link_text(&quot;搜索设置&quot;).click()
    sleep(2)
    # 保存设置
    driver.find_element_by_class_name(&quot;prefpanelgo&quot;).click()
    # 获取警告框
    alert = driver.switch_to.alert
    # 获取警告框提示信息
    alert_text = alert.text
    print(alert_text)
    time.sleep(3)
    # 接取警告框
    alert.accept()
    driver.quit()

# 下拉框处理
# WebDriver 提供了Select 类来处理下拉框。
# Select类：用于定位&lt;select&gt;标签。
# select_by_value()：通过value值定位下拉选项。
# select_by_visible_text()：通过text值定位下拉选项。
# select_by_index()：根据下拉选项的索引进行选择。第一个选项为0，第二个选项为1。
def test_select():
    driver = webdriver.Chrome()
    path = r&#39;D:\7z\py\html\select.html&#39;
    driver.get(path)
    # 通过显示等待的方法判断元素是否出现
    WebDriverWait(driver, 10).until(EC.visibility_of_element_located((By.NAME, &quot;anjing&quot;)))
    select = driver.find_element_by_name(&#39;anjing&#39;)
    # 根据下标进行选择，从0开始
    Select(select).select_by_index(1)
    time.sleep(2)
    # 根据value的值选择
    Select(select).select_by_value(&#39;daily&#39;)
    time.sleep(2)
    # 根基text选择
    Select(select).select_by_visible_text(&#39;关注了吗？&#39;)
    time.sleep(2)
    # 判断选择是否预期
    WebDriverWait(driver, 20).until(EC.element_located_to_be_selected((By.XPATH, &#39;//*[contains(text(),&quot;关注了&quot;)]&#39;)))
    driver.quit()

#上传文件
def test_upfile():
    file_path = os.path.abspath(r&#39;D:\7z\py\html&#39;)
    driver = webdriver.Chrome()
    upload_page = r&#39;D:\7z\py\html\select.html&#39;
    driver.get(upload_page)
    # 定位上传按钮，添加本地文件
    time.sleep(3)
    driver.find_element_by_id(&quot;inputfile&quot;).send_keys(file_path + &#39;/day02.html&#39;)

#操作cookie
# WebDriver 操作Cookie 的方法如下。
# get_cookies()：获得所有Cookie。
# get_cookie(name)：返回字典中key 为“name”的Cookie。
# add_cookie(cookie_dict)：添加 Cookie。
# delete_cookie(name,optionsString)：删除名为OpenString 的Cookie。
# delete_all_cookies()：删除所有Cookie。
def test_cookie():
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.baidu.com&quot;)
    # 获得所有Cookie 信息并打印
    cookie = driver.get_cookies()
    print(cookie)
    # 添加Cookie 信息
    driver.add_cookie(&#123;&#39;name&#39;: &#39;key-aaaaaaa&#39;, &#39;value&#39;: &#39;value-bbbbbb&#39;&#125;)
    # 遍历指定的Cookies
    for cookie in driver.get_cookies():
        print(&quot;%s -&gt; %s&quot; % (cookie[&#39;name&#39;], cookie[&#39;value&#39;]))

#调用javascript,实现浏览器滚动条的拖动效果
def test_move():
    from selenium import webdriver
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.baidu.com&quot;)
    #，通过set_window_size()方法将浏览器窗口设置为固定宽、高显示,目的是让窗口出现水平和垂直滚动条
    driver.set_window_size(800, 600)
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
    driver.find_element_by_id(&quot;su&quot;).click()
    # 通过JavaScript 设置浏览器窗口的滚动条位置
    js = &quot;window.scrollTo(100,450);&quot;
    driver.execute_script(js)
    time.sleep(4)
def test_picture():
    from selenium import webdriver
    driver = webdriver.Chrome()
    driver.get(&#39;http://www.baidu.com&#39;)
    # 截取当前窗口，指定截图图片的保存位置
</code></pre>
<h4 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h4><pre><code>&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;上传表单&lt;/title&gt;
#上传文件
&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;
rel=&quot;stylesheet&quot; &gt;
&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;jumbotron&quot;&gt;
&lt;form class=&quot;form-inline&quot; role=&quot;form&quot;&gt;
&lt;div class=&quot;form-group&quot;&gt;
&lt;label class=&quot;sr-only&quot; for=&quot;name&quot;&gt;名称&lt;/label&gt;
&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;
placeholder=&quot;请输入名称&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;form-group&quot;&gt;
&lt;label class=&quot;sr-only&quot; for=&quot;inputfile&quot;&gt;文件输入&lt;/label&gt;
&lt;input type=&quot;file&quot; id=&quot;inputfile&quot;&gt;
&lt;/div&gt;
&lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;

# select 选择
&lt;form&gt;
&lt;center&gt;
&lt;select name=&quot;anjing&quot;&gt;
&lt;option value=&quot;boke&quot;&gt;请关注今日天气&lt;/option&gt;
&lt;option value=&quot;study&quot;&gt;今天大雨&lt;/option&gt;
&lt;option value=&quot;daily&quot;&gt;写写什么&lt;/option&gt;
&lt;option value=&quot;like&quot;&gt;喜欢的食物&lt;/option&gt;
&lt;option value=&quot;attention&quot;&gt;关注点在哪里&lt;/option&gt;
&lt;/center&gt;
&lt;/select&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" data-id="cm7lnedws0014h4vd6uc18q5l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" rel="tag">selenium多窗口_警告框处理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selenium时间等待" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" class="article-date">
  <time datetime="2022-11-11T01:36:49.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/selenium/">selenium</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/">selenium时间等待</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="获得验证信息"><a href="#获得验证信息" class="headerlink" title="获得验证信息"></a>获得验证信息</h4><pre><code class="python">from time import sleep
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait


def test_title():
    #title：用于获取当前页面的标题
    #current_url：用于获取当前页面的URL
    #text：用于获取当前页面的文本信息
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    print(&#39;Before search================&#39;)
    # 打印当前页面title
    title = driver.title
    print(&quot;title:&quot; + title) #title:百度一下，你就知道
    # 打印当前页面URL
    now_url = driver.current_url
    print(&quot;URL:&quot; + now_url) # URL:https://www.baidu.com/
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
    driver.find_element_by_id(&quot;su&quot;).click()
    sleep(2)
    print(&#39;After search================&#39;)
    # 再次打印当前页面title
    title = driver.title
    print(&quot;title:&quot; + title) #selenium_百度搜索
    # 再次打印当前页面URL
    now_url = driver.current_url
    print(&quot;URL:&quot; + now_url)
    # 获取搜索结果条数
    # num = driver.find_element_by_class_name(&#39;nums&#39;).text
    num = driver.find_element_by_css_selector(&#39;.hint_PIwZX.c_font_2AD7M&#39;).text
    print(&quot;result:&quot; + num) #result:百度为您找到相关结果约100,000,000个
    driver.quit()
</code></pre>
<h4 id="显示等待和隐士等待"><a href="#显示等待和隐士等待" class="headerlink" title="显示等待和隐士等待"></a>显示等待和隐士等待</h4><p><img src="../images/%E9%A2%84%E6%9C%9F%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95.jpg" alt="预期判断方法"></p>
<pre><code class="python"># WebDriverWait 类是WebDriver 提供的等待方法。在设置时间内，默认每隔一段时间检
# 测一次当前页面元素是否存在，如果超过设置时间仍检测不到，则抛出异常。具体格式如下
# WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)
# driver：浏览器驱动。
# timeout：最长超时时间，默认以秒为单位。
# poll_frequency：检测的间隔（步长）时间，默认为0.5s。
# ignored_exceptions：超时后的异常信息，默认情况下抛出NoSuchElementException异常。
# WebDriverWait()一般与until()或until_not()方法配合使用，下面是until()和until_not()方法的说明。until(method, message=″)
# 调用该方法提供的驱动程序作为一个参数，直到返回值为True。until_not(method, message=″)调用该方法提供的驱动程序作为一个参数，直到返回值为False。
def test_time():
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.baidu.com&quot;)
    element = WebDriverWait(driver, 5, 0.5).until(
        expected_conditions.visibility_of_element_located((By.ID, &quot;kw&quot;))
    )
    element.send_keys(&#39;selenium&#39;)
    driver.implicitly_wait(10) #隐式等待
    driver.quit()
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" data-id="cm7lnedwt0019h4vd5mns7q9g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" rel="tag">selenium时间等待</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selenium定位方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2022-11-08T09:36:08.000Z" itemprop="datePublished">2022-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/selenium/">selenium</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/">selenium定位方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="项目能正常开展自动化测试的条件"><a href="#项目能正常开展自动化测试的条件" class="headerlink" title="项目能正常开展自动化测试的条件"></a>项目能正常开展自动化测试的条件</h4><pre><code>1.软件需求变动不频繁
2.项目周期长
3.自动化测试脚本可重复使用
</code></pre>
<h4 id="css定位简单语法"><a href="#css定位简单语法" class="headerlink" title="css定位简单语法"></a>css定位简单语法</h4><p><img src="/.com//css%E9%80%89%E6%8B%A9%E5%99%A8.jpg" alt="css选择器的常用语法"></p>
<h4 id="常用的定位方式举例"><a href="#常用的定位方式举例" class="headerlink" title="常用的定位方式举例"></a>常用的定位方式举例</h4><pre><code class="python">import os
import time
#导入selenium下面的webdriver模块
from selenium import webdriver
def test_click():
    try:
        os.system(&quot;taskkill /f /im chromedriver.exe /t&quot;)
    except:
        pass

    #调用webdriver模块下的Chrome()类
    driver = webdriver.Chrome()
    # 通过driver变量，调用Chrome()类提供的get()方法访问百度首页
    # driver.maximize_window()
    driver.get(&quot;https://www.baidu.com&quot;)
    # driver.implicitly_wait(10)
    time.sleep(4)
    # driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;Selenium&quot;)
    # driver.find_element_by_class_name(&#39;s_ipt&#39;).send_keys(&quot;测试开发&quot;)
    # driver.find_element_by_tag_name(&#39;input&#39;).send_keys(&#39;mysql&#39;) #定位不到
    # driver.find_element_by_link_text(&#39;贴吧&#39;).click()
    # driver.find_element_by_partial_link_text(&#39;携手并进&#39;).click()
    # xpath定位：利用元素属性定位
    # driver.find_element_by_xpath(&#39;//*[@id=&quot;kw&quot;]&#39;).send_keys(&#39;hahah&#39;)
    # driver.find_element_by_xpath(&quot;//*[@class=&#39;s_ipt&#39;]&quot;)
    # 使用XPath 不局限于id、name和class 这三个属性值，元素的任意属性都可以使用，只要它能唯一标识一个元素
    # driver.find_element_by_xpath(&quot;//input[@maxlength=&#39;100&#39;]&quot;).send_keys(&#39;aaa&#39;) #不能成功，数字不唯一
    # driver.find_element_by_xpath(&quot;//input[@autocomplete=&#39;off&#39;]&quot;).send_keys(&#39;bbb&#39;) #可以成功
    # driver.find_element_by_xpath(&quot;//input[@type=&#39;text&#39;]&quot;).send_keys(&#39;ccc&#39;)# 不能成功,type不唯一

    #层级和属性定位
    # driver.find_element_by_xpath(&quot;//form//span[@class=&#39;bg s_ipt_wr new-pmd quickdelete-wrap&#39;]/input[1]&quot;).send_keys(&quot;工程局&quot;)#定位失败
    # driver.find_element_by_xpath(&quot;//span[@id=&#39;s_kw_wrap&#39;]/input[@name=&#39;wd&#39;]&quot;).send_keys(&quot;疫情最新&quot;) 定位失败，执行失败
    # driver.find_element_by_xpath(&quot;//form[@id=&#39;form&#39;]/span[1]/input[1]&quot;).send_keys(&quot;form&quot;) 成功定位

    #使用逻辑运算符定位
    # driver.find_element_by_xpath(&quot;//input[@id=&#39;kw&#39; and @name=&#39;wd&#39;]&quot;).send_keys(&quot;逻辑运算&quot;) #成功定位

    #使用contains方法定位
    # driver.find_element_by_xpath(&quot;//form[contains(@id,&#39;form&#39;)]/span[1]/input&quot;).send_keys(&quot;contains&quot;) #定位成功

    #使用text方法定位‘贴吧’
    # driver.find_element_by_xpath(&quot;//a[contains(text(),&#39;贴吧&#39;)]&quot;).click() #定位成功

    #使用css定位
    #css是一种语言，用来描述html和xml文档的表现，css使用选择器为页面元素绑定属性，一般情况下，css定位速度比xpath定位速度快
    #通过class定位
    # driver.find_element_by_css_selector(&#39;.s_ipt&#39;).send_keys(&quot;css_selector&quot;) #成功定位
    # 层级关系定位：
    # driver.find_element_by_css_selector(&#39;form#form&gt;span&gt;input&#39;).send_keys(&quot;form&quot;) 成功定位
    #通过id定位
    # driver.find_element_by_css_selector(&#39;#kw&#39;).send_keys(&quot;立冬&quot;) #定位成功
    #通过属性定位
    # driver.find_element_by_css_selector(&#39;[autocomplete=off]&#39;).send_keys(&quot;隆冬&quot;) #定位成功
    # driver.find_element_by_css_selector(&quot;[name=&#39;wd&#39;]&quot;).send_keys(&quot;小寒&quot;) #定位成功
    # driver.find_element_by_css_selector(&quot;[type=&#39;text&#39;]&quot;).send_keys(&quot;hhh&quot;)#元素不唯一，失败，属性值可以选择加引号
    #组合定位
    # driver.find_element_by_css_selector(&quot;form#form &gt; span &gt;input.s_ipt&quot;).send_keys(&quot;组合定位&quot;) #定位成功
    # driver.find_element_by_css_selector(&#39;form.fm &gt; span &gt;input.s_ipt&#39;).send_keys(&quot;class&quot;) # 定位成功
    # driver.find_element_by_css_selector(&#39;form#form&gt; span &gt;input#kw&#39;).send_keys(&#39;dcc&#39;) #定位成功
    #更多定位方法
    #查找class 属性包含“s_ipt_wr”字符串的元素
    # driver.find_element_by_css_selector(&quot;[class*=s_ipt]&quot;).send_keys(&#39;haaa&#39;)  #定位失败
    # driver.find_element_by_css_selector(&quot;form &gt; input:nth-child(2)&quot;) #查找 form标签下面第2个input标签的元素
    time.sleep(2)

    # driver.find_element_by_id(&quot;su&quot;).click()
    # driver.find_element_by_css_selector(&#39;#s-top-left &gt; a:nth-child(1)&#39;).click()  #定位百度首页新闻超链接，定位成功
    driver.find_element_by_xpath(&quot;//input[@type=&#39;submit&#39;]&quot;).click()
    # driver.find_element_by_css_selector(&quot;input[class~=&#39;btn&#39;]&quot;).click() #字符开头(&quot;input[class^=&#39;btn&#39;]&quot;)#字符结尾(&quot;input[class$=&#39;s_btn&#39;]&quot;) 定位失败
    # driver.find_element_by_css_selector(&#39;.btn.self-btn.bg.s_btn&#39;).click()

    time.sleep(2)
    driver.close()

    driver.quit()
    # try:
    #
    #     os.system(&quot;taskkill /f /im chromedriver.exe /t&quot;)
    # except:
    #     pass
</code></pre>
<h4 id="控制浏览器"><a href="#控制浏览器" class="headerlink" title="控制浏览器"></a>控制浏览器</h4><pre><code class="python">import time

from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By


def test_con():
    driver = webdriver.Chrome()
    driver.get(&quot;http://m.baidu.com&quot;)
    #参数数字为像素
    print(&quot;设置浏览器宽480、高800 显示&quot;)
    driver.set_window_size(480, 800)
    time.sleep(2)
    driver.quit()
def test_forward():
    driver = webdriver.Chrome()
    #访问百度首页
    url = &quot;http://m.baidu.com&quot;
    print(&quot;now access %s&quot;%(url))
    driver.get(url)
    #访问新闻页
    url2=&#39;http://news.baidu.com&#39;
    print(&quot;now access %s&quot; %(url2))
    driver.get(url2)
    time.sleep(2)
    # 返回（后退）到百度首页
    print(&quot;back to %s &quot; %(url))
    driver.back()
    time.sleep(2)
    # 前进到新闻页
    print(&quot;forward to %s&quot; %(url2))
    driver.forward()
    driver.quit()
def test_common():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    driver.refresh() #刷新浏览器
    time.sleep(2)
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;cclean&quot;)
    time.sleep(1)
    driver.find_element_by_id(&quot;kw&quot;).clear() #先清理“cclean”
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)
    driver.find_element_by_id(&quot;su&quot;).click()
    driver.quit()
#submit()：提交表单
#有些搜索框不提供搜索按钮，而是通过按键盘上的回车键完成搜索内容的提交，这时可以通过submit()模拟
def test_submit():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    time.sleep(2)
    search_text = driver.find_element_by_id(&#39;kw&#39;)
    search_text.send_keys(&#39;selenium&#39;)
    search_text.submit()
    time.sleep(3)
    driver.quit()
#size：返回元素的尺寸。text：获取元素的文本。get_attribute(name)：获得属性值。is_displayed()：设置该元素是否用户可见
def test_ele():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.com&quot;)
    time.sleep(2)
    size = driver.find_element(By.ID,&#39;kw&#39;).size
    print(size)
    # 返回文本信息
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;哈哈哈哈啊啊&quot;)
    text = driver.find_element_by_id(&quot;kw&quot;).text
    print(text)
    # 返回元素的属性值，可以是id、name、type 或其他任意属性
    attribute = driver.find_element_by_id(&quot;kw&quot;).get_attribute(&#39;type&#39;)
    print(attribute)
    # 返回元素的结果是否可见，返回结果为True 或False
    result = driver.find_element_by_id(&quot;kw&quot;).is_displayed()
    print(result)
    driver.quit()
#鼠标操作，在WebDriver中，与鼠标操作相关的方法都封装在ActionChains 类中。ActionChains 类提供了鼠标操作的常用方法：
#perform()：执行ActionChains 类中存储的所有行为。
# context_click()：右击。
# double_click()：双击。
# drag_and_drop()：拖动。
# move_to_element()：鼠标悬停
def test_chain():
    driver = webdriver.Chrome()
    driver.get(&quot;https://www.baidu.cn&quot;)
    time.sleep(5)
    # 定位到要悬停的元素
    above = driver.find_element_by_link_text(&quot;设置&quot;)
    time.sleep(2)
    # 对定位到的元素执行鼠标悬停操作
    #调用 ActionChains 类，把浏览器驱动driver 作为参数传入。
    #move_to_element()方法用于模拟鼠标移动到元素上，在调用时需要指定元素
    #提交所有ActionChains 类中存储的行为
    ActionChains(driver).move_to_element(above).perform()
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/08/selenium%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/" data-id="cm7lnedwt0017h4vdecdndx3l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/selenium%E5%AE%9A%E4%BD%8D/" rel="tag">selenium定位</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql8用户权限" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/" class="article-date">
  <time datetime="2022-11-07T03:11:19.000Z" itemprop="datePublished">2022-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/">mysql8用户权限</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="mysql-的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权"><a href="#mysql-的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权" class="headerlink" title="mysql 的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权"></a>mysql 的登录方式，测试的时候要创建不同的用户来赋权做测试，下面是针对不同登录方式的赋权</h4><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test1‘@’ip’;<br>create user ‘test1‘@’172.172.30.53’ identified by ‘Aa123456@@’;<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test2‘@’主机名’; （host要是mysql30-53）[update user set host=’%’ where user=’test2’;]<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test3‘@’localhost’;<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘test4‘@’127.0.0.1’;<br>查看用户权限：show grants for myuser;     (show grants for root@’localhost’)<br>查看所有用户：select user,host from mysql.user;<br>查看单个用户的所有情况：select * from mysql.user where user=’myuser’\G</p>
<h4 id="授予用户权限和收回权限"><a href="#授予用户权限和收回权限" class="headerlink" title="授予用户权限和收回权限"></a>授予用户权限和收回权限</h4><p>创建用户：<br>create user ‘testss‘@’172.172.30.%’ identified by ‘Aa123456##’;<br>更新用户访问ip:<br>update user set host=’172.172.30.%’, where user=’testcc’;<br>授予用户远程访问的权限：<br>GRANT create,select, INSERT,UPDATE,DELETE,DROP,CREATE,RELOAD, PROCESS, REPLICATION CLIENT,BACKUP_ADMIN,REPLICATION_APPLIER,SESSION_VARIABLES_ADMIN ON <em>.</em> TO ‘testss‘@’172.172.30.%’  WITH GRANT OPTION;<br>grant insert ON <em>.</em> TO ‘testcc‘@’172.172.30.%’  WITH GRANT OPTION;<br>回收权限：revoke select on <em>.</em> from ‘data‘@’172.172.30.%’;</p>
<h4 id="查看mysql日志命令"><a href="#查看mysql日志命令" class="headerlink" title="查看mysql日志命令"></a>查看mysql日志命令</h4><p>获取binlog文件列表:<br>mysql&gt; show binary logs;<br>生成一个新的binlog日志：<br>mysql&gt; flush logs;<br>查看当前正在写入的binlog文件<br>mysql&gt; show master status\G<br>查看指定binlog文件的内容<br>mysql&gt; show binlog events in ‘mysql-bin.000002’<br>查看mysql的binlog日志是否开启：<br>show variables like ‘log_bin’;</p>
<h4 id="Mysql创建自动插入数据的存储过程"><a href="#Mysql创建自动插入数据的存储过程" class="headerlink" title="Mysql创建自动插入数据的存储过程"></a>Mysql创建自动插入数据的存储过程</h4><p>create table test(datetime datetime);<br>CREATE PROCEDURE user()<br>insert into test values(now());<br>CREATE EVENT IF NOT EXISTS eventJob<br>ON SCHEDULE EVERY 1 SECOND<br>ON COMPLETION PRESERVE<br>DO CALL user();<br>alter event eventJob on completion preserve enable;<br>SET GLOBAL event_scheduler = 1;</p>
<p>关闭定时器：<br>alter event eventJob  on completion preserve disable;<br>SET GLOBAL event_scheduler = 0；</p>
<h4 id="mysql插入当前时间"><a href="#mysql插入当前时间" class="headerlink" title="mysql插入当前时间"></a>mysql插入当前时间</h4><p>create table test(name varchar(255));<br>insert into test values (now());</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/07/mysql8%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/" data-id="cm7lnedwk0009h4vd974n7hng" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql%E6%9D%83%E9%99%90/" rel="tag">mysql权限</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python读写Excel文件-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/" class="article-date">
  <time datetime="2022-11-07T02:18:53.000Z" itemprop="datePublished">2022-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%84%E7%90%86Excel%E6%96%87%E4%BB%B6/">处理Excel文件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/">python读写Excel文件-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Excel简介"><a href="#Excel简介" class="headerlink" title="Excel简介"></a>Excel简介</h3><p>Excel是Microsoft（微软）为使用Windows和macOS操作系统开发的一款电子表格软件。Excel凭借其直观的界面、出色的计算功能和图表工具，再加上成功的市场营销，一直以来都是最为流行的个人计算机数据处理软件。当然，Excel也有很多竞品，例如Google Sheets、LibreOffice Calc、Numbers等，这些竞品基本上也能够兼容Excel，至少能够读写较新版本的Excel文件，当然这些不是我们讨论的重点。掌握用Python程序操作Excel文件，可以让日常办公自动化的工作更加轻松愉快，而且在很多商业项目中，导入导出Excel文件都是特别常见的功能。</p>
<p>本章我们继续讲解基于另一个三方库<code>openpyxl</code>如何进行Excel文件操作，首先需要先安装它。</p>
<pre><code class="Bash">pip install openpyxl
</code></pre>
<p><code>openpyxl</code>的优点在于，当我们打开一个Excel文件后，既可以对它进行读操作，又可以对它进行写操作，而且在操作的便捷性上是优于<code>xlwt</code>和<code>xlrd</code>的。此外，如果要进行样式编辑和公式计算，使用<code>openpyxl</code>也远比上一个章节我们讲解的方式更为简单，而且<code>openpyxl</code>还支持数据透视和插入图表等操作，功能非常强大。有一点需要再次强调，<code>openpyxl</code>并不支持操作Office 2007以前版本的Excel文件。</p>
<h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>例如在当前文件夹下有一个名为“阿里巴巴2020年股票数据.xlsx”的Excel文件，如果想读取并显示该文件的内容，可以通过如下所示的代码来完成。</p>
<pre><code class="Python">import datetime

import openpyxl

# 加载一个工作簿 ---&gt; Workbook
wb = openpyxl.load_workbook(&#39;阿里巴巴2020年股票数据.xlsx&#39;)
# 获取工作表的名字
print(wb.sheetnames)
# 获取工作表 ---&gt; Worksheet
sheet = wb.worksheets[0]
# 获得单元格的范围
print(sheet.dimensions)
# 获得行数和列数
print(sheet.max_row, sheet.max_column)

# 获取指定单元格的值
print(sheet.cell(3, 3).value)
print(sheet[&#39;C3&#39;].value)
print(sheet[&#39;G255&#39;].value)

# 获取多个单元格（嵌套元组）
print(sheet[&#39;A2:C5&#39;])

# 读取所有单元格的数据
for row_ch in range(2, sheet.max_row + 1):
    for col_ch in &#39;ABCDEFG&#39;:
        value = sheet[f&#39;&#123;col_ch&#125;&#123;row_ch&#125;&#39;].value
        if type(value) == datetime.datetime:
            print(value.strftime(&#39;%Y年%m月%d日&#39;), end=&#39;\t&#39;)
        elif type(value) == int:
            print(f&#39;&#123;value:&lt;10d&#125;&#39;, end=&#39;\t&#39;)
        elif type(value) == float:
            print(f&#39;&#123;value:.4f&#125;&#39;, end=&#39;\t&#39;)
        else:
            print(value, end=&#39;\t&#39;)
    print()
</code></pre>
<blockquote>
<p><strong>提示</strong>：上面代码中使用的Excel文件“阿里巴巴2020年股票数据.xlsx”可以通过后面的百度云盘地址进行获取。链接:<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a> 提取码:e7b4。</p>
</blockquote>
<p>需要提醒大家一点，<code>openpyxl</code>获取指定的单元格有两种方式，一种是通过<code>cell</code>方法，需要注意，该方法的行索引和列索引都是从<code>1</code>开始的，这是为了照顾用惯了Excel的人的习惯；另一种是通过索引运算，通过指定单元格的坐标，例如<code>C3</code>、<code>G255</code>，也可以取得对应的单元格，再通过单元格对象的<code>value</code>属性，就可以获取到单元格的值。通过上面的代码，相信大家还注意到了，可以通过类似<code>sheet[&#39;A2:C5&#39;]</code>或<code>sheet[&#39;A2&#39;:&#39;C5&#39;]</code>这样的切片操作获取多个单元格，该操作将返回嵌套的元组，相当于获取到了多行多列。</p>
<h3 id="写Excel文件"><a href="#写Excel文件" class="headerlink" title="写Excel文件"></a>写Excel文件</h3><p>下面我们使用<code>openpyxl</code>来进行写Excel操作。</p>
<pre><code class="Python">import random

import openpyxl

# 第一步：创建工作簿（Workbook）
wb = openpyxl.Workbook()

# 第二步：添加工作表（Worksheet）
sheet = wb.active
sheet.title = &#39;期末成绩&#39;

titles = (&#39;姓名&#39;, &#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;)
for col_index, title in enumerate(titles):
    sheet.cell(1, col_index + 1, title)

names = (&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;)
for row_index, name in enumerate(names):
    sheet.cell(row_index + 2, 1, name)
    for col_index in range(2, 5):
        sheet.cell(row_index + 2, col_index, random.randrange(50, 101))

# 第四步：保存工作簿
wb.save(&#39;考试成绩表.xlsx&#39;)
</code></pre>
<h4 id="调整样式和公式计算"><a href="#调整样式和公式计算" class="headerlink" title="调整样式和公式计算"></a>调整样式和公式计算</h4><p>在使用<code>openpyxl</code>操作Excel时，如果要调整单元格的样式，可以直接通过单元格对象（<code>Cell</code>对象）的属性进行操作。单元格对象的属性包括字体（<code>font</code>）、对齐（<code>alignment</code>）、边框（<code>border</code>）等，具体的可以参考<code>openpyxl</code>的<a target="_blank" rel="noopener" href="https://openpyxl.readthedocs.io/en/stable/index.html">官方文档</a>。在使用<code>openpyxl</code>时，如果需要做公式计算，可以完全按照Excel中的操作方式来进行，具体的代码如下所示。</p>
<pre><code class="Python">import openpyxl
from openpyxl.styles import Font, Alignment, Border, Side

# 对齐方式
alignment = Alignment(horizontal=&#39;center&#39;, vertical=&#39;center&#39;)
# 边框线条
side = Side(color=&#39;ff7f50&#39;, style=&#39;mediumDashed&#39;)

wb = openpyxl.load_workbook(&#39;考试成绩表.xlsx&#39;)
sheet = wb.worksheets[0]

# 调整行高和列宽
sheet.row_dimensions[1].height = 30
sheet.column_dimensions[&#39;E&#39;].width = 120

sheet[&#39;E1&#39;] = &#39;平均分&#39;
# 设置字体
sheet.cell(1, 5).font = Font(size=18, bold=True, color=&#39;ff1493&#39;, name=&#39;华文楷体&#39;)
# 设置对齐方式
sheet.cell(1, 5).alignment = alignment
# 设置单元格边框
sheet.cell(1, 5).border = Border(left=side, top=side, right=side, bottom=side)
for i in range(2, 7):
    # 公式计算每个学生的平均分
    sheet[f&#39;E&#123;i&#125;&#39;] = f&#39;=average(B&#123;i&#125;:D&#123;i&#125;)&#39;
    sheet.cell(i, 5).font = Font(size=12, color=&#39;4169e1&#39;, italic=True)
    sheet.cell(i, 5).alignment = alignment

wb.save(&#39;考试成绩表.xlsx&#39;)
</code></pre>
<h3 id="生成统计图表"><a href="#生成统计图表" class="headerlink" title="生成统计图表"></a>生成统计图表</h3><p>通过<code>openpyxl</code>库，可以直接向Excel中插入统计图表，具体的做法跟在Excel中插入图表大体一致。我们可以创建指定类型的图表对象，然后通过该对象的属性对图表进行设置。当然，最为重要的是为图表绑定数据，即横轴代表什么，纵轴代表什么，具体的数值是多少。最后，可以将图表对象添加到表单中，具体的代码如下所示。</p>
<pre><code class="Python">from openpyxl import Workbook
from openpyxl.chart import BarChart, Reference

wb = Workbook(write_only=True)
sheet = wb.create_sheet()

rows = [
    (&#39;类别&#39;, &#39;销售A组&#39;, &#39;销售B组&#39;),
    (&#39;手机&#39;, 40, 30),
    (&#39;平板&#39;, 50, 60),
    (&#39;笔记本&#39;, 80, 70),
    (&#39;外围设备&#39;, 20, 10),
]

# 向表单中添加行
for row in rows:
    sheet.append(row)

# 创建图表对象
chart = BarChart()
chart.type = &#39;col&#39;
chart.style = 10
# 设置图表的标题
chart.title = &#39;销售统计图&#39;
# 设置图表纵轴的标题
chart.y_axis.title = &#39;销量&#39;
# 设置图表横轴的标题
chart.x_axis.title = &#39;商品类别&#39;
# 设置数据的范围
data = Reference(sheet, min_col=2, min_row=1, max_row=5, max_col=3)
# 设置分类的范围
cats = Reference(sheet, min_col=1, min_row=2, max_row=5)
# 给图表添加数据
chart.add_data(data, titles_from_data=True)
# 给图表设置分类
chart.set_categories(cats)
chart.shape = 4
# 将图表添加到表单指定的单元格中
sheet.add_chart(chart, &#39;A10&#39;)

wb.save(&#39;demo.xlsx&#39;)
</code></pre>
<p>运行上面的代码，打开生成的Excel文件，效果如下图所示。</p>
<img src="https://github.com/jackfrued/mypic/raw/master/20210819235009.png" alt="image-20210819235009026" width="75%">

<h3 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h3><p>掌握了Python程序操作Excel的方法，可以解决日常办公中很多繁琐的处理Excel电子表格工作，最常见就是将多个数据格式相同的Excel文件合并到一个文件以及从多个Excel文件或表单中提取指定的数据。如果数据体量较大或者处理数据的方式比较复杂，我们还是推荐大家使用Python数据分析神器之一的<code>pandas</code>库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/07/python%E8%AF%BB%E5%86%99Excel%E6%96%87%E4%BB%B6-2/" data-id="cm7lnedwr000zh4vd996x2zmj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Excel/" rel="tag">Excel</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jmeter/">jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%9F%BA%E7%A1%80/">linux基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/pytest/">pytest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/selenium/">selenium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/unittest/">unittest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%84%E7%90%86Excel%E6%96%87%E4%BB%B6/">处理Excel文件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/">接口测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Excel/" rel="tag">Excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csv/" rel="tag">csv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" rel="tag">jmeter_cookie处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" rel="tag">jmeter参数化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4/" rel="tag">linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql%E6%9D%83%E9%99%90/" rel="tag">mysql权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ntpd/" rel="tag">ntpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest/" rel="tag">pytest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" rel="tag">selenium多窗口_警告框处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%AE%9A%E4%BD%8D/" rel="tag">selenium定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" rel="tag">selenium时间等待</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" rel="tag">接口基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="tag">类与对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/csv/" style="font-size: 10px;">csv</a> <a href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" style="font-size: 10px;">jmeter_cookie处理</a> <a href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" style="font-size: 10px;">jmeter参数化</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">linux命令</a> <a href="/tags/mysql%E6%9D%83%E9%99%90/" style="font-size: 10px;">mysql权限</a> <a href="/tags/ntpd/" style="font-size: 10px;">ntpd</a> <a href="/tags/pytest/" style="font-size: 10px;">pytest</a> <a href="/tags/pytest%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">pytest基础</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" style="font-size: 10px;">selenium多窗口_警告框处理</a> <a href="/tags/selenium%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">selenium定位</a> <a href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" style="font-size: 10px;">selenium时间等待</a> <a href="/tags/unittest%E6%A6%82%E5%BF%B5/" style="font-size: 15px;">unittest概念</a> <a href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">接口基础</a> <a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">类与对象</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/26/linux%E5%91%BD%E4%BB%A4lsof/">linux命令lsof</a>
          </li>
        
          <li>
            <a href="/2025/02/26/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/select/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/02/25/%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA/">改变对象字符串显示</a>
          </li>
        
          <li>
            <a href="/2023/09/20/ntp%E9%85%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/">ntp配置时间同步</a>
          </li>
        
          <li>
            <a href="/2023/06/19/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">接口测试学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 当时只道是寻常<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>