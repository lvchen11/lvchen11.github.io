<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>月明星稀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="太阳当空照，花儿爱微笑">
<meta property="og:type" content="website">
<meta property="og:title" content="月明星稀">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="月明星稀">
<meta property="og:description" content="太阳当空照，花儿爱微笑">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="当时只道是寻常">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="月明星稀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">月明星稀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-反向迭代" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/20/%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3/" class="article-date">
  <time datetime="2025-03-20T07:09:12.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/20/%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3/">反向迭代</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 Python 中反向迭代序列可以通过以下方法实现，根据不同的需求选择最佳方案：</p>
<ol>
<li><strong>使用 <code>reversed()</code> 函数（推荐）</strong></li>
</ol>
<p><code>reversed()</code> 返回一个反向迭代器，直接按倒序访问元素，无需复制数据。</p>
<pre><code class="python">my_list = [1, 2, 3, 4, 5]

# 反向迭代列表
for item in reversed(my_list):
    print(item)
# 输出：5 4 3 2 1

# 反向迭代字符串
text = &quot;hello&quot;
for char in reversed(text):
    print(char)  # 输出：o l l e h
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>内存高效</strong>：不生成新序列，直接反向访问原数据。</li>
<li><strong>通用性</strong>：支持列表、字符串、元组等所有可逆对象。</li>
</ul>
<ol start="2">
<li><strong>切片操作 <code>[::-1]</code></strong></li>
</ol>
<p>通过切片生成一个反向副本，适用于需要修改反向序列的场景。</p>
<pre><code class="python">my_list = [1, 2, 3, 4, 5]
reversed_list = my_list[::-1]  # 生成新列表 [5, 4, 3, 2, 1]

for item in reversed_list:
    print(item)
</code></pre>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>内存开销</strong>：会生成完整的新序列副本，不适合大型数据集。</li>
<li><strong>适用性</strong>：仅支持列表、字符串等可切片对象。</li>
</ul>
<ol start="3">
<li><strong>自定义反向迭代逻辑</strong></li>
</ol>
<p>当对象不支持反向迭代时（如自定义链表），可手动实现反向逻辑。</p>
<h4 id="示例：链表反向迭代"><a href="#示例：链表反向迭代" class="headerlink" title="示例：链表反向迭代"></a>示例：链表反向迭代</h4><pre><code class="python">class Node:
    def __init__(self, value, next_node=None):
        self.value = value
        self.next = next_node

# 创建链表：1 -&gt; 2 -&gt; 3 -&gt; None
head = Node(1, Node(2, Node(3)))

# 手动反向迭代
current = head
stack = []
while current:
    stack.append(current.value)  # 将节点值压入栈
    current = current.next

for value in reversed(stack):    # 从栈中弹出反向值
    print(value)  # 输出：3 2 1
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>处理不支持内置反向操作的数据结构（如单向链表）。</li>
<li>需要自定义反向条件（如只反向偶数索引元素）。</li>
</ul>
<ol start="4">
<li><strong>为自定义类添加反向迭代支持</strong></li>
</ol>
<p>通过实现 <code>__reversed__</code> 方法，使自定义容器支持 <code>reversed()</code>。</p>
<pre><code class="python">class MyContainer:
    def __init__(self, data):
        self.data = data

    def __reversed__(self):
        # 返回一个反向迭代器
        return reversed(self.data)

# 使用示例
container = MyContainer([1, 2, 3])
for item in reversed(container):
    print(item)  # 输出：3 2 1
</code></pre>
<ol start="5">
<li><strong>反向迭代不可逆对象</strong></li>
</ol>
<p>对生成器或文件流等不可逆对象，可先转成列表再反向。</p>
<pre><code class="python"># 反向迭代生成器产生的数据
gen = (x for x in range(5))  # 生成器：0,1,2,3,4
for item in reversed(list(gen)):  # 先转为列表
    print(item)  # 输出：4 3 2 1 0
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>内存风险</strong>：若数据量巨大，转换为列表可能导致内存不足。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>内存开销</th>
<th>是否修改原数据</th>
</tr>
</thead>
<tbody><tr>
<td><code>reversed()</code></td>
<td>通用反向迭代</td>
<td>低</td>
<td>否</td>
</tr>
<tr>
<td>切片 <code>[::-1]</code></td>
<td>需要反向副本</td>
<td>高</td>
<td>生成副本</td>
</tr>
<tr>
<td>自定义逻辑</td>
<td>特殊数据结构或条件反向</td>
<td>可变</td>
<td>否</td>
</tr>
<tr>
<td>转列表再反向</td>
<td>处理不可逆对象（如生成器）</td>
<td>高</td>
<td>生成副本</td>
</tr>
</tbody></table>
<p>根据数据规模和需求选择最佳方案！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/20/%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3/" data-id="cm8h0o63p001r70vdbwtq6o3g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%85%B6%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" rel="tag">迭代其和生成器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-生成器创建自定义迭代模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/20/%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2025-03-20T07:02:22.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/20/%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/">生成器创建自定义迭代模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用生成器创建自定义迭代模式的 Python 实现</p>
<h4 id="1-目标"><a href="#1-目标" class="headerlink" title="1. 目标"></a>1. <strong>目标</strong></h4><p>通过生成器函数（<code>yield</code>）实现以下自定义迭代模式：</p>
<ul>
<li><strong>非线性序列</strong>（如平方数、指数增长）。</li>
<li><strong>条件过滤序列</strong>（如仅生成偶数或特定范围的数）。</li>
<li><strong>无限序列</strong>（如斐波那契数列）。</li>
<li><strong>组合迭代</strong>（如交替合并多个序列）。</li>
</ul>
<h4 id="2-基础生成器示例"><a href="#2-基础生成器示例" class="headerlink" title="2. 基础生成器示例"></a>2. <strong>基础生成器示例</strong></h4><h5 id="示例-1：生成平方数序列"><a href="#示例-1：生成平方数序列" class="headerlink" title="示例 1：生成平方数序列"></a><strong>示例 1：生成平方数序列</strong></h5><pre><code class="python">def square_generator(n):
    &quot;&quot;&quot;生成前n个平方数&quot;&quot;&quot;
    for i in range(n):
        yield i ** 2

# 使用示例
for num in square_generator(5):
    print(num)  # 输出：0, 1, 4, 9, 16
</code></pre>
<h5 id="示例-2：生成指数增长序列"><a href="#示例-2：生成指数增长序列" class="headerlink" title="示例 2：生成指数增长序列"></a><strong>示例 2：生成指数增长序列</strong></h5><pre><code class="python">def exponential_generator(base, max_value):
    &quot;&quot;&quot;生成 base^0, base^1, ...，直到超过max_value&quot;&quot;&quot;
    current = 1
    while current &lt;= max_value:
        yield current
        current *= base

# 使用示例
for num in exponential_generator(2, 32):
    print(num)  # 输出：1, 2, 4, 8, 16, 32
</code></pre>
<h4 id="3-条件过滤迭代"><a href="#3-条件过滤迭代" class="headerlink" title="3. 条件过滤迭代"></a>3. <strong>条件过滤迭代</strong></h4><h5 id="示例-3：仅生成满足条件的值"><a href="#示例-3：仅生成满足条件的值" class="headerlink" title="示例 3：仅生成满足条件的值"></a><strong>示例 3：仅生成满足条件的值</strong></h5><pre><code class="python">def conditional_filter(start, end, condition_func):
    &quot;&quot;&quot;生成 start到end之间满足condition_func的数&quot;&quot;&quot;
    current = start
    while current &lt;= end:
        if condition_func(current):
            yield current
        current += 1

# 使用示例：生成偶数
is_even = lambda x: x % 2 == 0
for num in conditional_filter(0, 10, is_even):
    print(num)  # 输出：0, 2, 4, 6, 8, 10
</code></pre>
<h4 id="4-无限序列"><a href="#4-无限序列" class="headerlink" title="4. 无限序列"></a>4. <strong>无限序列</strong></h4><h5 id="示例-4：无限斐波那契数列"><a href="#示例-4：无限斐波那契数列" class="headerlink" title="示例 4：无限斐波那契数列"></a><strong>示例 4：无限斐波那契数列</strong></h5><pre><code class="python">def fibonacci_generator():
    &quot;&quot;&quot;生成无限斐波那契数列&quot;&quot;&quot;
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 使用示例：生成前10个斐波那契数
fib = fibonacci_generator()
for _ in range(10):
    print(next(fib))  # 输出：0, 1, 1, 2, 3, 5, 8, 13, 21, 34
</code></pre>
<h4 id="5-组合迭代模式"><a href="#5-组合迭代模式" class="headerlink" title="5. 组合迭代模式"></a>5. <strong>组合迭代模式</strong></h4><h5 id="示例-5：交替合并多个序列"><a href="#示例-5：交替合并多个序列" class="headerlink" title="示例 5：交替合并多个序列"></a><strong>示例 5：交替合并多个序列</strong></h5><pre><code class="python">def alternate(*iterables):
    &quot;&quot;&quot;交替从多个可迭代对象中取元素&quot;&quot;&quot;
    iterators = [iter(it) for it in iterables]
    while iterators:
        for it in list(iterators):
            try:
                yield next(it)
            except StopIteration:
                iterators.remove(it)

# 使用示例
list1 = [1, 2, 3]
list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
for item in alternate(list1, list2):
    print(item)  # 输出：1, &#39;a&#39;, 2, &#39;b&#39;, 3, &#39;c&#39;
</code></pre>
<h4 id="6-动态调整迭代逻辑"><a href="#6-动态调整迭代逻辑" class="headerlink" title="6. 动态调整迭代逻辑"></a>6. <strong>动态调整迭代逻辑</strong></h4><h5 id="示例-6：可变步长的迭代"><a href="#示例-6：可变步长的迭代" class="headerlink" title="示例 6：可变步长的迭代"></a><strong>示例 6：可变步长的迭代</strong></h5><pre><code class="python">def dynamic_step_generator(start, end, step_func):
    &quot;&quot;&quot;根据step_func动态调整步长&quot;&quot;&quot;
    current = start
    while current &lt;= end:
        yield current
        step = step_func(current)  # 例如：步长每次翻倍
        current += step

# 使用示例：步长每次翻倍
step_func = lambda x: x if x &lt; 4 else 1  # 自定义逻辑
for num in dynamic_step_generator(1, 10, step_func):
    print(num)  # 输出：1, 2, 4, 5, 6, 7, 8, 9, 10
</code></pre>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><ul>
<li><strong>核心机制</strong>：通过 <code>yield</code> 暂停函数状态，逐个返回值。</li>
<li><strong>灵活控制</strong>：可以自由定义迭代的起始、终止、步长、条件等逻辑。</li>
<li><strong>内存高效</strong>：生成器按需生成值，无需预先生成完整序列。</li>
</ul>
<p>通过组合上述模式，你可以轻松实现复杂的迭代需求（如分块处理、实时数据流等）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/20/%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/" data-id="cm8h0o640003u70vd4owaavm5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%85%B6%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" rel="tag">迭代其和生成器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-代理迭代的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/20/%E4%BB%A3%E7%90%86%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2025-03-20T06:55:15.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/20/%E4%BB%A3%E7%90%86%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/">代理迭代的实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要在自定义容器对象上实现代理迭代，可以通过以下步骤完成：</p>
<p>解决方案：代理迭代的实现</p>
<p><strong>目标</strong>：让自定义容器直接迭代其内部多个可迭代对象的所有元素。</p>
<h4 id="步骤说明"><a href="#步骤说明" class="headerlink" title="步骤说明"></a>步骤说明</h4><ol>
<li><strong>定义容器类</strong>：容器类需包含多个可迭代对象（如列表、元组）。</li>
<li><strong>实现 <code>__iter__</code> 方法</strong>：在该方法中遍历所有内部可迭代对象，并逐个生成它们的元素。</li>
<li><strong>使用 <code>yield from</code> 简化代码</strong>：通过 <code>yield from iterable</code> 直接委托迭代逻辑给内部对象。</li>
</ol>
<p>示例代码</p>
<pre><code>class MultiIterContainer:
    def __init__(self, *iterables):
        # 存储多个可迭代对象（如列表、元组、生成器等）
        self.iterables = iterables
    
    def __iter__(self):
        # 遍历每个内部可迭代对象，并逐层展开其元素
        for iterable in self.iterables:
            yield from iterable

# 测试
if __name__ == &quot;__main__&quot;:
    # 初始化容器，传入列表、元组和生成器
    data = [1, 2, 3]
    text = (&quot;a&quot;, &quot;b&quot;)
    gen = (x for x in range(4, 6))  # 生成器：4, 5

    container = MultiIterContainer(data, text, gen)

    # 直接迭代容器对象
    for item in container:
        print(item, end=&quot; &quot;)  # 输出：1 2 3 a b 4 5
</code></pre>
<p>关键机制</p>
<ol>
<li><strong><code>yield from</code> 的作用</strong>：<ul>
<li>简化嵌套循环：<code>yield from iterable</code> 等价于 <code>for x in iterable: yield x</code>。</li>
<li>支持任意可迭代对象（列表、元组、生成器、其他自定义容器等）。</li>
</ul>
</li>
<li><strong>惰性迭代</strong>：<ul>
<li>容器迭代时按需生成元素，适用于处理大型数据集或无限序列。</li>
</ul>
</li>
<li><strong>动态更新</strong>：<ul>
<li>如果容器内部的可迭代对象在迭代过程中被修改，迭代结果会反映最新状态。</li>
</ul>
</li>
</ol>
<p>扩展场景：处理嵌套结构</p>
<p>若容器内部存在多层嵌套的可迭代对象（如列表的列表），可通过递归展开：</p>
<pre><code>class DeepIterContainer:
    def __init__(self, *iterables):
        self.iterables = iterables
    
    def __iter__(self):
        for item in self.iterables:
            if isinstance(item, (list, tuple)):  # 检查是否为可迭代对象
                yield from DeepIterContainer(*item)  # 递归展开
            else:
                yield item

# 测试
container = DeepIterContainer([1, [2, (3,)], 4], (&quot;a&quot;, [&quot;b&quot;]))
for x in container:
    print(x, end=&quot; &quot;)  # 输出：1 2 3 4 a b
</code></pre>
<p>总结</p>
<p>通过实现 <code>__iter__</code> 方法并委托给内部对象的迭代逻辑，自定义容器可以：</p>
<ol>
<li><strong>统一管理多个可迭代对象</strong>。</li>
<li><strong>直接支持 <code>for</code> 循环、列表推导式等迭代操作</strong>。</li>
<li><strong>灵活扩展</strong>（如嵌套展开、过滤元素等）。</li>
</ol>
<p>这种模式常用于日志聚合、数据管道或组合模式的设计中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/20/%E4%BB%A3%E7%90%86%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="cm8h0o63n001l70vd6mi64wsn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%85%B6%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" rel="tag">迭代其和生成器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python迭代器和生成器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/20/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" class="article-date">
  <time datetime="2025-03-20T05:37:49.000Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/20/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/">python迭代器和生成器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一、迭代器（Iterator）</strong><br><strong>1. 核心概念</strong><br>迭代器是一个实现了<code>__iter__</code>和<code>__next__</code>方法的对象，用于逐个访问集合中的元素。任何实现了这两个方法的类都可以称为迭代器：</p>
<ul>
<li><code>__iter__</code>：返回迭代器对象自身（通常是<code>self</code>）</li>
<li><code>__next__</code>：返回下一个元素，若没有元素则抛出<code>StopIteration</code>异常</li>
</ul>
<p><strong>2. 代码示例</strong></p>
<pre><code class="python">class MyIterator:
    def __init__(self, max_val):
        self.max_val = max_val
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current &lt; self.max_val:
            self.current += 1
            return self.current
        else:
            raise StopIteration

# 使用示例
it = MyIterator(3)
print(next(it))  # 输出 1
print(next(it))  # 输出 2
print(next(it))  # 输出 3
# for num in it:
#     print(num)
</code></pre>
<p><strong>3. 内置迭代器工具</strong><br>Python内置对象如列表、字符串等虽然不是迭代器，但可通过<code>iter()</code>函数转换为迭代器</p>
<pre><code class="python">my_list = [1, 2, 3]
list_iter = iter(my_list)
print(next(list_iter))  # 输出 1
</code></pre>
<hr>
<p><strong>二、生成器（Generator）</strong><br><strong>1. 核心概念</strong><br>生成器是一种特殊的迭代器，通过<code>yield</code>关键字实现延迟计算。它不需要显式定义<code>__iter__</code>和<code>__next__</code>方法，而是通过函数暂停和恢复执行状态来生成值。</p>
<p><strong>2. 代码示例</strong><br><strong>(1) 生成器函数：</strong></p>
<pre><code class="python">def my_generator(max_val):
    current = 0
    while current &lt; max_val:
        yield current
        current += 1

# 使用示例
gen = my_generator(3)
print(next(gen))  # 输出 0
print(next(gen))  # 输出 1
</code></pre>
<p><strong>(2) 生成器表达式：</strong></p>
<pre><code class="python">gen_expr = (x**2 for x in range(3))
print(list(gen_expr))  # 输出 [0, 1, 4]
</code></pre>
<p><strong>3. 优势特性</strong></p>
<ul>
<li><strong>内存效率</strong>：生成器逐个生成值，无需预存所有数据（适合处理大文件或无限序列）</li>
<li><strong>状态保持</strong>：每次<code>yield</code>会保存当前执行状态</li>
<li><strong>简化代码</strong>：无需手动实现迭代器类</li>
</ul>
<hr>
<p><strong>三、关键区别对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>迭代器</th>
<th>生成器</th>
</tr>
</thead>
<tbody><tr>
<td>实现方式</td>
<td>需显式定义<code>__iter__</code>和<code>__next__</code></td>
<td>使用<code>yield</code>关键字自动实现</td>
</tr>
<tr>
<td>代码复杂度</td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td>内存占用</td>
<td>需预先存储数据</td>
<td>按需生成数据</td>
</tr>
<tr>
<td>应用场景</td>
<td>遍历现有集合</td>
<td>处理流式数据或大规模数据集</td>
</tr>
</tbody></table>
<hr>
<p><strong>四、实际应用场景</strong></p>
<ol>
<li><p><strong>迭代器</strong>：遍历数据库查询结果、自定义集合类</p>
</li>
<li><p>生成器</p>
<ul>
<li>读取大文件（逐行处理避免内存溢出）</li>
</ul>
<pre><code class="python">def read_large_file(file_path):
    with open(file_path) as f:
        for line in f:
            yield line.strip()
</code></pre>
<ul>
<li>生成无限序列（如斐波那契数列）</li>
</ul>
<pre><code class="python">def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
</code></pre>
</li>
</ol>
<hr>
<p><strong>五、注意事项</strong></p>
<ol>
<li>生成器只能遍历一次，若需重复使用需重新创建</li>
<li>迭代器可通过<code>for</code>循环隐式调用<code>next()</code></li>
<li>生成器支持双向通信（通过<code>.send()</code>方法传递值）</li>
</ol>
<p>通过结合迭代器的规范性和生成器的简洁性，可以高效处理各类数据流问题。如需进一步优化，可研究<code>itertools</code>模块提供的扩展工具。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/20/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" data-id="cm8h0o63l001770vd6dv76uqe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" rel="tag">迭代器和生成器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-服务器同步时间配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2025-03-07T08:15:24.000Z" itemprop="datePublished">2025-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE/">服务器同步时间配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、服务端配置（172-172-31-32）"><a href="#一、服务端配置（172-172-31-32）" class="headerlink" title="一、服务端配置（172.172.31.32）"></a>一、服务端配置（172.172.31.32）</h3><h4 id="1-安装Chrony"><a href="#1-安装Chrony" class="headerlink" title="1. 安装Chrony"></a>1. 安装Chrony</h4><pre><code class="bash">yum install -y chrony
</code></pre>
<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h4><p>编辑 <code>/etc/chrony.conf</code>：</p>
<pre><code class="bash">vi /etc/chrony.conf
</code></pre>
<p><strong>删除或注释原有<code>server</code>行</strong>，添加以下内容：</p>
<pre><code class="conf"># 指定上游时间源（以阿里云NTP为例）
server ntp.aliyun.com iburst

# 允许客户端网段访问（覆盖33和34）
allow 172.172.31.0/24

# 其他优化参数
driftfile /var/lib/chrony/drift
makestep 1.0 3
rtcsync
</code></pre>
<h4 id="3-启动服务并设置开机自启"><a href="#3-启动服务并设置开机自启" class="headerlink" title="3. 启动服务并设置开机自启"></a>3. 启动服务并设置开机自启</h4><pre><code class="bash">systemctl enable --now chronyd
</code></pre>
<h4 id="4-防火墙放行"><a href="#4-防火墙放行" class="headerlink" title="4. 防火墙放行"></a>4. 防火墙放行</h4><pre><code class="bash">firewall-cmd --add-service=chrony --permanent
firewall-cmd --reload
</code></pre>
<h4 id="5-验证服务端状态"><a href="#5-验证服务端状态" class="headerlink" title="5. 验证服务端状态"></a>5. 验证服务端状态</h4><pre><code class="bash"># 检查同步源状态（出现`^*`表示已同步）
chronyc sources -v

# 查看时间偏差和频率
chronyc tracking
</code></pre>
<hr>
<h3 id="二、客户端配置（172-172-31-33-和-172-172-31-34）"><a href="#二、客户端配置（172-172-31-33-和-172-172-31-34）" class="headerlink" title="二、客户端配置（172.172.31.33 和 172.172.31.34）"></a>二、客户端配置（172.172.31.33 和 172.172.31.34）</h3><h4 id="1-安装Chrony-1"><a href="#1-安装Chrony-1" class="headerlink" title="1. 安装Chrony"></a>1. 安装Chrony</h4><pre><code class="bash">yum install -y chrony
</code></pre>
<h4 id="2-修改配置文件-1"><a href="#2-修改配置文件-1" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h4><p>编辑 <code>/etc/chrony.conf</code>：</p>
<pre><code class="bash">vi /etc/chrony.conf
</code></pre>
<p><strong>删除或注释原有<code>server</code>行</strong>，添加以下内容：</p>
<pre><code class="conf"># 指向NTP服务器IP（172.172.31.32）
server 172.172.31.32 iburst

# 其他优化参数（与服务端一致）
driftfile /var/lib/chrony/drift
makestep 1.0 3
rtcsync
</code></pre>
<h4 id="3-启动服务并验证"><a href="#3-启动服务并验证" class="headerlink" title="3. 启动服务并验证"></a>3. 启动服务并验证</h4><pre><code class="bash">systemctl restart chronyd

# 检查是否同步到服务端（应显示`^* 172.172.31.32`）
chronyc sources -v

# 查看时间偏差
chronyc tracking
</code></pre>
<hr>
<h3 id="三、统一时区设置（所有机器）"><a href="#三、统一时区设置（所有机器）" class="headerlink" title="三、统一时区设置（所有机器）"></a>三、统一时区设置（所有机器）</h3><pre><code class="bash"># 设置时区为上海（根据需求调整）
timedatectl set-timezone Asia/Shanghai

# 验证时间和时区
timedatectl status

# 将系统时间写入硬件时钟
hwclock -w
</code></pre>
<hr>
<h3 id="四、最终验证"><a href="#四、最终验证" class="headerlink" title="四、最终验证"></a>四、最终验证</h3><h4 id="1-检查所有机器时间一致性"><a href="#1-检查所有机器时间一致性" class="headerlink" title="1. 检查所有机器时间一致性"></a>1. 检查所有机器时间一致性</h4><pre><code class="bash"># 在所有机器上执行
date +&quot;%Y-%m-%d %H:%M:%S&quot;
</code></pre>
<p>输出时间差异应小于 <strong>1秒</strong>。</p>
<h4 id="2-查看客户端同步状态"><a href="#2-查看客户端同步状态" class="headerlink" title="2. 查看客户端同步状态"></a>2. 查看客户端同步状态</h4><p>在客户端执行：</p>
<pre><code class="bash">chronyc tracking
</code></pre>
<p>输出中 <code>System time</code> 应为 <code>0.000000 seconds</code>（表示已同步）。</p>
<hr>
<h3 id="五、故障排查"><a href="#五、故障排查" class="headerlink" title="五、故障排查"></a>五、故障排查</h3><h4 id="1-客户端无法同步"><a href="#1-客户端无法同步" class="headerlink" title="1. 客户端无法同步"></a>1. 客户端无法同步</h4><ul>
<li><p>检查网络连通性</p>
<pre><code class="bash">ping 172.172.31.32
</code></pre>
</li>
<li><p>查看服务端是否允许访问</p>
<pre><code class="bash"># 在服务端执行
chronyc clients
</code></pre>
</li>
</ul>
<p>应显示客户端IP（33和34）。</p>
<h4 id="2-时间偏差过大"><a href="#2-时间偏差过大" class="headerlink" title="2. 时间偏差过大"></a>2. 时间偏差过大</h4><ul>
<li><p>强制立即同步</p>
<pre><code class="bash">chronyc makestep
</code></pre>
</li>
</ul>
<h4 id="3-SELinux拦截"><a href="#3-SELinux拦截" class="headerlink" title="3. SELinux拦截"></a>3. SELinux拦截</h4><ul>
<li><p>临时允许NTP通信</p>
<pre><code class="bash">setsebool -P chronyd_can_network on
</code></pre>
</li>
</ul>
<hr>
<h3 id="六、方案优势"><a href="#六、方案优势" class="headerlink" title="六、方案优势"></a>六、方案优势</h3><ol>
<li><strong>平滑同步</strong>：Chrony通过微调系统时钟避免时间跳变，适合生产环境。</li>
<li><strong>容错性强</strong>：支持间歇性网络中断后自动恢复同步。</li>
<li><strong>资源占用低</strong>：相比传统NTPd，内存和CPU消耗更低。</li>
</ol>
<p>若需进一步优化，可在服务端配置多个上游源（如 <code>server ntp1.aliyun.com iburst</code> 和 <code>server ntp2.aliyun.com iburst</code>）提升可靠性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE/" data-id="cm8h0o63s002870vdbwbkfzs9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chrony/" rel="tag">Chrony</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql数据库插入数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/" class="article-date">
  <time datetime="2025-03-06T01:35:03.000Z" itemprop="datePublished">2025-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/">mysql数据库插入数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL数据库插入大数据"><a href="#MySQL数据库插入大数据" class="headerlink" title="MySQL数据库插入大数据"></a>MySQL数据库插入大数据</h1><h5 id="一、连接数据库创建表"><a href="#一、连接数据库创建表" class="headerlink" title="一、连接数据库创建表"></a>一、连接数据库创建表</h5><pre><code class="sql">CREATE TABLE `ln_batch_return_detail_mmdd` (
  `legal_entity` VARCHAR(14) NOT NULL COMMENT &#39;法人号&#39;,
  `tx_trace_no` VARCHAR(40) NOT NULL COMMENT &#39;交易流水号&#39;, 
  `tx_trace_no_local` VARCHAR(40) COMMENT &#39;核算本地流水号&#39;,
  `tx_trace_cnt` BIGINT NOT NULL COMMENT &#39;流水笔次&#39;,
  `settle_flag` VARCHAR(1) NOT NULL COMMENT &#39;结清标志[0:不结息; 1:结息]&#39;,
  `prcl_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;本金金额&#39;,
  `int_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;利息金额&#39;,
  `core_trace_no` VARCHAR(60) NOT NULL COMMENT &#39;核心流水号&#39;,
  `deduct_sts` VARCHAR(1) NOT NULL COMMENT &#39;扣款状态[1:成功; 2:失败]&#39;,
  `error_info` VARCHAR(200) NOT NULL COMMENT &#39;异常信息&#39;,
  `mac` VARCHAR(30) NOT NULL COMMENT &#39;MAC 验证&#39;,
  `vpd_entity` BIGINT NOT NULL COMMENT &#39;多实体号&#39;,
  `repay_ac_no` VARCHAR(32) COMMENT &#39;还款账号&#39;,
  `ln_ac_id` DECIMAL(20,0) COMMENT &#39;贷款账户ID&#39;,
  `repay_ac_seqn` BIGINT COMMENT &#39;还款账户序号&#39;,
  `tx_date` BIGINT NOT NULL COMMENT &#39;交易日期&#39;,
  `opposite_br_no` VARCHAR(14) COMMENT &#39;对方机构号&#39;,
  `repay_ac_name` VARCHAR(200) COMMENT &#39;还款账户名称&#39;,
  `send_prcl_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;上送本金金额&#39;,
  `send_int_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;上送利息金额&#39;,
  `send_settl_amt` DECIMAL(23,2) NOT NULL COMMENT &#39;上送结清金额&#39;,
  `batch_no` VARCHAR(40) NOT NULL COMMENT &#39;批次号&#39;,
  PRIMARY KEY (`tx_trace_no`, `tx_trace_cnt`, `legal_entity`),
  INDEX `ln_return_detail_mmdd_idx1` (`tx_date`, `tx_trace_no_local`, `tx_trace_no`, `tx_trace_cnt`, `legal_entity`)
) ENGINE=InnoDB;
</code></pre>
<h5 id="二、执行python脚本生成data-csv数据"><a href="#二、执行python脚本生成data-csv数据" class="headerlink" title="二、执行python脚本生成data.csv数据"></a>二、执行python脚本生成data.csv数据</h5><pre><code class="python">import csv
import random
from tqdm import tqdm  # 进度条工具（可选：pip install tqdm）

def generate_csv(file_path, total_rows=10_000_000, batch_size=10_000):
    # CSV文件列头（与表字段顺序严格一致）
    header = [
        &quot;legal_entity&quot;, &quot;tx_trace_no&quot;, &quot;tx_trace_no_local&quot;, &quot;tx_trace_cnt&quot;, &quot;settle_flag&quot;,
        &quot;prcl_amt&quot;, &quot;int_amt&quot;, &quot;core_trace_no&quot;, &quot;deduct_sts&quot;, &quot;error_info&quot;,
        &quot;mac&quot;, &quot;vpd_entity&quot;, &quot;repay_ac_no&quot;, &quot;ln_ac_id&quot;, &quot;repay_ac_seqn&quot;,
        &quot;tx_date&quot;, &quot;opposite_br_no&quot;, &quot;repay_ac_name&quot;, &quot;send_prcl_amt&quot;, &quot;send_int_amt&quot;,
        &quot;send_settl_amt&quot;, &quot;batch_no&quot;
    ]

    with open(file_path, &#39;w&#39;, newline=&#39;&#39;) as f:
        writer = csv.writer(f)
        writer.writerow(header)  # 写入列头

        # 分批次生成数据（避免内存溢出）
        for i in tqdm(range(1, total_rows + 1), desc=&quot;Generating CSV&quot;):
            row = [
                f&quot;LE&#123;i:08d&#125;&quot;,                      # legal_entity
                f&quot;TX&#123;i:08d&#125;&quot;,                      # tx_trace_no
                f&quot;LOCAL&#123;i:08d&#125;&quot;,                   # tx_trace_no_local
                i,                                 # tx_trace_cnt
                &#39;0&#39; if random.random() &lt; 0.5 else &#39;1&#39;,  # settle_flag
                round(random.uniform(100, 10000), 2),  # prcl_amt
                round(random.uniform(10, 1000), 2),    # int_amt
                f&quot;CORE&#123;i:08d&#125;&quot;,                    # core_trace_no
                &#39;1&#39; if random.random() &lt; 0.9 else &#39;2&#39;, # deduct_sts
                &#39;No error&#39; if random.random() &lt; 0.95 else &#39;Error&#39;, # error_info
                f&quot;MAC&#123;i:08d&#125;&quot;,                     # mac
                random.randint(1, 1_000_000),      # vpd_entity
                f&quot;ACCT&#123;i:08d&#125;&quot;,                    # repay_ac_no
                random.randint(1, 10_000_000_000), # ln_ac_id
                random.randint(1, 100),            # repay_ac_seqn
                20230000 + random.randint(1, 365), # tx_date
                f&quot;BR&#123;i:08d&#125;&quot;,                      # opposite_br_no
                f&quot;Name&#123;i:08d&#125;&quot;,                    # repay_ac_name
                round(random.uniform(100, 10000), 2),  # send_prcl_amt
                round(random.uniform(10, 1000), 2),    # send_int_amt
                round(random.uniform(100, 11000), 2),  # send_settl_amt
                f&quot;BATCH&#123;i:08d&#125;&quot;                    # batch_no
            ]
            writer.writerow(row)

            # 每生成 batch_size 行刷新一次缓冲区
            if i % batch_size == 0:
                f.flush()

if __name__ == &quot;__main__&quot;:
    generate_csv(&quot;data.csv&quot;, total_rows=100_000_000) # 生成一千万条数据
</code></pre>
<h5 id="三、导入数据到数据库"><a href="#三、导入数据到数据库" class="headerlink" title="三、导入数据到数据库"></a>三、导入数据到数据库</h5><ol>
<li>将数据上传到服务器，并放到MySQL指定的目录下</li>
</ol>
<pre><code class="sql"># 执行下面命令
mysql&gt; SHOW VARIABLES LIKE &#39;secure_file_priv&#39;;
+------------------+-----------------------+
| Variable_name    | Value                 |
+------------------+-----------------------+
| secure_file_priv | /var/lib/mysql-files/ |
+------------------+-----------------------+
</code></pre>
<ol start="2">
<li>执行前关闭索引，执行结束后开启索引</li>
</ol>
<pre><code class="sql">-- 临时关闭索引更新（加速插入）
ALTER TABLE ln_batch_return_detail_mmdd DISABLE KEYS;
-- 插入完成后重建索引
ALTER TABLE ln_batch_return_detail_mmdd ENABLE KEYS;
</code></pre>
<ol start="3">
<li>进入数据库执行插入命令</li>
</ol>
<pre><code class="sql">-- 执行数据导入
LOAD DATA INFILE &#39;/path/to/data.csv&#39;
INTO TABLE `ln_batch_return_detail_mmdd`
FIELDS TERMINATED BY &#39;,&#39;     -- CSV字段分隔符（与生成文件时一致）
OPTIONALLY ENCLOSED BY &#39;&quot;&#39;   -- 字段包裹符（如果字段含逗号或换行符）
LINES TERMINATED BY &#39;\n&#39;     -- 行分隔符（Linux/Mac用\n，Windows用\r\n）
IGNORE 1 LINES               -- 跳过CSV文件的列头行
(
  `legal_entity`, `tx_trace_no`, `tx_trace_no_local`, `tx_trace_cnt`, `settle_flag`,
  `prcl_amt`, `int_amt`, `core_trace_no`, `deduct_sts`, `error_info`,
  `mac`, `vpd_entity`, `repay_ac_no`, `ln_ac_id`, `repay_ac_seqn`,
  `tx_date`, `opposite_br_no`, `repay_ac_name`, `send_prcl_amt`, `send_int_amt`,
  `send_settl_amt`, `batch_no`
);
</code></pre>
<p>4.查看成功写入1千万条数据</p>
<p><img src="../images/sql%E8%BE%93%E5%85%A5%E6%8F%92%E5%85%A5.png" alt="sql输入插入"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/" data-id="cm8h0o63c000d70vdb0e54127" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-在类中封装属性名" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/03/%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B0%81%E8%A3%85%E5%B1%9E%E6%80%A7%E5%90%8D/" class="article-date">
  <time datetime="2025-03-03T05:46:07.000Z" itemprop="datePublished">2025-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/03/%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B0%81%E8%A3%85%E5%B1%9E%E6%80%A7%E5%90%8D/">在类中封装属性名</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在面向对象编程中，<strong>封装属性名</strong>的目的是隐藏类的内部实现细节，通过受控的方法访问或修改数据，从而提高代码的安全性和可维护性</p>
<h4 id="一、-Python中的属性封装实现"><a href="#一、-Python中的属性封装实现" class="headerlink" title="一、 Python中的属性封装实现"></a>一、 Python中的属性封装实现</h4><ol>
<li>使用私有属性（名称改写）<pre><code>* 在属性名前添加双下划线__, Python会将其名称改写为 `_ClassName__attribute`，限制直接访问。
* 提供公有方法（getter/setter）或 `@property` 装饰器来访问和验证数据。
</code></pre>
</li>
</ol>
<pre><code class="python">class Person:
    def __init__(self, name, age):
        self.__name = name  # 私有属性
        self.__age = age

    # 使用@property 访问属性
    @property
    def name(self):
        return self.__name

    # 定义setter方法验证数据
    # 用于控制属性赋值逻辑的 setter 方法，它会验证你给属性赋的值是否合法
    @name.setter
    def name(self, value):
        if isinstance(value, str) and len(value) &gt; 0:
            self.__name = value
        else:
            raise ValueError(&quot;Invalid name&quot;)

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, value):
        if value &gt;= 0:
            self.__age = value
        else:
            raise ValueError(&quot;Age cannot be negative&quot;)

# 使用示例
p = Person(&quot;Alice&quot;, 30)
print(p.name)  # 输出: Alice
p.age = 25     # 合法操作
p.age = -5     # 抛出 ValueError

p.name = &quot;Bob&quot;
p.age = 44
print(p._Person__name)
print(p._Person__age)
</code></pre>
<ol start="2">
<li> @name.setter 的作用</li>
</ol>
<ul>
<li><p><em><strong>功能</strong></em>：这是一个装饰器，用来标记这是一个 <code>setter</code> 方法。当你给 <code>name</code> 属性赋值时（例如 <code>p.name = &quot;Bob&quot;</code>），<strong>自动触发</strong>这个方法。</p>
</li>
<li><p><strong>为什么需要</strong>：普通的属性赋值（如 <code>p.name = 123</code>）无法验证数据是否合法，而 <code>setter</code> 方法允许你在赋值前插入自定义检查逻辑。</p>
</li>
</ul>
<ol start="3">
<li> 方法内部的验证逻辑</li>
</ol>
<pre><code class="python">def name(self, value):
    if isinstance(value, str) and len(value) &gt; 0:  # 检查是否为非空字符串
        self.__name = value  # 合法则赋值给私有属性 __name
    else:
        raise ValueError(&quot;Invalid name&quot;)  # 非法则抛出异常
</code></pre>
<pre><code>    * **`isinstance(value, str)`** ：检查 `value` 是否是字符串类型（例如防止数字或对象被赋值给 `name`）。
    * **`len(value) &gt; 0`** ：确保字符串不是空的（例如防止 `name = &quot;&quot;`）。
</code></pre>
<ul>
<li><strong><code>raise ValueError</code></strong> ：如果值不合法，直接抛出错误，阻止赋值。</li>
</ul>
<ol start="4">
<li>和 @property 的关系</li>
</ol>
<ul>
<li><strong><code>@property</code> 定义 getter</strong>：负责读取属性时的逻辑（例如 <code>print(p.name)</code>）。</li>
<li><strong><code>@name.setter</code> 定义 setter</strong>：负责写入属性时的逻辑（例如 <code>p.name = &quot;Bob&quot;</code>）。</li>
<li><strong>配套使用</strong>：两者共同实现对属性的<strong>安全读写控制</strong>。</li>
</ul>
<ol start="5">
<li>为什么用 <code>self.__name</code></li>
</ol>
<ul>
<li><strong>双下划线 <code>__name</code></strong> ：这是 Python 的私有属性命名约定，实际会被改写为 <code>_Person__name</code>，防止外部直接访问（如 <code>p.__name</code> 会报错，但 <code>p._Person__name</code> 仍可访问，不过约定上不这样做）。</li>
<li><strong>封装目的</strong>：强制通过 <code>setter</code> 方法修改属性，确保所有赋值都经过验证。</li>
</ul>
<h4 id="二、封装的优势"><a href="#二、封装的优势" class="headerlink" title="二、封装的优势"></a>二、封装的优势</h4><ol>
<li><strong>数据保护</strong>：防止外部代码直接修改属性，避免非法值（如负数的年龄）。</li>
<li><strong>灵活性</strong>：可在方法中添加额外逻辑（如数据验证、日志记录）。</li>
<li><strong>兼容性</strong>：内部实现变化时，不影响外部代码（如重命名属性）。</li>
</ol>
<h4 id="三、单下划线和双下划线的区别"><a href="#三、单下划线和双下划线的区别" class="headerlink" title="三、单下划线和双下划线的区别"></a>三、单下划线和双下划线的区别</h4><h5 id="一、单下划线-name-受保护的属性（Portected）"><a href="#一、单下划线-name-受保护的属性（Portected）" class="headerlink" title="一、单下划线  _name : 受保护的属性（Portected）"></a>一、单下划线  _name : 受保护的属性（Portected）</h5><pre><code>1. 命名的约定：

    *  _name 表示这是一个内部属性，暗示开发者“不要直接访问，除非你知道自己在做什么”。
    *  不触发名称改写：名称保持为 _name, 没有自动重命名。
    *  访问权限：外部代码仍可以直接读写（p.name = 123）,但约定上应通过方法或属性装饰器操作。
</code></pre>
<ol start="2">
<li>典型用途：</li>
</ol>
<ul>
<li>类的内部状态管理（如缓存、临时变量）</li>
<li>子类继承时可以安全覆盖或者扩展</li>
</ul>
<pre><code class="python">class Person:
    def __init__(self, name):
        self._name = name  # 单下划线，约定上的“受保护”属性

p = Person(&quot;Alice&quot;)
print(p._name)  # 直接访问：输出 &quot;Alice&quot;（不推荐但允许）
</code></pre>
<h5 id="二、对比表格"><a href="#二、对比表格" class="headerlink" title="二、对比表格"></a>二、对比表格</h5><table>
<thead>
<tr>
<th>特性</th>
<th>单下划线 <code>_name</code></th>
<th>双下划线 <code>__name</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>名称改写</strong></td>
<td>无</td>
<td>有（改写为 <code>_ClassName__name</code>）</td>
</tr>
<tr>
<td><strong>直接外部访问</strong></td>
<td>允许（不推荐）</td>
<td>不允许（需改写后的名称）</td>
</tr>
<tr>
<td><strong>继承冲突防护</strong></td>
<td>无，子类可直接覆盖</td>
<td>有，避免子类同名属性冲突</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>约定上的内部属性</td>
<td>强制私有属性</td>
</tr>
</tbody></table>
<h5 id="三、何时选择哪种？"><a href="#三、何时选择哪种？" class="headerlink" title="三、何时选择哪种？"></a>三、何时选择哪种？</h5><ol>
<li><strong>用单下划线 <code>_name</code></strong> ：<ul>
<li>属性需要被子类继承或覆盖。</li>
<li>仅作为内部状态管理，不涉及敏感数据。</li>
<li>团队约定明确时（如 Django 框架常用 <code>_</code> 表示内部方法）。</li>
</ul>
</li>
<li><strong>用双下划线 <code>__name</code></strong> ：<ul>
<li>明确禁止外部直接访问（即使通过名称改写也不建议）。</li>
<li>避免多级继承中的属性命名冲突。</li>
<li>需要强制封装时（如属性值必须通过方法验证）。</li>
</ul>
</li>
</ol>
<h5 id="四、代码示例"><a href="#四、代码示例" class="headerlink" title="四、代码示例"></a>四、代码示例</h5><pre><code class="python">class Base:
    def __init__(self):
        self._protected = &quot;Base Protected&quot;  # 单下划线
        self.__private = &quot;Base Private&quot;     # 双下划线

class SubClass(Base):
    def __init__(self):
        super().__init__()
        self._protected = &quot;Sub Protected&quot;   # 直接覆盖父类的 _protected
        self.__private = &quot;Sub Private&quot;      # 实际名称是 _SubClass__private

    def show(self):
        print(self._protected)              # 输出 &quot;Sub Protected&quot;
        print(self.__private)               # 输出 &quot;Sub Private&quot;
        print(self._Base__private)           # 输出 &quot;Base Private&quot;（访问父类私有属性）

obj = SubClass()
obj.show()
</code></pre>
<h5 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h5><ul>
<li><strong>单下划线 <code>_name</code></strong> ：约定上的“内部属性”，轻量级封装。</li>
<li><strong>双下划线 <code>__name</code></strong> ：强制私有属性，通过名称改写避免冲突。</li>
<li>实际开发中，优先用单下划线，除非明确需要避免继承冲突或强制封装。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/03/%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B0%81%E8%A3%85%E5%B1%9E%E6%80%A7%E5%90%8D/" data-id="cm8h0o63q001y70vdbnzm5vr7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="tag">类与对象</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-对象支持上下文管理协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/03/%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2025-03-03T03:15:32.000Z" itemprop="datePublished">2025-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/03/%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/">对象支持上下文管理协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​            在 Python 中，让对象支持上下文管理协议，简单说就是让你的对象能和 with 语句配合使用，自动处理资源的打开和关闭（比如文件、网络连接、锁等），避免资源泄漏。</p>
<p>只需要在类中实现两个方法：</p>
<ol>
<li><p><strong>enter</strong>(self)</p>
<ul>
<li><p>当with语句开始调用时，返回你需要管理的资源（比如打开的文件对象）。</p>
</li>
<li><p>通常返回self, 但也可以返回其他对象。</p>
</li>
</ul>
</li>
<li><p><strong>exit</strong>(self，exc_type，exc_val，exc_tb)</p>
<ul>
<li><p>当 <code>with</code> 语句块<strong>结束</strong>时（无论是否发生异常）调用。</p>
</li>
<li><p>负责清理工作（比如关闭文件、释放锁）。</p>
</li>
</ul>
</li>
</ol>
<pre><code class="python"># 模拟文件打开器
class FileOpener:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file  # 返回文件对象，供 with 块内使用

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()  # 确保文件被关闭

# 使用 with 语句自动管理文件
with FileOpener(&quot;test.txt&quot;, &quot;w&quot;) as f:
    f.write(&quot;Hello, Context Manager!&quot;)
# 这里文件已自动关闭，无需手动调用 f.close()
</code></pre>
<p>✅ 为什么要用上下文管理？</p>
<ol>
<li><strong>资源安全</strong>：即使代码块中发生异常，<code>__exit__</code> 也会被调用，确保资源释放。</li>
<li><strong>代码简洁</strong>：避免了冗长的 <code>try...finally</code> 结构。</li>
<li><strong>可读性高</strong>：明确展示资源的作用域。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/03/%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/" data-id="cm8h0o63p001u70vdbzjwfzkp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="tag">类与对象</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自定义字符串的格式化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/03/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/" class="article-date">
  <time datetime="2025-03-03T02:22:58.000Z" itemprop="datePublished">2025-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/03/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/">自定义字符串的格式化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code class="python">_formats = &#123;
    &#39;ymd&#39; : &#39;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&#39;,
    &#39;mdy&#39; : &#39;&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;&#39;,
    &#39;dmy&#39; : &#39;&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;&#39;
    &#125;

class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def __format__(self, code):
        if code == &#39;&#39;:
            code = &#39;ymd&#39;
        fmt = _formats[code]
        return fmt.format(d=self) # 替换为 self.year, self.month, self.day 的实际值
ddd = Date(2012, 12, 21)
print(format(ddd, &#39;ymd&#39;))
print(&#39;The date is &#123;:mdy&#125;&#39;.format(ddd))


import math
# __format__ 专门用于格式化输出，支持动态格式控制（如精度、单位等）
# __str__ 和 __repr__ 用于一般字符串表示。
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __format__(self, format_spec):
        if format_spec == &#39;r&#39;:  # 直角坐标
            return f&quot;Vector(&#123;self.x&#125;, &#123;self.y&#125;)&quot;
        elif format_spec == &#39;p&#39;:  # 极坐标
            r = math.hypot(self.x, self.y)
            theta = math.degrees(math.atan2(self.y, self.x))
            return f&quot;Vector(r=&#123;r:.2f&#125;, θ=&#123;theta:.2f&#125;°)&quot;
        elif format_spec == &#39;&#39;:  # 默认格式
            return f&quot;Vector(&#123;self.x&#125;, &#123;self.y&#125;)&quot;
        else:
            raise ValueError(f&quot;Unknown format specifier &#39;&#123;format_spec&#125;&#39;&quot;)

# 使用示例
v = Vector(3, 4)

print(f&quot;&#123;v&#125;&quot;)          # 输出: Vector(3, 4)
print(f&quot;&#123;v:r&#125;&quot;)        # 输出: Vector(3, 4)
print(f&quot;&#123;v:p&#125;&quot;)        # 输出: Vector(r=5.00, θ=53.13°)
print(format(v, &#39;p&#39;))  # 输出: Vector(r=5.00, θ=53.13°)
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/" data-id="cm8h0o641003x70vdg6blebd3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="tag">类与对象</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux命令lsof" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/02/26/linux%E5%91%BD%E4%BB%A4lsof/" class="article-date">
  <time datetime="2025-02-26T06:15:44.000Z" itemprop="datePublished">2025-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux%E5%9F%BA%E7%A1%80/">linux基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/02/26/linux%E5%91%BD%E4%BB%A4lsof/">linux命令lsof</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-lsof简介"><a href="#1-lsof简介" class="headerlink" title="1.lsof简介"></a>1.lsof简介</h4><p>lsof(list open  files)可以列出当前系统中进程打开的所有文件，在Linux环境下，我们可以理解为一切(包括网络套接口)皆文件。在实际使用过程中，lsof是一款非常强大的系统监控和系统诊断工具。在终端下输入lsof 即可显示系统打开的文件， lsof 一般需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。</p>
<h4 id="2-lsof使用"><a href="#2-lsof使用" class="headerlink" title="2.lsof使用"></a>2.lsof使用</h4><h5 id="2-lsof-h-显示使用方法"><a href="#2-lsof-h-显示使用方法" class="headerlink" title="2.lsof -h 显示使用方法"></a>2.lsof -h 显示使用方法</h5><p><img src="../images/lsof.png" alt="lsof"></p>
<p>2.2终端下输入lsof命令，打开前三个文件</p>
<p><img src="../images/lsof_head.jpg" alt="lsof_head"></p>
<p>2.3lsof输出每列含义如下</p>
<pre><code class="text">COMMAND：进程的名称
PID：进程标识符
TID：任务 ID。Linux 下 TID 为空表示该行为进程
USER：进程所有者
FD：文件描述符。主要有：
    cwd：应用程序当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改
    txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序
    lnn：库引用（AIX）
    err：FD 信息错误
    jld：监狱目录（FreeBSD）
    ltx：共享库文本（代码和数据）
    mxx：十六进制内存映射类型号 xx
    m86：DOS合并映射文件
    mem：内存映射文件
    mmap：内存映射设备
    pd：父目录
    rtd：根目录
    tr：内核跟踪文件（OpenBSD）
    v86：VP/ix 映射文件
    0：标准输出
    1：标准输入
    2：标准错误
    文件描述符后一般还跟着文件状态模式：
    r：只读模式
    w：写入模式
    u：读写模式
    空格：文件的状态模式为 unknow，且没有锁定
    -：文件的状态模式为 unknow，且被锁定
    
    同时在文件状态模式后面，还跟着相关的锁：
    N：对于未知类型的 Solaris NFS 锁
    r：文件部分的读锁
    R：整个文件的读锁
    w：文件的部分写锁
    W：整个文件的写锁
    u：任何长度的读写锁
    U：用于未知类型的锁
    x：用于部分文件上的 SCO OpenServer Xenix 锁
    X：用于整个文件上的 SCO OpenServer Xenix 锁
    space：无锁
TYPE：文件类型。常见的文件类型有：
    REG：普通文件
    DIR：表示目录
    CHR：表示字符类型
    BLK：块设备类型
    UNIX：UNIX 域套接字
    FIFO：先进先出队列
    IPv4：IPv4 套接字
DEVICE：磁盘名称
SIZE：文件的大小或文件偏移量（以字节为单位）
NODE：索引节点
NAME：打开文件的确切名称
</code></pre>
<p>2.4 Linux上常用的几种用法</p>
<p>lsof -i  显示所有网络连接</p>
<p>lsof  filename 显示打开指定文件的所有进程</p>
<p>lsof -a 表示两个参数都必须满足时才显示结果</p>
<p>lsof -c string   显示COMMAND列中包含指定字符的进程所有打开的文件</p>
<p>lsof -u username  显示所属user进程打开的文件</p>
<p>lsof -g gid 显示归属gid的进程情况</p>
<p>lsof +d /DIR/ 显示目录下被进程打开的文件</p>
<p>lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长</p>
<p>lsof -d FD 显示指定文件描述符的进程</p>
<p>lsof -n 不将IP转换为hostname，缺省是不加上-n参数</p>
<p>lsof -i 用以显示符合条件的进程情况</p>
<p>2.5 显示指定程序的端口号</p>
<p><img src="../images/lsof_i.jpg" alt="lsof_i"></p>
<h4 id="3-Lsof解决Device-is-busy问题"><a href="#3-Lsof解决Device-is-busy问题" class="headerlink" title="3.Lsof解决Device is busy问题"></a>3.Lsof解决Device is busy问题</h4><p>在系统运维过程中，我们会遇到磁盘卸载报umount: /home: device is busy之类的提示</p>
<p><img src="../images/umount.jpg" alt="umount"></p>
<h5 id="3-1-使用lsof命令找出占用磁盘的进程"><a href="#3-1-使用lsof命令找出占用磁盘的进程" class="headerlink" title="3.1 使用lsof命令找出占用磁盘的进程"></a>3.1 使用lsof命令找出占用磁盘的进程</h5><p><img src="../images/lsof_home.jpg" alt="lsof_home"></p>
<p>直接kill掉此进程(kill -9 5689)，umount /home/后目录成功卸载</p>
<p>umount -l /home 强行解除挂载</p>
<p>fuser  -mv -k /home直接杀死占用磁盘的进程</p>
<p>3.2 <strong>Lsof解决文件已删除空间未释放问题</strong></p>
<p>磁盘空间达到100%会导致数据无法正常写入文件造成程序异常，如下/home空间达到100%，一般的解决方法是先删除大文件，然后有必要的情况下对磁盘进行扩容。</p>
<p>按照排查步骤，先进入/home目录查找占用磁盘的大文件（命令du -h –max-depth=1 /home），如下发现/home目录下并没有占用空间大的文件和目录。</p>
<p>为什么磁盘空间显示占用100%呢？原因是磁盘上文件已经被删除，但是存在进程仍然占用这些文件，因此其原来占用的磁盘空间并没有被释放，当然重启操作系统，空间会被释放出来，但是重启并不是最好的解决方法。</p>
<p>lsof -n | grep delete检查出占用文件的进程</p>
<p><img src="../images/delete.jpg" alt="delete"></p>
<p>从进程显示上可以看出，/home目录下占用文件已经删除，仍然有3个进程在占用，我们采用kill方式杀死进程，释放空间。</p>
<p><img src="../images/kill.jpg" alt="kill"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/26/linux%E5%91%BD%E4%BB%A4lsof/" data-id="cm8h0o63b000870vd032j9grm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4/" rel="tag">linux命令</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jmeter/">jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%9F%BA%E7%A1%80/">linux基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/pytest/">pytest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/selenium/">selenium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/unittest/">unittest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%84%E7%90%86Excel%E6%96%87%E4%BB%B6/">处理Excel文件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/">接口测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrony/" rel="tag">Chrony</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Excel/" rel="tag">Excel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csv/" rel="tag">csv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" rel="tag">jmeter_cookie处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" rel="tag">jmeter参数化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%91%BD%E4%BB%A4/" rel="tag">linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql%E6%9D%83%E9%99%90/" rel="tag">mysql权限</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ntpd/" rel="tag">ntpd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest/" rel="tag">pytest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pytest%E5%9F%BA%E7%A1%80/" rel="tag">pytest基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" rel="tag">selenium多窗口_警告框处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E5%AE%9A%E4%BD%8D/" rel="tag">selenium定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" rel="tag">selenium时间等待</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unittest%E6%A6%82%E5%BF%B5/" rel="tag">unittest概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" rel="tag">接口基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="tag">类与对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%85%B6%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" rel="tag">迭代其和生成器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" rel="tag">迭代器和生成器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Chrony/" style="font-size: 10px;">Chrony</a> <a href="/tags/Excel/" style="font-size: 13.33px;">Excel</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/csv/" style="font-size: 10px;">csv</a> <a href="/tags/jmeter-cookie%E5%A4%84%E7%90%86/" style="font-size: 10px;">jmeter_cookie处理</a> <a href="/tags/jmeter%E5%8F%82%E6%95%B0%E5%8C%96/" style="font-size: 10px;">jmeter参数化</a> <a href="/tags/linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">linux命令</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/mysql%E6%9D%83%E9%99%90/" style="font-size: 10px;">mysql权限</a> <a href="/tags/ntpd/" style="font-size: 10px;">ntpd</a> <a href="/tags/pytest/" style="font-size: 10px;">pytest</a> <a href="/tags/pytest%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">pytest基础</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/selenium%E5%A4%9A%E7%AA%97%E5%8F%A3-%E8%AD%A6%E5%91%8A%E6%A1%86%E5%A4%84%E7%90%86/" style="font-size: 10px;">selenium多窗口_警告框处理</a> <a href="/tags/selenium%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">selenium定位</a> <a href="/tags/selenium%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85/" style="font-size: 10px;">selenium时间等待</a> <a href="/tags/unittest%E6%A6%82%E5%BF%B5/" style="font-size: 13.33px;">unittest概念</a> <a href="/tags/%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">接口基础</a> <a href="/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" style="font-size: 20px;">类与对象</a> <a href="/tags/%E8%BF%AD%E4%BB%A3%E5%85%B6%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" style="font-size: 16.67px;">迭代其和生成器</a> <a href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" style="font-size: 10px;">迭代器和生成器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/20/%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3/">反向迭代</a>
          </li>
        
          <li>
            <a href="/2025/03/20/%E7%94%9F%E6%88%90%E5%99%A8%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/">生成器创建自定义迭代模式</a>
          </li>
        
          <li>
            <a href="/2025/03/20/%E4%BB%A3%E7%90%86%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/">代理迭代的实现</a>
          </li>
        
          <li>
            <a href="/2025/03/20/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/">python迭代器和生成器</a>
          </li>
        
          <li>
            <a href="/2025/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE/">服务器同步时间配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 当时只道是寻常<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>